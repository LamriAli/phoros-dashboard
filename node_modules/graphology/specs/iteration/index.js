"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = iteration;

var _assert = _interopRequireDefault(require("assert"));

var _take = _interopRequireDefault(require("obliterator/take"));

var _nodes = _interopRequireDefault(require("./nodes"));

var _edges = _interopRequireDefault(require("./edges"));

var _neighbors = _interopRequireDefault(require("./neighbors"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * Graphology Iteration Specs
 * ===========================
 *
 * Testing the iteration-related methods of the graph.
 */
function iteration(Graph, checkers) {
  return {
    Adjacency: {
      'it should be possible to iterate over the graph\'s adjacency using callbacks.': function itShouldBePossibleToIterateOverTheGraphSAdjacencyUsingCallbacks() {
        var graph = new Graph();
        graph.mergeEdge(1, 2);
        graph.mergeEdge(2, 3);
        graph.mergeEdge(3, 1);
        graph.replaceNodeAttributes(2, {
          hello: 'world'
        });
        var adjacency = [];
        graph.forEach(function (s, t, sa, ta, e, ea) {
          adjacency.push([s, t]);

          _assert["default"].deepEqual(sa, graph.getNodeAttributes(s));

          _assert["default"].deepEqual(ta, graph.getNodeAttributes(t));

          _assert["default"].deepEqual(ea, graph.getEdgeAttributes(e));
        });

        _assert["default"].deepEqual(adjacency, [[1, 2], [2, 3], [3, 1]]);
      },
      'it should be possible to create an iterator over the graph\'s adjacency.': function itShouldBePossibleToCreateAnIteratorOverTheGraphSAdjacency() {
        var graph = new Graph();
        graph.mergeEdge(1, 2);
        graph.mergeEdge(2, 3);
        graph.mergeEdge(3, 1);
        graph.replaceNodeAttributes(2, {
          hello: 'world'
        });

        _assert["default"].deepEqual((0, _take["default"])(graph.adjacency()), graph.edges().map(function (edge) {
          var _graph$extremities = graph.extremities(edge),
              source = _graph$extremities[0],
              target = _graph$extremities[1];

          return [source, target, graph.getNodeAttributes(source), graph.getNodeAttributes(target), edge, graph.getEdgeAttributes(edge)];
        }));
      },
      'it should be possible to iterate via Symbol.iterator.': function itShouldBePossibleToIterateViaSymbolIterator() {
        if (typeof Symbol === 'undefined') return;
        var graph = new Graph();
        graph.mergeEdge(1, 2);
        graph.mergeEdge(2, 3);
        graph.mergeEdge(3, 1);
        graph.replaceNodeAttributes(2, {
          hello: 'world'
        });

        _assert["default"].deepEqual((0, _take["default"])(graph[Symbol.iterator]()), graph.edges().map(function (edge) {
          var _graph$extremities2 = graph.extremities(edge),
              source = _graph$extremities2[0],
              target = _graph$extremities2[1];

          return [source, target, graph.getNodeAttributes(source), graph.getNodeAttributes(target), edge, graph.getEdgeAttributes(edge)];
        }));
      }
    },
    Nodes: (0, _nodes["default"])(Graph, checkers),
    Edges: (0, _edges["default"])(Graph, checkers),
    Neighbors: (0, _neighbors["default"])(Graph, checkers)
  };
}