{"version":3,"file":"graphology.cjs.js","sources":["../src/utils.js","../src/errors.js","../src/data.js","../src/indices.js","../src/attributes.js","../src/iteration/edges.js","../src/iteration/neighbors.js","../src/serialization.js","../src/graph.js","../src/classes.js","../src/endpoint.cjs.js"],"sourcesContent":["/**\n * Graphology Utilities\n * =====================\n *\n * Collection of helpful functions used by the implementation.\n */\n\n/**\n * Very simple Object.assign-like function.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nexport function assign() {\n  const target = arguments[0] || {};\n\n  for (let i = 1, l = arguments.length; i < l; i++) {\n    if (!arguments[i])\n      continue;\n\n    for (const k in arguments[i])\n      target[k] = arguments[i][k];\n  }\n\n  return target;\n}\n\n/**\n * Function returning the first matching edge for given path.\n * Note: this function does not check the existence of source & target. This\n * must be performed by the caller.\n *\n * @param  {Graph}  graph  - Target graph.\n * @param  {any}    source - Source node.\n * @param  {any}    target - Target node.\n * @param  {string} type   - Type of the edge (mixed, directed or undirected).\n * @return {string|null}\n */\nexport function getMatchingEdge(graph, source, target, type) {\n  const sourceData = graph._nodes.get(source);\n\n  let edge = null;\n\n  if (!sourceData)\n    return edge;\n\n  if (type === 'mixed') {\n    edge = (\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target])\n    );\n  }\n  else if (type === 'directed') {\n    edge = sourceData.out && sourceData.out[target];\n  }\n  else {\n    edge = sourceData.undirected && sourceData.undirected[target];\n  }\n\n  return edge;\n}\n\n/**\n * Checks whether the given value is a Graph implementation instance.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isGraph(value) {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof value.addUndirectedEdgeWithKey === 'function' &&\n    typeof value.dropNode === 'function'\n  );\n}\n\n/**\n * Checks whether the given value is a plain object.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isPlainObject(value) {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    value.constructor === Object\n  );\n}\n\n/**\n * Pretty prints the given integer.\n *\n * @param  {number}  integer - Target integer.\n * @return {string}          - The pretty string.\n */\nexport function prettyPrint(integer) {\n  const string = '' + integer;\n\n  let prettyString = '';\n\n  for (let i = 0, l = string.length; i < l; i++) {\n    const j = l - i - 1;\n\n    prettyString = string[j] + prettyString;\n\n    if (!((i - 2) % 3) && i !== l - 1)\n      prettyString = ',' + prettyString;\n  }\n\n  return prettyString;\n}\n\n/**\n * Creates a \"private\" property for the given member name by concealing it\n * using the `enumerable` option.\n *\n * @param {object} target - Target object.\n * @param {string} name   - Member name.\n */\nexport function privateProperty(target, name, value) {\n  Object.defineProperty(target, name, {\n    enumerable: false,\n    configurable: false,\n    writable: true,\n    value\n  });\n}\n\n\n/**\n * Creates a read-only property for the given member name & the given getter.\n *\n * @param {object}   target - Target object.\n * @param {string}   name   - Member name.\n * @param {mixed}    value  - The attached getter or fixed value.\n */\nexport function readOnlyProperty(target, name, value) {\n  const descriptor = {\n    enumerable: true,\n    configurable: true\n  };\n\n  if (typeof value === 'function') {\n    descriptor.get = value;\n  }\n  else {\n    descriptor.value = value;\n    descriptor.writable = false;\n  }\n\n  Object.defineProperty(target, name, descriptor);\n}\n\n/**\n * Creates a function generating incremental ids for edges.\n *\n * @return {function}\n */\nexport function incrementalId() {\n  let i = 0;\n\n  return () => {\n    return `_geid${i++}_`;\n  };\n}\n","/**\n * Graphology Custom Errors\n * =========================\n *\n * Defining custom errors for ease of use & easy unit tests across\n * implementations (normalized typology rather than relying on error\n * messages to check whether the correct error was found).\n */\nexport class GraphError extends Error {\n  constructor(message, data) {\n    super();\n    this.name = 'GraphError';\n    this.message = message || '';\n    this.data = data || {};\n  }\n}\n\nexport class InvalidArgumentsGraphError extends GraphError {\n  constructor(message, data) {\n    super(message, data);\n    this.name = 'InvalidArgumentsGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, InvalidArgumentsGraphError.prototype.constructor);\n  }\n}\n\nexport class NotFoundGraphError extends GraphError {\n  constructor(message, data) {\n    super(message, data);\n    this.name = 'NotFoundGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, NotFoundGraphError.prototype.constructor);\n  }\n}\n\nexport class UsageGraphError extends GraphError {\n  constructor(message, data) {\n    super(message, data);\n    this.name = 'UsageGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, UsageGraphError.prototype.constructor);\n  }\n}\n","/**\n * Graphology Internal Data Classes\n * =================================\n *\n * Internal classes hopefully reduced to structs by engines & storing\n * necessary information for nodes & edges.\n *\n * Note that those classes don't rely on the `class` keyword to avoid some\n * cruft introduced by most of ES2015 transpilers.\n */\n\n/**\n * MixedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function MixedNodeData(key, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.undirectedDegree = 0;\n  this.directedSelfLoops = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n  this.undirected = {};\n}\n\n/**\n * DirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function DirectedNodeData(key, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes || {};\n\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n}\n\nDirectedNodeData.prototype.upgradeToMixed = function() {\n\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.undirected = {};\n};\n\n\n/**\n * UndirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function UndirectedNodeData(key, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes || {};\n\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.undirected = {};\n}\n\nUndirectedNodeData.prototype.upgradeToMixed = function() {\n\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n};\n\n/**\n * DirectedEdgeData class.\n *\n * @constructor\n * @param {string}  string       - The edge's key.\n * @param {boolean} generatedKey - Was its key generated?\n * @param {string}  source       - Source of the edge.\n * @param {string}  target       - Target of the edge.\n * @param {object}  attributes   - Edge's attributes.\n */\nexport function DirectedEdgeData(key, generatedKey, source, target, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  // Extremities\n  this.source = source;\n  this.target = target;\n\n  // Was its key generated?\n  this.generatedKey = generatedKey;\n}\n\n/**\n * UndirectedEdgeData class.\n *\n * @constructor\n * @param {string}  string       - The edge's key.\n * @param {boolean} generatedKey - Was its key generated?\n * @param {string}  source       - Source of the edge.\n * @param {string}  target       - Target of the edge.\n * @param {object}  attributes   - Edge's attributes.\n */\nexport function UndirectedEdgeData(key, generatedKey, source, target, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  // Extremities\n  this.source = source;\n  this.target = target;\n\n  // Was its key generated?\n  this.generatedKey = generatedKey;\n}\n","/**\n * Graphology Indexes Functions\n * =============================\n *\n * Bunch of functions used to compute or clear indexes.\n */\n\n/**\n * Function updating the 'structure' index with the given edge's data.\n * Note that in the case of the multi graph, related edges are stored in a\n * set that is the same for A -> B & B <- A.\n *\n * @param {Graph}    graph      - Target Graph instance.\n * @param {EdgeData} edgeData   - Added edge's data.\n * @param {NodeData} sourceData - Source node's data.\n * @param {NodeData} targetData - Target node's data.\n */\nexport function updateStructureIndex(\n  graph,\n  undirected,\n  edgeData,\n  source,\n  target,\n  sourceData,\n  targetData\n) {\n  const multi = graph.multi;\n\n  const outKey = undirected ? 'undirected' : 'out',\n        inKey = undirected ? 'undirected' : 'in';\n\n  // Handling source\n  let edgeOrSet = sourceData[outKey][target];\n\n  if (typeof edgeOrSet === 'undefined') {\n    edgeOrSet = multi ? new Set() : edgeData;\n    sourceData[outKey][target] = edgeOrSet;\n  }\n\n  if (multi)\n    edgeOrSet.add(edgeData);\n\n  // If selfLoop, we break here\n  if (source === target)\n    return;\n\n  // Handling target (we won't add the edge because it was already taken\n  // care of with source above)\n  if (typeof targetData[inKey][source] === 'undefined')\n    targetData[inKey][source] = edgeOrSet;\n}\n\n/**\n * Function clearing the 'structure' index data related to the given edge.\n *\n * @param {Graph}    graph    - Target Graph instance.\n * @param {EdgeData} edgeData - Dropped edge's data.\n */\nexport function clearEdgeFromStructureIndex(graph, undirected, edgeData) {\n  const multi = graph.multi;\n\n  const {source: sourceData, target: targetData} = edgeData;\n\n  const source = sourceData.key,\n        target = targetData.key;\n\n  // NOTE: since the edge set is the same for source & target, we can only\n  // affect source\n  const outKey = undirected ? 'undirected' : 'out',\n        sourceIndex = sourceData[outKey];\n\n  const inKey = undirected ? 'undirected' : 'in';\n\n  if (target in sourceIndex) {\n\n    if (multi) {\n      const set = sourceIndex[target];\n\n      if (set.size === 1) {\n        delete sourceIndex[target];\n        delete targetData[inKey][source];\n      }\n      else {\n        set.delete(edgeData);\n      }\n    }\n    else\n      delete sourceIndex[target];\n  }\n\n  if (multi)\n    return;\n\n  const targetIndex = targetData[inKey];\n\n  delete targetIndex[source];\n}\n\n/**\n * Function clearing the whole 'structure' index.\n *\n * @param {Graph} graph - Target Graph instance.\n */\nexport function clearStructureIndex(graph) {\n  graph._nodes.forEach(data => {\n\n    // Clearing now useless properties\n    if (typeof data.in !== 'undefined') {\n      data.in = {};\n      data.out = {};\n    }\n\n    if (typeof data.undirected !== 'undefined') {\n      data.undirected = {};\n    }\n  });\n}\n\n/**\n * Function used to upgrade a simple `structure` index to a multi on.\n *\n * @param {Graph}  graph - Target Graph instance.\n */\nexport function upgradeStructureIndexToMulti(graph) {\n  graph._nodes.forEach((data, node) => {\n\n    // Directed\n    if (data.out) {\n\n      for (const neighbor in data.out) {\n        const edges = new Set();\n        edges.add(data.out[neighbor]);\n        data.out[neighbor] = edges;\n        graph._nodes.get(neighbor).in[node] = edges;\n      }\n    }\n\n    // Undirected\n    if (data.undirected) {\n      for (const neighbor in data.undirected) {\n        if (neighbor > node)\n          continue;\n\n        const edges = new Set();\n        edges.add(data.undirected[neighbor]);\n        data.undirected[neighbor] = edges;\n        graph._nodes.get(neighbor).undirected[node] = edges;\n      }\n    }\n  });\n}\n","/**\n * Graphology Attributes methods\n * ==============================\n *\n * Attributes-related methods being exactly the same for nodes & edges,\n * we abstract them here for factorization reasons.\n */\nimport {\n  assign,\n  isPlainObject,\n  getMatchingEdge\n} from './utils';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\nimport {\n  DirectedEdgeData,\n  UndirectedEdgeData\n} from './data';\n\n/**\n * Attach an attribute getter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\nfunction attachAttributeGetter(Class, method, type, EdgeDataClass) {\n\n  /**\n   * Get the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {mixed}          - The attribute's value.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    return data.attributes[name];\n  };\n}\n\n/**\n * Attach an attributes getter method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\nfunction attachAttributesGetter(Class, method, type, EdgeDataClass) {\n\n  /**\n   * Retrieves all the target element's attributes.\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   *\n   * @return {object}          - The element's attributes.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 1) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + arguments[1];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    return data.attributes;\n  };\n}\n\n/**\n * Attach an attribute checker method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\nfunction attachAttributeChecker(Class, method, type, EdgeDataClass) {\n\n  /**\n   * Checks whether the desired attribute is set for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\n/**\n * Attach an attribute setter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\nfunction attachAttributeSetter(Class, method, type, EdgeDataClass) {\n\n  /**\n   * Set the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name, value) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 3) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n      value = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      meta: {\n        name,\n        value\n      }\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\nfunction attachAttributeUpdater(Class, method, type, EdgeDataClass) {\n\n  /**\n   * Update the desired attribute for the given element (node or edge) using\n   * the provided function.\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 3) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n      updater = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(`Graph.${method}: updater should be a function.`);\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    data.attributes[name] = updater(data.attributes[name]);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      meta: {\n        name,\n        value: data.attributes[name]\n      }\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute remover method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\nfunction attachAttributeRemover(Class, method, type, EdgeDataClass) {\n\n  /**\n   * Remove the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      meta: {\n        name\n      }\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute replacer method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\nfunction attachAttributesReplacer(Class, method, type, EdgeDataClass) {\n\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - New attributes.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - New attributes.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(`Graph.${method}: provided attributes are not a plain object.`);\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    const oldAttributes = data.attributes;\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      meta: {\n        before: oldAttributes,\n        after: attributes\n      }\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute merger method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\nfunction attachAttributesMerger(Class, method, type, EdgeDataClass) {\n\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - Attributes to merge.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - Attributes to merge.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(`Graph.${method}: provided attributes are not a plain object.`);\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      meta: {\n        data: attributes\n      }\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachAttributesMerger\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nexport function attachAttributesMethods(Graph) {\n  ATTRIBUTES_METHODS.forEach(function({name, attacher}) {\n\n    // For edges\n    attacher(\n      Graph,\n      name('Edge'),\n      'mixed',\n      DirectedEdgeData\n    );\n\n    // For directed edges\n    attacher(\n      Graph,\n      name('DirectedEdge'),\n      'directed',\n      DirectedEdgeData\n    );\n\n    // For undirected edges\n    attacher(\n      Graph,\n      name('UndirectedEdge'),\n      'undirected',\n      UndirectedEdgeData\n    );\n  });\n}\n","/**\n * Graphology Edge Iteration\n * ==========================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's edges.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError\n} from '../errors';\n\nimport {UndirectedEdgeData} from '../data';\n\n/**\n * Definitions.\n */\nconst EDGES_ITERATION = [\n  {\n    name: 'edges',\n    type: 'mixed'\n  },\n  {\n    name: 'inEdges',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outEdges',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundEdges',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundEdges',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedEdges',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedEdges',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function collecting edges from the given object.\n *\n * @param  {array}  edges  - Edges array to populate.\n * @param  {object} object - Target object.\n * @return {array}         - The found edges.\n */\nfunction collect(edges, object) {\n  for (const k in object) {\n    if (object[k] instanceof Set)\n      object[k].forEach(edgeData => edges.push(edgeData.key));\n    else\n      edges.push(object[k].key);\n  }\n}\n\n/**\n * Function iterating over edges from the given object using a callback.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction forEachSimple(object, callback) {\n  for (const k in object) {\n    const edgeData = object[k];\n\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes\n    );\n  }\n}\n\nfunction forEachMulti(object, callback) {\n  for (const k in object) {\n    object[k].forEach(edgeData => callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes\n    ));\n  }\n}\n\n/**\n * Function returning an iterator over edges from the given object.\n *\n * @param  {object}   object - Target object.\n * @return {Iterator}\n */\nfunction createIterator(object) {\n  const keys = Object.keys(object),\n        l = keys.length;\n\n  let inner = null,\n      i = 0;\n\n  return new Iterator(function next() {\n    let edgeData;\n\n    if (inner) {\n      const step = inner.next();\n\n      if (step.done) {\n        inner = null;\n        i++;\n        return next();\n      }\n\n      edgeData = step.value;\n    }\n    else {\n      if (i >= l)\n        return {done: true};\n\n      const k = keys[i];\n\n      edgeData = object[k];\n\n      if (edgeData instanceof Set) {\n        inner = edgeData.values();\n        return next();\n      }\n\n      i++;\n    }\n\n    return {\n      done: false,\n      value: [\n        edgeData.key,\n        edgeData.attributes,\n        edgeData.source.key,\n        edgeData.target.key,\n        edgeData.source.attributes,\n        edgeData.target.attributes\n      ]\n    };\n  });\n}\n\n/**\n * Function collecting edges from the given object at given key.\n *\n * @param  {array}  edges  - Edges array to populate.\n * @param  {object} object - Target object.\n * @param  {mixed}  k      - Neighbor key.\n * @return {array}         - The found edges.\n */\nfunction collectForKey(edges, object, k) {\n\n  if (!(k in object))\n    return;\n\n  if (object[k] instanceof Set)\n    object[k].forEach(edgeData => edges.push(edgeData.key));\n  else\n    edges.push(object[k].key);\n\n  return;\n}\n\n/**\n * Function iterating over the egdes from the object at given key using\n * a callback.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction forEachForKey(object, k, callback) {\n\n  if (!(k in object))\n    return;\n\n  if (object[k] instanceof Set)\n    object[k].forEach(edgeData => callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes\n    ));\n  else {\n    const edgeData = object[k];\n\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes\n    );\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over the egdes from the object at given key.\n *\n * @param  {object}   object   - Target object.\n * @param  {mixed}    k        - Neighbor key.\n * @return {Iterator}\n */\nfunction createIteratorForKey(object, k) {\n  const v = object[k];\n\n  if (v instanceof Set) {\n    const iterator = v.values();\n\n    return new Iterator(function() {\n      const step = iterator.next();\n\n      if (step.done)\n        return step;\n\n      const edgeData = step.value;\n\n      return {\n        done: false,\n        value: [\n          edgeData.key,\n          edgeData.attributes,\n          edgeData.source.key,\n          edgeData.target.key,\n          edgeData.source.attributes,\n          edgeData.target.attributes\n        ]\n      };\n    });\n  }\n\n  return Iterator.of([\n    v.key,\n    v.attributes,\n    v.source.key,\n    v.target.key,\n    v.source.attributes,\n    v.target.attributes\n  ]);\n}\n\n/**\n * Function creating an array of edges for the given type.\n *\n * @param  {Graph}   graph - Target Graph instance.\n * @param  {string}  type  - Type of edges to retrieve.\n * @return {array}         - Array of edges.\n */\nfunction createEdgeArray(graph, type) {\n  if (graph.size === 0)\n    return [];\n\n  if (type === 'mixed' || type === graph.type)\n    return take(graph._edges.keys(), graph._edges.size);\n\n  const size = type === 'undirected' ?\n    graph.undirectedSize :\n    graph.directedSize;\n\n  const list = new Array(size),\n        mask = type === 'undirected';\n\n  let i = 0;\n\n  graph._edges.forEach((data, edge) => {\n\n    if ((data instanceof UndirectedEdgeData) === mask)\n      list[i++] = edge;\n  });\n\n  return list;\n}\n\n/**\n * Function iterating over a graph's edges using a callback.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction forEachEdge(graph, type, callback) {\n  if (graph.size === 0)\n    return;\n\n  if (type === 'mixed' || type === graph.type) {\n    graph._edges.forEach((data, key) => {\n\n      const {attributes, source, target} = data;\n\n      callback(\n        key,\n        attributes,\n        source.key,\n        target.key,\n        source.attributes,\n        target.attributes\n      );\n    });\n  }\n  else {\n    const mask = type === 'undirected';\n\n    graph._edges.forEach((data, key) => {\n      if ((data instanceof UndirectedEdgeData) === mask) {\n\n        const {attributes, source, target} = data;\n\n        callback(\n          key,\n          attributes,\n          source.key,\n          target.key,\n          source.attributes,\n          target.attributes\n        );\n      }\n    });\n  }\n}\n\n/**\n * Function creating an iterator of edges for the given type.\n *\n * @param  {Graph}    graph - Target Graph instance.\n * @param  {string}   type  - Type of edges to retrieve.\n * @return {Iterator}\n */\nfunction createEdgeIterator(graph, type) {\n  if (graph.size === 0)\n    return Iterator.empty();\n\n  let iterator;\n\n  if (type === 'mixed') {\n    iterator = graph._edges.values();\n\n    return new Iterator(function next() {\n      const step = iterator.next();\n\n      if (step.done)\n        return step;\n\n      const data = step.value;\n\n      const value = [\n        data.key,\n        data.attributes,\n        data.source.key,\n        data.target.key,\n        data.source.attributes,\n        data.target.attributes\n      ];\n\n      return {value, done: false};\n    });\n  }\n\n  iterator = graph._edges.values();\n\n  return new Iterator(function next() {\n    const step = iterator.next();\n\n    if (step.done)\n      return step;\n\n    const data = step.value;\n\n    if ((data instanceof UndirectedEdgeData) === (type === 'undirected')) {\n      const value = [\n        data.key,\n        data.attributes,\n        data.source.key,\n        data.target.key,\n        data.source.attributes,\n        data.target.attributes\n      ];\n\n      return {value, done: false};\n    }\n\n    return next();\n  });\n}\n\n/**\n * Function creating an array of edges for the given type & the given node.\n *\n * @param  {string}  type      - Type of edges to retrieve.\n * @param  {string}  direction - In or out?\n * @param  {any}     nodeData  - Target node's data.\n * @return {array}             - Array of edges.\n */\nfunction createEdgeArrayForNode(type, direction, nodeData) {\n  const edges = [];\n\n  if (type !== 'undirected') {\n    if (direction !== 'out')\n      collect(edges, nodeData.in);\n    if (direction !== 'in')\n      collect(edges, nodeData.out);\n  }\n\n  if (type !== 'directed') {\n    collect(edges, nodeData.undirected);\n  }\n\n  return edges;\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction forEachEdgeForNode(multi, type, direction, nodeData, callback) {\n  const fn = multi ? forEachMulti : forEachSimple;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out')\n      fn(nodeData.in, callback);\n    if (direction !== 'in')\n      fn(nodeData.out, callback);\n  }\n\n  if (type !== 'directed') {\n    fn(nodeData.undirected, callback);\n  }\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createEdgeIteratorForNode(type, direction, nodeData) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined')\n      iterator = chain(iterator, createIterator(nodeData.in));\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined')\n      iterator = chain(iterator, createIterator(nodeData.out));\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    iterator = chain(iterator, createIterator(nodeData.undirected));\n  }\n\n  return iterator;\n}\n\n/**\n * Function creating an array of edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {any}      target     - Target node.\n * @return {array}               - Array of edges.\n */\nfunction createEdgeArrayForPath(type, direction, sourceData, target) {\n  const edges = [];\n\n  if (type !== 'undirected') {\n\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out')\n      collectForKey(edges, sourceData.in, target);\n\n    if (typeof sourceData.out !== 'undefined' && direction !== 'in')\n      collectForKey(edges, sourceData.out, target);\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined')\n      collectForKey(edges, sourceData.undirected, target);\n  }\n\n  return edges;\n}\n\n/**\n * Function iterating over edges for the given path using a callback.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction forEachEdgeForPath(type, direction, sourceData, target, callback) {\n  if (type !== 'undirected') {\n\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out')\n      forEachForKey(sourceData.in, target, callback);\n\n    if (typeof sourceData.out !== 'undefined' && direction !== 'in')\n      forEachForKey(sourceData.out, target, callback);\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined')\n      forEachForKey(sourceData.undirected, target, callback);\n  }\n}\n\n/**\n * Function returning an iterator over edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction createEdgeIteratorForPath(type, direction, sourceData, target) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n\n    if (\n      typeof sourceData.in !== 'undefined' &&\n      direction !== 'out' &&\n      target in sourceData.in\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.in, target));\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      target in sourceData.out\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.out, target));\n  }\n\n  if (type !== 'directed') {\n    if (\n      typeof sourceData.undirected !== 'undefined' &&\n      target in sourceData.undirected\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.undirected, target));\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching an edge array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeArrayCreator(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  /**\n   * Function returning an array of certain edges.\n   *\n   * Arity 0: Return all the relevant edges.\n   *\n   * Arity 1: Return all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function(source, target) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    if (!arguments.length)\n      return createEdgeArray(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${source}\" node in the graph.`);\n\n      // Iterating over a node's edges\n      return createEdgeArrayForNode(\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData\n      );\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${name}:  could not find the \"${source}\" source node in the graph.`);\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(`Graph.${name}:  could not find the \"${target}\" target node in the graph.`);\n\n      // Iterating over the edges between source & target\n      return createEdgeArrayForPath(type, direction, sourceData, target);\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching a edge callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachEdge(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function(source, target, callback) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(`Graph.${forEachName}: could not find the \"${source}\" node in the graph.`);\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${forEachName}:  could not find the \"${source}\" source node in the graph.`);\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(`Graph.${forEachName}:  could not find the \"${target}\" target node in the graph.`);\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(type, direction, sourceData, target, callback);\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${forEachName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching an edge iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nexport function attachEdgeIteratorCreator(Class, description) {\n  const {\n    name: originalName,\n    type,\n    direction\n  } = description;\n\n  const name = originalName.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over the graph's edges.\n   *\n   * Arity 0: Iterate over all the relevant edges.\n   *\n   * Arity 1: Iterate over all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Iterate over the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function(source, target) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    if (!arguments.length)\n      return createEdgeIterator(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${source}\" node in the graph.`);\n\n      // Iterating over a node's edges\n      return createEdgeIteratorForNode(type, direction, sourceData);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${name}:  could not find the \"${source}\" source node in the graph.`);\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(`Graph.${name}:  could not find the \"${target}\" target node in the graph.`);\n\n      // Iterating over the edges between source & target\n      return createEdgeIteratorForPath(type, direction, sourceData, target);\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching every edge iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport function attachEdgeIterationMethods(Graph) {\n  EDGES_ITERATION.forEach(description => {\n    attachEdgeArrayCreator(Graph, description);\n    attachForEachEdge(Graph, description);\n    attachEdgeIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Neighbor Iteration\n * ==============================\n *\n * Attaching some methods to the Graph class to be able to iterate over\n * neighbors.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError\n} from '../errors';\n\n/**\n * Definitions.\n */\nconst NEIGHBORS_ITERATION = [\n  {\n    name: 'neighbors',\n    type: 'mixed'\n  },\n  {\n    name: 'inNeighbors',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outNeighbors',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundNeighbors',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundNeighbors',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedNeighbors',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedNeighbors',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function merging neighbors into the given set iterating over the given object.\n *\n * @param {BasicSet} neighbors - Neighbors set.\n * @param {object}   object    - Target object.\n */\nfunction merge(neighbors, object) {\n  if (typeof object === 'undefined')\n    return;\n\n  for (const neighbor in object)\n    neighbors.add(neighbor);\n}\n\n/**\n * Function creating an array of relevant neighbors for the given node.\n *\n * @param  {string}       type      - Type of neighbors.\n * @param  {string}       direction - Direction.\n * @param  {any}          nodeData  - Target node's data.\n * @return {Array}                  - The list of neighbors.\n */\nfunction createNeighborArrayForNode(type, direction, nodeData) {\n\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return Object.keys(nodeData.undirected);\n\n    if (typeof direction === 'string')\n      return Object.keys(nodeData[direction]);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const neighbors = new Set();\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out') {\n      merge(neighbors, nodeData.in);\n    }\n    if (direction !== 'in') {\n      merge(neighbors, nodeData.out);\n    }\n  }\n\n  if (type !== 'directed') {\n    merge(neighbors, nodeData.undirected);\n  }\n\n  return take(neighbors.values(), neighbors.size);\n}\n\n/**\n * Function iterating over the given node's relevant neighbors using a\n * callback.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction forEachInObject(nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    callback(\n      neighborData.key,\n      neighborData.attributes\n    );\n  }\n}\n\nfunction forEachInObjectOnce(visited, nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key))\n      continue;\n\n    visited.add(neighborData.key);\n\n    callback(\n      neighborData.key,\n      neighborData.attributes\n    );\n  }\n}\n\nfunction forEachNeighborForNode(type, direction, nodeData, callback) {\n\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return forEachInObject(nodeData, nodeData.undirected, callback);\n\n    if (typeof direction === 'string')\n      return forEachInObject(nodeData, nodeData[direction], callback);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out') {\n      forEachInObjectOnce(visited, nodeData, nodeData.in, callback);\n    }\n    if (direction !== 'in') {\n      forEachInObjectOnce(visited, nodeData, nodeData.out, callback);\n    }\n  }\n\n  if (type !== 'directed') {\n    forEachInObjectOnce(visited, nodeData, nodeData.undirected, callback);\n  }\n}\n\n/**\n * Function returning an iterator over the given node's relevant neighbors.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createObjectIterator(nodeData, object) {\n  const keys = Object.keys(object),\n        l = keys.length;\n\n  let i = 0;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {done: true};\n\n    let edgeData = object[keys[i++]];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    return {\n      done: false,\n      value: [neighborData.key, neighborData.attributes]\n    };\n  });\n}\n\nfunction createDedupedObjectIterator(visited, nodeData, object) {\n  const keys = Object.keys(object),\n        l = keys.length;\n\n  let i = 0;\n\n  return new Iterator(function next() {\n    if (i >= l)\n      return {done: true};\n\n    let edgeData = object[keys[i++]];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key))\n      return next();\n\n    visited.add(neighborData.key);\n\n    return {\n      done: false,\n      value: [neighborData.key, neighborData.attributes]\n    };\n  });\n}\n\nfunction createNeighborIterator(type, direction, nodeData) {\n\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return createObjectIterator(nodeData, nodeData.undirected);\n\n    if (typeof direction === 'string')\n      return createObjectIterator(nodeData, nodeData[direction]);\n  }\n\n  let iterator = Iterator.empty();\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out') {\n      iterator = chain(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.in));\n    }\n    if (direction !== 'in') {\n      iterator = chain(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.out));\n    }\n  }\n\n  if (type !== 'directed') {\n    iterator = chain(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.undirected));\n  }\n\n  return iterator;\n}\n\n/**\n * Function returning whether the given node has target neighbor.\n *\n * @param  {Graph}        graph     - Target graph.\n * @param  {string}       type      - Type of neighbor.\n * @param  {string}       direction - Direction.\n * @param  {any}          node      - Target node.\n * @param  {any}          neighbor  - Target neighbor.\n * @return {boolean}\n */\nfunction nodeHasNeighbor(graph, type, direction, node, neighbor) {\n\n  const nodeData = graph._nodes.get(node);\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined') {\n      for (const k in nodeData.in)\n        if (k === neighbor)\n          return true;\n    }\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined') {\n      for (const k in nodeData.out)\n        if (k === neighbor)\n          return true;\n    }\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    for (const k in nodeData.undirected)\n        if (k === neighbor)\n          return true;\n  }\n\n  return false;\n}\n\n/**\n * Function attaching a neighbors array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborArrayCreator(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  /**\n   * Function returning an array or the count of certain neighbors.\n   *\n   * Arity 1: Return all of a node's relevant neighbors.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return whether the two nodes are indeed neighbors.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The neighbors or the number of neighbors.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function(node) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    if (arguments.length === 2) {\n      const node1 = '' + arguments[0],\n            node2 = '' + arguments[1];\n\n      if (!this._nodes.has(node1))\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${node1}\" node in the graph.`);\n\n      if (!this._nodes.has(node2))\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${node2}\" node in the graph.`);\n\n      // Here, we want to assess whether the two given nodes are neighbors\n      return nodeHasNeighbor(\n        this,\n        type,\n        direction,\n        node1,\n        node2\n      );\n    }\n    else if (arguments.length === 1) {\n      node = '' + node;\n\n      const nodeData = this._nodes.get(node);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${node}\" node in the graph.`);\n\n      // Here, we want to iterate over a node's relevant neighbors\n      const neighbors = createNeighborArrayForNode(\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData\n      );\n\n      return neighbors;\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${name}: invalid number of arguments (expecting 1 or 2 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachNeighbor(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function(node, callback) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(`Graph.${forEachName}: could not find the \"${node}\" node in the graph.`);\n\n    // Here, we want to iterate over a node's relevant neighbors\n    forEachNeighborForNode(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborIteratorCreator(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const iteratorName = name.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over all the relevant neighbors.\n   *\n   * @param  {any}      node     - Target node.\n   * @return {Iterator}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[iteratorName] = function(node) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(`Graph.${iteratorName}: could not find the \"${node}\" node in the graph.`);\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborIterator(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching every neighbor iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport function attachNeighborIterationMethods(Graph) {\n  NEIGHBORS_ITERATION.forEach(description => {\n    attachNeighborArrayCreator(Graph, description);\n    attachForEachNeighbor(Graph, description);\n    attachNeighborIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Serialization Utilities\n * ===================================\n *\n * Collection of functions used to validate import-export formats & to ouput\n * them from internal graph data.\n *\n * Serialized Node:\n * {key, ?attributes}\n *\n * Serialized Edge:\n * {key?, source, target, attributes?, undirected?}\n *\n * Serialized Graph:\n * {nodes[], edges?[]}\n */\nimport {UndirectedEdgeData} from './data';\nimport {assign, isPlainObject} from './utils';\n\n/**\n * Formats internal node data into a serialized node.\n *\n * @param  {any}    key  - The node's key.\n * @param  {object} data - Internal node's data.\n * @return {array}       - The serialized node.\n */\nexport function serializeNode(key, data) {\n  const serialized = {key};\n\n  if (Object.keys(data.attributes).length)\n    serialized.attributes = assign({}, data.attributes);\n\n  return serialized;\n}\n\n/**\n * Formats internal edge data into a serialized edge.\n *\n * @param  {any}    key  - The edge's key.\n * @param  {object} data - Internal edge's data.\n * @return {array}       - The serialized edge.\n */\nexport function serializeEdge(key, data) {\n  const serialized = {\n    source: data.source.key,\n    target: data.target.key\n  };\n\n  // We export the key unless if it was provided by the user\n  if (!data.generatedKey)\n    serialized.key = key;\n\n  if (Object.keys(data.attributes).length)\n    serialized.attributes = assign({}, data.attributes);\n\n  if (data instanceof UndirectedEdgeData)\n    serialized.undirected = true;\n\n  return serialized;\n}\n\n/**\n * Checks whether the given value is a serialized node.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedNode(value) {\n  if (!isPlainObject(value))\n    return 'not-object';\n\n  if (!('key' in value))\n    return 'no-key';\n\n  if ('attributes' in value &&\n      (!isPlainObject(value.attributes) || value.attributes === null))\n    return 'invalid-attributes';\n\n  return null;\n}\n\n/**\n * Checks whether the given value is a serialized edge.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedEdge(value) {\n  if (!isPlainObject(value))\n    return 'not-object';\n\n  if (!('source' in value))\n    return 'no-source';\n\n  if (!('target' in value))\n    return 'no-target';\n\n  if ('attributes' in value &&\n      (!isPlainObject(value.attributes) || value.attributes === null))\n    return 'invalid-attributes';\n\n  if ('undirected' in value &&\n      (typeof value.undirected !== 'boolean'))\n    return 'invalid-undirected';\n\n  return null;\n}\n","/* eslint no-nested-ternary: 0 */\n/**\n * Graphology Reference Implementation\n * ====================================\n *\n * Reference implementation of the graphology specs.\n */\nimport {EventEmitter} from 'events';\nimport Iterator from 'obliterator/iterator';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\nimport {\n  MixedNodeData,\n  DirectedNodeData,\n  UndirectedNodeData,\n  DirectedEdgeData,\n  UndirectedEdgeData\n} from './data';\n\nimport {\n  updateStructureIndex,\n  clearEdgeFromStructureIndex,\n  clearStructureIndex,\n  upgradeStructureIndexToMulti\n} from './indices';\n\nimport {attachAttributesMethods} from './attributes';\nimport {attachEdgeIterationMethods} from './iteration/edges';\nimport {attachNeighborIterationMethods} from './iteration/neighbors';\n\nimport {\n  serializeNode,\n  serializeEdge,\n  validateSerializedNode,\n  validateSerializedEdge\n} from './serialization';\n\nimport {\n  assign,\n  getMatchingEdge,\n  isGraph,\n  isPlainObject,\n  prettyPrint,\n  privateProperty,\n  readOnlyProperty,\n  incrementalId\n} from './utils';\n\n/**\n * Enums.\n */\nconst TYPES = new Set([\n  'directed',\n  'undirected',\n  'mixed'\n]);\n\nconst EMITTER_PROPS = new Set([\n  'domain',\n  '_events',\n  '_eventsCount',\n  '_maxListeners'\n]);\n\nconst EDGE_ADD_METHODS = [\n  {\n    name: verb => `${verb}Edge`,\n    generateKey: true\n  },\n  {\n    name: verb => `${verb}DirectedEdge`,\n    generateKey: true,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdge`,\n    generateKey: true,\n    type: 'undirected'\n  },\n  {\n    name: verb => `${verb}EdgeWithKey`,\n  },\n  {\n    name: verb => `${verb}DirectedEdgeWithKey`,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdgeWithKey`,\n    type: 'undirected'\n  }\n];\n\n/**\n * Default options.\n */\nconst DEFAULTS = {\n  allowSelfLoops: true,\n  edgeKeyGenerator: null,\n  multi: false,\n  type: 'mixed'\n};\n\n/**\n * Abstract functions used by the Graph class for various methods.\n */\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction addEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes\n) {\n\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(`Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(`Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);\n\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(`Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`);\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n  attributes = attributes || {};\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(`Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);\n\n  const sourceData = graph._nodes.get(source),\n        targetData = graph._nodes.get(target);\n\n  if (!sourceData)\n    throw new NotFoundGraphError(`Graph.${name}: source node \"${source}\" not found.`);\n\n  if (!targetData)\n    throw new NotFoundGraphError(`Graph.${name}: target node \"${target}\" not found.`);\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey)\n    edge = graph._edgeKeyGenerator(eventData);\n\n  // Coercion of edge key\n  edge = '' + edge;\n\n  // Here, we have a key collision\n  if (graph._edges.has(edge))\n    throw new UsageGraphError(`Graph.${name}: the \"${edge}\" edge already exists in the graph.`);\n\n  // Here, we might have a source / target collision\n  if (\n    !graph.multi &&\n    (\n      undirected ?\n        typeof sourceData.undirected[target] !== 'undefined' :\n        typeof sourceData.out[target] !== 'undefined'\n    )\n  ) {\n    throw new UsageGraphError(`Graph.${name}: an edge linking \"${source}\" to \"${target}\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`);\n  }\n\n  // Storing some data\n  const DataClass = undirected ? UndirectedEdgeData : DirectedEdgeData;\n\n  const edgeData = new DataClass(\n    edge,\n    mustGenerateKey,\n    sourceData,\n    targetData,\n    attributes\n  );\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  if (source === target) {\n    if (undirected)\n      sourceData.undirectedSelfLoops++;\n    else\n      sourceData.directedSelfLoops++;\n  }\n  else {\n    if (undirected) {\n      sourceData.undirectedDegree++;\n      targetData.undirectedDegree++;\n    }\n    else {\n      sourceData.outDegree++;\n      targetData.inDegree++;\n    }\n  }\n\n  // Updating relevant index\n  updateStructureIndex(\n    graph,\n    undirected,\n    edgeData,\n    source,\n    target,\n    sourceData,\n    targetData\n  );\n\n  if (undirected)\n    graph._undirectedSize++;\n  else\n    graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction mergeEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes\n) {\n\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(`Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(`Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);\n\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(`Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`);\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n  attributes = attributes || {};\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(`Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);\n\n  let sourceData = graph._nodes.get(source),\n      targetData = graph._nodes.get(target),\n      edgeData;\n\n  // Do we need to handle duplicate?\n  let alreadyExistingEdge = null;\n\n  if (!mustGenerateKey) {\n    edgeData = graph._edges.get(edge);\n\n    if (edgeData) {\n\n      // Here, we need to ensure, if the user gave a key, that source & target\n      // are coherent\n      if (\n        (edgeData.source !== source || edgeData.target !== target) ||\n        (undirected && (edgeData.source !== target || edgeData.target !== source))\n      ) {\n        throw new UsageGraphError(`Graph.${name}: inconsistency detected when attempting to merge the \"${edge}\" edge with \"${source}\" source & \"${target}\" target vs. (${edgeData.source}, ${edgeData.target}).`);\n      }\n\n      alreadyExistingEdge = edge;\n    }\n  }\n\n  let alreadyExistingEdgeData;\n\n  // Here, we might have a source / target collision\n  if (\n    !alreadyExistingEdge &&\n    !graph.multi &&\n    sourceData &&\n    (\n      undirected ?\n        typeof sourceData.undirected[target] !== 'undefined' :\n        typeof sourceData.out[target] !== 'undefined'\n    )\n  ) {\n    alreadyExistingEdgeData = getMatchingEdge(graph, source, target, undirected ? 'undirected' : 'directed');\n  }\n\n  // Handling duplicates\n  if (alreadyExistingEdgeData) {\n\n    // We can skip the attribute merging part if the user did not provide them\n    if (!attributes)\n      return alreadyExistingEdge;\n\n    // Merging the attributes\n    assign(alreadyExistingEdgeData.attributes, attributes);\n    return alreadyExistingEdge;\n  }\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey)\n    edge = graph._edgeKeyGenerator(eventData);\n\n  // Coercion of edge key\n  edge = '' + edge;\n\n  // Here, we have a key collision\n  if (graph._edges.has(edge))\n    throw new UsageGraphError(`Graph.${name}: the \"${edge}\" edge already exists in the graph.`);\n\n  if (!sourceData) {\n    graph.addNode(source);\n    sourceData = graph._nodes.get(source);\n\n    if (source === target)\n      targetData = sourceData;\n  }\n  if (!targetData) {\n    graph.addNode(target);\n    targetData = graph._nodes.get(target);\n  }\n\n  // Storing some data\n  const DataClass = undirected ? UndirectedEdgeData : DirectedEdgeData;\n\n  edgeData = new DataClass(\n    edge,\n    mustGenerateKey,\n    sourceData,\n    targetData,\n    attributes\n  );\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  if (source === target) {\n    if (undirected)\n      sourceData.undirectedSelfLoops++;\n    else\n      sourceData.directedSelfLoops++;\n  }\n  else {\n    if (undirected) {\n      sourceData.undirectedDegree++;\n      targetData.undirectedDegree++;\n    }\n    else {\n      sourceData.outDegree++;\n      targetData.inDegree++;\n    }\n  }\n\n  // Updating relevant index\n  updateStructureIndex(\n    graph,\n    undirected,\n    edgeData,\n    source,\n    target,\n    sourceData,\n    targetData\n  );\n\n  if (undirected)\n    graph._undirectedSize++;\n  else\n    graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Graph class\n *\n * @constructor\n * @param  {object}  [options] - Options:\n * @param  {boolean}   [allowSelfLoops] - Allow self loops?\n * @param  {string}    [type]           - Type of the graph.\n * @param  {boolean}   [map]            - Allow references as keys?\n * @param  {boolean}   [multi]          - Allow parallel edges?\n *\n * @throws {Error} - Will throw if the arguments are not valid.\n */\nexport default class Graph extends EventEmitter {\n  constructor(options) {\n    super();\n\n    //-- Solving options\n    options = assign({}, DEFAULTS, options);\n\n    // Enforcing options validity\n    if (options.edgeKeyGenerator && typeof options.edgeKeyGenerator !== 'function')\n      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'edgeKeyGenerator' option. Expecting a function but got \"${options.edgeKeyGenerator}\".`);\n\n    if (typeof options.multi !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"${options.multi}\".`);\n\n    if (!TYPES.has(options.type))\n      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'type' option. Should be one of \"mixed\", \"directed\" or \"undirected\" but got \"${options.type}\".`);\n\n    if (typeof options.allowSelfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"${options.allowSelfLoops}\".`);\n\n    //-- Private properties\n\n    // Utilities\n    const NodeDataClass = options.type === 'mixed' ?\n      MixedNodeData :\n      (options.type === 'directed') ?\n        DirectedNodeData :\n        UndirectedNodeData;\n\n    privateProperty(this, 'NodeDataClass', NodeDataClass);\n\n    // Indexes\n    privateProperty(this, '_attributes', {});\n    privateProperty(this, '_nodes', new Map());\n    privateProperty(this, '_edges', new Map());\n    privateProperty(this, '_directedSize', 0);\n    privateProperty(this, '_undirectedSize', 0);\n    privateProperty(this, '_edgeKeyGenerator', options.edgeKeyGenerator || incrementalId());\n\n    // Options\n    privateProperty(this, '_options', options);\n\n    // Emitter properties\n    EMITTER_PROPS.forEach(prop => privateProperty(this, prop, this[prop]));\n\n    //-- Properties readers\n    readOnlyProperty(this, 'order', () => this._nodes.size);\n    readOnlyProperty(this, 'size', () => this._edges.size);\n    readOnlyProperty(this, 'directedSize', () => this._directedSize);\n    readOnlyProperty(this, 'undirectedSize', () => this._undirectedSize);\n    readOnlyProperty(this, 'multi', this._options.multi);\n    readOnlyProperty(this, 'type', this._options.type);\n    readOnlyProperty(this, 'allowSelfLoops', this._options.allowSelfLoops);\n  }\n\n  /**---------------------------------------------------------------------------\n   * Read\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning whether the given node is found in the graph.\n   *\n   * @param  {any}     node - The node.\n   * @return {boolean}\n   */\n  hasNode(node) {\n    return this._nodes.has('' + node);\n  }\n\n  /**\n   * Method returning whether the given directed edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasDirectedEdge(source, target) {\n\n    // Early termination\n    if (this.type === 'undirected')\n      return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return (\n        !!edgeData &&\n        edgeData instanceof DirectedEdgeData\n      );\n    }\n    else if (arguments.length === 2) {\n\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData)\n        return false;\n\n      // Is there a directed edge pointing toward target?\n      const edges = nodeData.out[target];\n\n      if (!edges)\n        return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);\n  }\n\n  /**\n   * Method returning whether the given undirected edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasUndirectedEdge(source, target) {\n\n    // Early termination\n    if (this.type === 'directed')\n      return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return (\n        !!edgeData &&\n        edgeData instanceof UndirectedEdgeData\n      );\n    }\n    else if (arguments.length === 2) {\n\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData)\n        return false;\n\n      // Is there a directed edge pointing toward target?\n      const edges = nodeData.undirected[target];\n\n      if (!edges)\n        return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);\n  }\n\n  /**\n   * Method returning whether the given edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasEdge(source, target) {\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      return this._edges.has(edge);\n    }\n    else if (arguments.length === 2) {\n\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData)\n        return false;\n\n      // Is there a directed edge pointing toward target?\n      let edges = typeof nodeData.out !== 'undefined' && nodeData.out[target];\n\n      if (!edges)\n        edges = typeof nodeData.undirected !== 'undefined' && nodeData.undirected[target];\n\n      if (!edges)\n        return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);\n  }\n\n  /**\n   * Method returning the edge matching source & target in a directed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  directedEdge(source, target) {\n\n    if (this.type === 'undirected')\n      return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError('Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.');\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(`Graph.directedEdge: could not find the \"${source}\" source node in the graph.`);\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(`Graph.directedEdge: could not find the \"${target}\" target node in the graph.`);\n\n    const edgeData = (sourceData.out && sourceData.out[target]) || undefined;\n\n    if (edgeData)\n      return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a undirected fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  undirectedEdge(source, target) {\n\n    if (this.type === 'directed')\n      return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError('Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.');\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(`Graph.undirectedEdge: could not find the \"${source}\" source node in the graph.`);\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(`Graph.undirectedEdge: could not find the \"${target}\" target node in the graph.`);\n\n    const edgeData = (sourceData.undirected && sourceData.undirected[target]) || undefined;\n\n    if (edgeData)\n      return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a mixed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  edge(source, target) {\n    if (this.multi)\n      throw new UsageGraphError('Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.');\n\n    source = '' + source;\n    target = '' + target;\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(`Graph.edge: could not find the \"${source}\" source node in the graph.`);\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(`Graph.edge: could not find the \"${target}\" target node in the graph.`);\n\n    const edgeData = (\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]) ||\n      undefined\n    );\n\n    if (edgeData)\n      return edgeData.key;\n  }\n\n  /**\n   * Method returning the given node's in degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} allowSelfLoops - Count self-loops?\n   * @return {number}            - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.inDegree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.inDegree: could not find the \"${node}\" node in the graph.`);\n\n    if (this.type === 'undirected')\n      return 0;\n\n    const loops = selfLoops ? nodeData.directedSelfLoops : 0;\n\n    return nodeData.inDegree + loops;\n  }\n\n  /**\n   * Method returning the given node's out degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's out degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.outDegree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.outDegree: could not find the \"${node}\" node in the graph.`);\n\n    if (this.type === 'undirected')\n      return 0;\n\n    const loops = selfLoops ? nodeData.directedSelfLoops : 0;\n\n    return nodeData.outDegree + loops;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's directed degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.directedDegree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    if (!this.hasNode(node))\n      throw new NotFoundGraphError(`Graph.directedDegree: could not find the \"${node}\" node in the graph.`);\n\n    if (this.type === 'undirected')\n      return 0;\n\n    return this.inDegree(node, selfLoops) + this.outDegree(node, selfLoops);\n  }\n\n  /**\n   * Method returning the given node's undirected degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's undirected degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.undirectedDegree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    if (!this.hasNode(node))\n      throw new NotFoundGraphError(`Graph.undirectedDegree: could not find the \"${node}\" node in the graph.`);\n\n    if (this.type === 'directed')\n      return 0;\n\n    const data = this._nodes.get(node),\n          loops = selfLoops ? (data.undirectedSelfLoops * 2) : 0;\n\n    return data.undirectedDegree + loops;\n  }\n\n  /**\n   * Method returning the given node's degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.degree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    if (!this.hasNode(node))\n      throw new NotFoundGraphError(`Graph.degree: could not find the \"${node}\" node in the graph.`);\n\n    let degree = 0;\n\n    if (this.type !== 'undirected')\n      degree += this.directedDegree(node, selfLoops);\n\n    if (this.type !== 'directed')\n      degree += this.undirectedDegree(node, selfLoops);\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given edge's source.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's source.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  source(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.source: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.source.key;\n  }\n\n  /**\n   * Method returning the given edge's target.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's target.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  target(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.target: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.target.key;\n  }\n\n  /**\n   * Method returning the given edge's extremities.\n   *\n   * @param  {any}   edge - The edge's key.\n   * @return {array}      - The edge's extremities.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  extremities(edge) {\n    edge = '' + edge;\n\n    const edgeData = this._edges.get(edge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(`Graph.extremities: could not find the \"${edge}\" edge in the graph.`);\n\n    return [\n      edgeData.source.key,\n      edgeData.target.key\n    ];\n  }\n\n  /**\n   * Given a node & an edge, returns the other extremity of the edge.\n   *\n   * @param  {any}   node - The node's key.\n   * @param  {any}   edge - The edge's key.\n   * @return {any}        - The related node.\n   *\n   * @throws {Error} - Will throw if either the node or the edge isn't in the graph.\n   */\n  opposite(node, edge) {\n    node = '' + node;\n    edge = '' + edge;\n\n    if (!this._nodes.has(node))\n      throw new NotFoundGraphError(`Graph.opposite: could not find the \"${node}\" node in the graph.`);\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.opposite: could not find the \"${edge}\" edge in the graph.`);\n\n    const {source: sourceData, target: targetData} = data;\n\n    const source = sourceData.key,\n          target = targetData.key;\n\n    if (node !== source && node !== target)\n      throw new NotFoundGraphError(`Graph.opposite: the \"${node}\" node is not attached to the \"${edge}\" edge (${source}, ${target}).`);\n\n    return node === source ? target : source;\n  }\n\n  /**\n   * Method returning whether the given edge is undirected.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  undirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.undirected: could not find the \"${edge}\" edge in the graph.`);\n\n    return data instanceof UndirectedEdgeData;\n  }\n\n  /**\n   * Method returning whether the given edge is directed.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  directed(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.directed: could not find the \"${edge}\" edge in the graph.`);\n\n    return data instanceof DirectedEdgeData;\n  }\n\n  /**\n   * Method returning whether the given edge is a self loop.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  selfLoop(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.selfLoop: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.source === data.target;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Mutation\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to add a node to the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   *\n   * @throws {Error} - Will throw if the given node already exist.\n   * @throws {Error} - Will throw if the given attributes are not an object.\n   */\n  addNode(node, attributes) {\n    if (attributes && !isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(`Graph.addNode: invalid attributes. Expecting an object but got \"${attributes}\"`);\n\n    // String coercion\n    node = '' + node;\n    attributes = attributes || {};\n\n    if (this._nodes.has(node))\n      throw new UsageGraphError(`Graph.addNode: the \"${node}\" node already exist in the graph.`);\n\n    const data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return node;\n  }\n\n  /**\n   * Method used to merge a node into the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   */\n  mergeNode(node, attributes) {\n    if (attributes && !isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(`Graph.mergeNode: invalid attributes. Expecting an object but got \"${attributes}\"`);\n\n    // String coercion\n    node = '' + node;\n    attributes = attributes || {};\n\n    // If the node already exists, we merge the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (attributes)\n        assign(data.attributes, attributes);\n      return node;\n    }\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return node;\n  }\n\n  /**\n   * Method used to drop a single node & all its attached edges from the graph.\n   *\n   * @param  {any}    node - The node.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node doesn't exist.\n   */\n  dropNode(node) {\n    node = '' + node;\n\n    if (!this.hasNode(node))\n      throw new NotFoundGraphError(`Graph.dropNode: could not find the \"${node}\" node in the graph.`);\n\n    // Removing attached edges\n    const edges = this.edges(node);\n\n    // NOTE: we could go faster here\n    for (let i = 0, l = edges.length; i < l; i++)\n      this.dropEdge(edges[i]);\n\n    const data = this._nodes.get(node);\n\n    // Dropping the node from the register\n    this._nodes.delete(node);\n\n    // Emitting\n    this.emit('nodeDropped', {\n      key: node,\n      attributes: data.attributes\n    });\n  }\n\n  /**\n   * Method used to drop a single edge from the graph.\n   *\n   * Arity 1:\n   * @param  {any}    edge - The edge.\n   *\n   * Arity 2:\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropEdge(edge) {\n    let edgeData;\n\n    if (arguments.length > 1) {\n      const source = '' + arguments[0],\n            target = '' + arguments[1];\n\n      edgeData = getMatchingEdge(this, source, target, this.type);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(`Graph.dropEdge: could not find the \"${source}\" -> \"${target}\" edge in the graph.`);\n    }\n    else {\n      edge = '' + edge;\n\n      edgeData = this._edges.get(edge);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(`Graph.dropEdge: could not find the \"${edge}\" edge in the graph.`);\n    }\n\n    // Dropping the edge from the register\n    this._edges.delete(edgeData.key);\n\n    // Updating related degrees\n    const {\n      source: sourceData,\n      target: targetData,\n      attributes\n    } = edgeData;\n\n    const undirected = edgeData instanceof UndirectedEdgeData;\n\n    if (sourceData === targetData) {\n      sourceData.selfLoops--;\n    }\n    else {\n      if (undirected) {\n        sourceData.undirectedDegree--;\n        targetData.undirectedDegree--;\n      }\n      else {\n        sourceData.outDegree--;\n        targetData.inDegree--;\n      }\n    }\n\n    // Clearing index\n    clearEdgeFromStructureIndex(this, undirected, edgeData);\n\n    if (undirected)\n      this._undirectedSize--;\n    else\n      this._directedSize--;\n\n    // Emitting\n    this.emit('edgeDropped', {\n      key: edge,\n      attributes,\n      source: sourceData.key,\n      target: targetData.key,\n      undirected\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to remove every edge & every node from the graph.\n   *\n   * @return {Graph}\n   */\n  clear() {\n\n    // Clearing edges\n    this._edges.clear();\n\n    // Clearing nodes\n    this._nodes.clear();\n\n    // Emitting\n    this.emit('cleared');\n  }\n\n  /**\n   * Method used to remove every edge from the graph.\n   *\n   * @return {Graph}\n   */\n  clearEdges() {\n\n    // Clearing edges\n    this._edges.clear();\n\n    // Clearing indices\n    this.clearIndex();\n\n    // Emitting\n    this.emit('edgesCleared');\n  }\n\n  /**---------------------------------------------------------------------------\n   * Attributes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning the desired graph's attribute.\n   *\n   * @param  {string} name - Name of the attribute.\n   * @return {any}\n   */\n  getAttribute(name) {\n    return this._attributes[name];\n  }\n\n  /**\n   * Method returning the graph's attributes.\n   *\n   * @return {object}\n   */\n  getAttributes() {\n    return this._attributes;\n  }\n\n  /**\n   * Method returning whether the graph has the desired attribute.\n   *\n   * @param  {string}  name - Name of the attribute.\n   * @return {boolean}\n   */\n  hasAttribute(name) {\n    return this._attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method setting a value for the desired graph's attribute.\n   *\n   * @param  {string}  name  - Name of the attribute.\n   * @param  {any}     value - Value for the attribute.\n   * @return {Graph}\n   */\n  setAttribute(name, value) {\n    this._attributes[name] = value;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      meta: {\n        name,\n        value\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Method using a function to update the desired graph's attribute's value.\n   *\n   * @param  {string}   name    - Name of the attribute.\n   * @param  {function} updater - Function use to update the attribute's value.\n   * @return {Graph}\n   */\n  updateAttribute(name, updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.updateAttribute: updater should be a function.');\n\n    this._attributes[name] = updater(this._attributes[name]);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      meta: {\n        name,\n        value: this._attributes[name]\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired graph's attribute.\n   *\n   * @param  {string} name  - Name of the attribute.\n   * @return {Graph}\n   */\n  removeAttribute(name) {\n    delete this._attributes[name];\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'remove',\n      meta: {\n        name\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Method replacing the graph's attributes.\n   *\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  replaceAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError('Graph.replaceAttributes: provided attributes are not a plain object.');\n\n    const before = this._attributes;\n\n    this._attributes = attributes;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'replace',\n      meta: {\n        before,\n        after: attributes\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the graph's attributes.\n   *\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  mergeAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError('Graph.mergeAttributes: provided attributes are not a plain object.');\n\n    this._attributes = assign(this._attributes, attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'merge',\n      meta: {\n        data: this._attributes\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Method returning the desired attribute for the given node.\n   *\n   * @param  {any}    node - Target node.\n   * @param  {string} name - Name of the attribute to get.\n   * @return {any}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  getNodeAttribute(node, name) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.getNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    return data.attributes[name];\n  }\n\n  /**\n   * Method returning the attributes for the given node.\n   *\n   * @param  {any}    node - Target node.\n   * @return {object}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  getNodeAttributes(node) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.getNodeAttributes: could not find the \"${node}\" node in the graph.`);\n\n    return data.attributes;\n  }\n\n  /**\n   * Method checking whether the given attribute exists for the given node.\n   *\n   * @param  {any}    node - Target node.\n   * @param  {string} name - Name of the attribute to check.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  hasNodeAttribute(node, name) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.hasNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    return data.attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method checking setting the desired attribute for the given node.\n   *\n   * @param  {any}    node  - Target node.\n   * @param  {string} name  - Name of the attribute to set.\n   * @param  {any}    value - Value for the attribute.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if less than 3 arguments are passed.\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  setNodeAttribute(node, name, value) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.setNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError('Graph.setNodeAttribute: not enough arguments. Either you forgot to pass the attribute\\'s name or value, or you meant to use #.replaceNodeAttributes / #.mergeNodeAttributes instead.');\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'set',\n      meta: {\n        name,\n        value\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Method checking setting the desired attribute for the given node.\n   *\n   * @param  {any}      node    - Target node.\n   * @param  {string}   name    - Name of the attribute to set.\n   * @param  {function} updater - Function that will update the attribute.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if less than 3 arguments are passed.\n   * @throws {Error} - Will throw if updater is not a function.\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  updateNodeAttribute(node, name, updater) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.updateNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError('Graph.updateNodeAttribute: not enough arguments. Either you forgot to pass the attribute\\'s name or updater, or you meant to use #.replaceNodeAttributes / #.mergeNodeAttributes instead.');\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.updateAttribute: updater should be a function.');\n\n    const attributes = data.attributes;\n\n    attributes[name] = updater(attributes[name]);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'set',\n      meta: {\n        name,\n        value: attributes[name]\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired attribute for the given node.\n   *\n   * @param  {any}    node  - Target node.\n   * @param  {string} name  - Name of the attribute to remove.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  removeNodeAttribute(node, name) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.hasNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'remove',\n      meta: {\n        name\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Method completely replacing the attributes of the given node.\n   *\n   * @param  {any}    node       - Target node.\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   * @throws {Error} - Will throw if the given attributes is not a plain object.\n   */\n  replaceNodeAttributes(node, attributes) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.replaceNodeAttributes: could not find the \"${node}\" node in the graph.`);\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError('Graph.replaceNodeAttributes: provided attributes are not a plain object.');\n\n    const oldAttributes = data.attributes;\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'replace',\n      meta: {\n        before: oldAttributes,\n        after: attributes\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the attributes of the given node with the provided ones.\n   *\n   * @param  {any}    node       - Target node.\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   * @throws {Error} - Will throw if the given attributes is not a plain object.\n   */\n  mergeNodeAttributes(node, attributes) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.mergeNodeAttributes: could not find the \"${node}\" node in the graph.`);\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError('Graph.mergeNodeAttributes: provided attributes are not a plain object.');\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'merge',\n      meta: {\n        data: attributes\n      }\n    });\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Iteration-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method iterating over the graph's adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEach(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.forEach: expecting a callback.');\n\n    this._edges.forEach((edgeData, key) => {\n      const sourceData = edgeData.source,\n            targetData = edgeData.target;\n\n      callback(\n        sourceData.key,\n        targetData.key,\n        sourceData.attributes,\n        targetData.attributes,\n        key,\n        edgeData.attributes\n      );\n    });\n  }\n\n  /**\n   * Method returning an iterator over the graph's adjacency.\n   *\n   * @return {Iterator}\n   */\n  adjacency() {\n    const iterator = this._edges.values();\n\n    return new Iterator(function() {\n      const step = iterator.next();\n\n      if (step.done)\n        return step;\n\n      const edgeData = step.value;\n\n      const sourceData = edgeData.source,\n            targetData = edgeData.target;\n\n      return {\n        done: false,\n        value: [\n          sourceData.key,\n          targetData.key,\n          sourceData.attributes,\n          targetData.attributes,\n          edgeData.key,\n          edgeData.attributes\n        ]\n      };\n    });\n  }\n\n  /**\n   * Method returning the list of the graph's nodes.\n   *\n   * @return {array} - The nodes.\n   */\n  nodes() {\n    return take(this._nodes.keys(), this._nodes.size);\n  }\n\n  /**\n   * Method iterating over the graph's nodes using the given callback.\n   *\n   * @param  {function}  callback - Callback (key, attributes, index).\n   */\n  forEachNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.forEachNode: expecting a callback.');\n\n    this._nodes.forEach((data, key) => {\n      callback(key, data.attributes);\n    });\n  }\n\n  /**\n   * Method returning an iterator over the graph's node entries.\n   *\n   * @return {Iterator}\n   */\n  nodeEntries() {\n    const iterator = this._nodes.values();\n\n    return new Iterator(() => {\n      const step = iterator.next();\n\n      if (step.done)\n        return step;\n\n      const data = step.value;\n\n      return {value: [data.key, data.attributes], done: false};\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Serialization\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method exporting the target node.\n   *\n   * @param  {any}   node - Target node.\n   * @return {array}      - The serialized node.\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  exportNode(node) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.exportNode: could not find the \"${node}\" node in the graph.`);\n\n    return serializeNode(node, data);\n  }\n\n  /**\n   * Method exporting the target edge.\n   *\n   * @param  {any}   edge - Target edge.\n   * @return {array}      - The serialized edge.\n   *\n   * @throws {Error} - Will throw if the edge is not found.\n   */\n  exportEdge(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.exportEdge: could not find the \"${edge}\" edge in the graph.`);\n\n    return serializeEdge(edge, data);\n  }\n\n  /**\n   * Method used to export the whole graph.\n   *\n   * @return {object} - The serialized graph.\n   */\n  export() {\n\n    const nodes = new Array(this._nodes.size);\n\n    let i = 0;\n\n    this._nodes.forEach((data, key) => {\n      nodes[i++] = serializeNode(key, data);\n    });\n\n    const edges = new Array(this._edges.size);\n\n    i = 0;\n\n    this._edges.forEach((data, key) => {\n      edges[i++] = serializeEdge(key, data);\n    });\n\n    return {\n      attributes: this.getAttributes(),\n      nodes,\n      edges\n    };\n  }\n\n  /**\n   * Method used to import a serialized node.\n   *\n   * @param  {object} data   - The serialized node.\n   * @param  {boolean} merge - Whether to merge the given node.\n   * @return {Graph}         - Returns itself for chaining.\n   */\n  importNode(data, merge = false) {\n\n    // Validating\n    const error = validateSerializedNode(data);\n\n    if (error) {\n\n      if (error === 'not-object')\n        throw new InvalidArgumentsGraphError('Graph.importNode: invalid serialized node. A serialized node should be a plain object with at least a \"key\" property.');\n      if (error === 'no-key')\n        throw new InvalidArgumentsGraphError('Graph.importNode: no key provided.');\n      if (error === 'invalid-attributes')\n        throw new InvalidArgumentsGraphError('Graph.importNode: invalid attributes. Attributes should be a plain object, null or omitted.');\n    }\n\n    // Adding the node\n    const {key, attributes = {}} = data;\n\n    if (merge)\n      this.mergeNode(key, attributes);\n    else\n      this.addNode(key, attributes);\n\n    return this;\n  }\n\n  /**\n   * Method used to import a serialized edge.\n   *\n   * @param  {object}  data  - The serialized edge.\n   * @param  {boolean} merge - Whether to merge the given edge.\n   * @return {Graph}         - Returns itself for chaining.\n   */\n  importEdge(data, merge = false) {\n\n    // Validating\n    const error = validateSerializedEdge(data);\n\n    if (error) {\n\n      if (error === 'not-object')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: invalid serialized edge. A serialized edge should be a plain object with at least a \"source\" & \"target\" property.');\n      if (error === 'no-source')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: missing souce.');\n      if (error === 'no-target')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: missing target.');\n      if (error === 'invalid-attributes')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: invalid attributes. Attributes should be a plain object, null or omitted.');\n      if (error === 'invalid-undirected')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: invalid undirected. Undirected should be boolean or omitted.');\n    }\n\n    // Adding the edge\n    const {\n      source,\n      target,\n      attributes = {},\n      undirected = false\n    } = data;\n\n    let method;\n\n    if ('key' in data) {\n      method = merge ?\n        (undirected ? this.mergeUndirectedEdgeWithKey : this.mergeDirectedEdgeWithKey) :\n        (undirected ? this.addUndirectedEdgeWithKey : this.addDirectedEdgeWithKey);\n\n      method.call(\n        this,\n        data.key,\n        source,\n        target,\n        attributes\n      );\n    }\n    else {\n      method = merge ?\n        (undirected ? this.mergeUndirectedEdge : this.mergeDirectedEdge) :\n        (undirected ? this.addUndirectedEdge : this.addDirectedEdge);\n\n      method.call(\n        this,\n        source,\n        target,\n        attributes\n      );\n    }\n\n    return this;\n  }\n\n  /**\n   * Method used to import a serialized graph.\n   *\n   * @param  {object|Graph} data  - The serialized graph.\n   * @param  {boolean}      merge - Whether to merge data.\n   * @return {Graph}              - Returns itself for chaining.\n   */\n  import(data, merge = false) {\n\n    // Importing a Graph instance\n    if (isGraph(data)) {\n\n      this.import(data.export(), merge);\n      return this;\n    }\n\n    // Importing a serialized graph\n    if (!isPlainObject(data))\n      throw new InvalidArgumentsGraphError('Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.');\n\n    if (data.attributes) {\n      if (!isPlainObject(data.attributes))\n        throw new InvalidArgumentsGraphError('Graph.import: invalid attributes. Expecting a plain object.');\n\n      if (merge)\n        this.mergeAttributes(data.attributes);\n      else\n        this.replaceAttributes(data.attributes);\n    }\n\n    // TODO: optimize\n    if (data.nodes)\n      data.nodes.forEach(node => this.importNode(node, merge));\n\n    if (data.edges)\n      data.edges.forEach(edge => this.importEdge(edge, merge));\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Utils\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning a null copy of the graph, i.e. a graph without nodes\n   * & edges but with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The null copy.\n   */\n  nullCopy(options) {\n    return new Graph(assign({}, this._options, options));\n  }\n\n  /**\n   * Method returning an empty copy of the graph, i.e. a graph without edges but\n   * with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The empty copy.\n   */\n  emptyCopy(options) {\n    const graph = new Graph(assign({}, this._options, options));\n\n    this._nodes.forEach((nodeData, key) => {\n      nodeData = new graph.NodeDataClass(key, assign({}, nodeData.attributes));\n      graph._nodes.set(key, nodeData);\n    });\n\n    return graph;\n  }\n\n  /**\n   * Method returning an exact copy of the graph.\n   *\n   * @return {Graph} - The copy.\n   */\n  copy() {\n    const graph = new Graph(this._options);\n    graph.import(this);\n\n    return graph;\n  }\n\n  /**\n   * Method upgrading the graph to a mixed one.\n   *\n   * @return {Graph} - The copy.\n   */\n  upgradeToMixed() {\n    if (this.type === 'mixed')\n      return this;\n\n    // Upgrading node data:\n    // NOTE: maybe this could lead to some de-optimization by usual\n    // JavaScript engines but I cannot be sure of it. Another solution\n    // would be to reinstantiate the classes but this surely has a performance\n    // and memory impact.\n    this._nodes.forEach(data => (data.upgradeToMixed()));\n\n    // Mutating the options & the instance\n    this._options.type = 'mixed';\n    readOnlyProperty(this, 'type', this._options.type);\n    privateProperty(this, 'NodeDataClass', MixedNodeData);\n\n    return this;\n  }\n\n  /**\n   * Method upgrading the graph to a multi one.\n   *\n   * @return {Graph} - The copy.\n   */\n  upgradeToMulti() {\n    if (this.multi)\n      return this;\n\n    // Mutating the options & the instance\n    this._options.multi = true;\n    readOnlyProperty(this, 'multi', true);\n\n    // Upgrading indices\n    upgradeStructureIndexToMulti(this);\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Indexes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to clear the desired index to clear memory.\n   *\n   * @return {Graph}       - Returns itself for chaining.\n   */\n  clearIndex() {\n    clearStructureIndex(this);\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Known methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used by JavaScript to perform JSON serialization.\n   *\n   * @return {object} - The serialized graph.\n   */\n  toJSON() {\n    return this.export();\n  }\n\n  /**\n   * Method used to perform string coercion and returning useful information\n   * about the Graph instance.\n   *\n   * @return {string} - String representation of the graph.\n   */\n  toString() {\n    const pluralOrder = this.order > 1 || this.order === 0,\n          pluralSize = this.size > 1 || this.size === 0;\n\n    return `Graph<${prettyPrint(this.order)} node${pluralOrder ? 's' : ''}, ${prettyPrint(this.size)} edge${pluralSize ? 's' : ''}>`;\n  }\n\n  /**\n   * Method used internally by node's console to display a custom object.\n   *\n   * @return {object} - Formatted object representation of the graph.\n   */\n  inspect() {\n    const nodes = {};\n    this._nodes.forEach((data, key) => {\n      nodes[key] = data.attributes;\n    });\n\n    const edges = {},\n          multiIndex = {};\n\n    this._edges.forEach((data, key) => {\n      const direction = data instanceof UndirectedEdgeData ? '--' : '->';\n\n      let label = '';\n\n      const desc = `(${data.source.key})${direction}(${data.target.key})`;\n\n      if (!data.generatedKey) {\n        label += `[${key}]: `;\n      }\n      else if (this.multi) {\n        if (typeof multiIndex[desc] === 'undefined') {\n          multiIndex[desc] = 0;\n        }\n        else {\n          multiIndex[desc]++;\n        }\n\n        label += `${multiIndex[desc]}. `;\n      }\n\n      label += desc;\n\n      edges[label] = data.attributes;\n    });\n\n    const dummy = {};\n\n    for (const k in this) {\n      if (this.hasOwnProperty(k) &&\n          !EMITTER_PROPS.has(k) &&\n          typeof this[k] !== 'function')\n        dummy[k] = this[k];\n    }\n\n    dummy.attributes = this._attributes;\n    dummy.nodes = nodes;\n    dummy.edges = edges;\n\n    privateProperty(dummy, 'constructor', this.constructor);\n\n    return dummy;\n  }\n}\n\n/**\n * Attaching custom inspect method for node >= 10.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.for('nodejs.util.inspect.custom')] = Graph.prototype.inspect;\n\n/**\n * Attaching methods to the prototype.\n *\n * Here, we are attaching a wide variety of methods to the Graph class'\n * prototype when those are very numerous and when their creation is\n * abstracted.\n */\n\n/**\n * Related to edge addition.\n */\nEDGE_ADD_METHODS.forEach(method => {\n  ['add', 'merge'].forEach(verb => {\n    const name = method.name(verb),\n          fn = verb === 'add' ? addEdge : mergeEdge;\n\n    if (method.generateKey) {\n      Graph.prototype[name] = function(source, target, attributes) {\n        return fn(\n          this,\n          name,\n          true,\n          (method.type || this.type) === 'undirected',\n          null,\n          source,\n          target,\n          attributes\n        );\n      };\n    }\n    else {\n      Graph.prototype[name] = function(edge, source, target, attributes) {\n        return fn(\n          this,\n          name,\n          false,\n          (method.type || this.type) === 'undirected',\n          edge,\n          source,\n          target,\n          attributes\n        );\n      };\n    }\n  });\n});\n\n/**\n * Self iterator.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.iterator] = Graph.prototype.adjacency;\n\n/**\n * Attributes-related.\n */\nattachAttributesMethods(Graph);\n\n/**\n * Edge iteration-related.\n */\nattachEdgeIterationMethods(Graph);\n\n/**\n * Neighbor iteration-related.\n */\nattachNeighborIterationMethods(Graph);\n","/**\n * Graphology Helper Classes\n * ==========================\n *\n * Building some higher-order classes instantiating the graph with\n * predefinite options.\n */\nimport {assign} from './utils';\nimport Graph from './graph';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\n/**\n * Alternative constructors.\n */\nclass DirectedGraph extends Graph {\n  constructor(options) {\n    super(\n      assign({type: 'directed'}, options)\n    );\n  }\n}\nclass UndirectedGraph extends Graph {\n  constructor(options) {\n    super(\n      assign({type: 'undirected'}, options)\n    );\n  }\n}\nclass MultiGraph extends Graph {\n  constructor(options) {\n    super(\n      assign({multi: true}, options)\n    );\n  }\n}\nclass MultiDirectedGraph extends Graph {\n  constructor(options) {\n    super(\n      assign({multi: true, type: 'directed'}, options)\n    );\n  }\n}\nclass MultiUndirectedGraph extends Graph {\n  constructor(options) {\n    super(\n      assign({multi: true, type: 'undirected'}, options)\n    );\n  }\n}\n\n/**\n * Attaching static #.from method to each of the constructors.\n */\nfunction attachStaticFromMethod(Class) {\n\n  /**\n   * Builds a graph from serialized data or another graph's data.\n   *\n   * @param  {Graph|SerializedGraph} data      - Hydratation data.\n   * @param  {object}                [options] - Options.\n   * @return {Class}\n   */\n  Class.from = function(data, options) {\n    const instance = new Class(options);\n    instance.import(data);\n\n    return instance;\n  };\n}\n\nattachStaticFromMethod(Graph);\nattachStaticFromMethod(DirectedGraph);\nattachStaticFromMethod(UndirectedGraph);\nattachStaticFromMethod(MultiGraph);\nattachStaticFromMethod(MultiDirectedGraph);\nattachStaticFromMethod(MultiUndirectedGraph);\n\nGraph.Graph = Graph;\nGraph.DirectedGraph = DirectedGraph;\nGraph.UndirectedGraph = UndirectedGraph;\nGraph.MultiGraph = MultiGraph;\nGraph.MultiDirectedGraph = MultiDirectedGraph;\nGraph.MultiUndirectedGraph = MultiUndirectedGraph;\n\nGraph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;\nGraph.NotFoundGraphError = NotFoundGraphError;\nGraph.UsageGraphError = UsageGraphError;\n\nexport {\n  Graph,\n  DirectedGraph,\n  UndirectedGraph,\n  MultiGraph,\n  MultiDirectedGraph,\n  MultiUndirectedGraph\n};\n","/**\n * Graphology CommonJS Endoint\n * ============================\n *\n * Endpoint for CommonJS modules consumers.\n */\nimport {Graph} from './classes';\n\nexport default Graph;\n"],"names":["assign","target","arguments","i","l","length","k","getMatchingEdge","graph","source","type","sourceData","_nodes","get","edge","out","undirected","isGraph","value","addUndirectedEdgeWithKey","dropNode","isPlainObject","constructor","Object","prettyPrint","integer","string","prettyString","j","privateProperty","name","defineProperty","enumerable","configurable","writable","readOnlyProperty","descriptor","incrementalId","GraphError","message","data","Error","InvalidArgumentsGraphError","captureStackTrace","prototype","NotFoundGraphError","UsageGraphError","MixedNodeData","key","attributes","inDegree","outDegree","undirectedDegree","directedSelfLoops","undirectedSelfLoops","DirectedNodeData","upgradeToMixed","UndirectedNodeData","DirectedEdgeData","generatedKey","UndirectedEdgeData","updateStructureIndex","edgeData","targetData","multi","outKey","inKey","edgeOrSet","Set","add","clearEdgeFromStructureIndex","sourceIndex","set","size","targetIndex","clearStructureIndex","forEach","upgradeStructureIndexToMulti","node","neighbor","edges","attachAttributeGetter","Class","method","EdgeDataClass","element","_edges","attachAttributesGetter","attachAttributeChecker","hasOwnProperty","attachAttributeSetter","emit","meta","attachAttributeUpdater","updater","attachAttributeRemover","attachAttributesReplacer","oldAttributes","before","after","attachAttributesMerger","ATTRIBUTES_METHODS","attacher","attachAttributesMethods","Graph","EDGES_ITERATION","direction","collect","object","push","forEachSimple","callback","forEachMulti","createIterator","keys","inner","Iterator","next","step","done","values","collectForKey","forEachForKey","createIteratorForKey","v","iterator","of","createEdgeArray","take","undirectedSize","directedSize","list","Array","mask","forEachEdge","createEdgeIterator","empty","createEdgeArrayForNode","nodeData","forEachEdgeForNode","fn","createEdgeIteratorForNode","chain","createEdgeArrayForPath","forEachEdgeForPath","createEdgeIteratorForPath","attachEdgeArrayCreator","description","has","attachForEachEdge","forEachName","toUpperCase","slice","attachEdgeIteratorCreator","originalName","attachEdgeIterationMethods","NEIGHBORS_ITERATION","merge","neighbors","createNeighborArrayForNode","forEachInObject","neighborData","forEachInObjectOnce","visited","forEachNeighborForNode","createObjectIterator","createDedupedObjectIterator","createNeighborIterator","nodeHasNeighbor","attachNeighborArrayCreator","node1","node2","attachForEachNeighbor","attachNeighborIteratorCreator","iteratorName","attachNeighborIterationMethods","serializeNode","serialized","serializeEdge","validateSerializedNode","validateSerializedEdge","TYPES","EMITTER_PROPS","EDGE_ADD_METHODS","verb","generateKey","DEFAULTS","allowSelfLoops","edgeKeyGenerator","addEdge","mustGenerateKey","eventData","_edgeKeyGenerator","DataClass","_undirectedSize","_directedSize","mergeEdge","alreadyExistingEdge","alreadyExistingEdgeData","addNode","options","NodeDataClass","Map","prop","_options","hasNode","hasDirectedEdge","hasUndirectedEdge","hasEdge","directedEdge","undefined","undirectedEdge","selfLoops","loops","directedDegree","degree","extremities","opposite","directed","selfLoop","mergeNode","dropEdge","clear","clearEdges","clearIndex","getAttribute","_attributes","getAttributes","hasAttribute","setAttribute","updateAttribute","removeAttribute","replaceAttributes","mergeAttributes","getNodeAttribute","getNodeAttributes","hasNodeAttribute","setNodeAttribute","updateNodeAttribute","removeNodeAttribute","replaceNodeAttributes","mergeNodeAttributes","adjacency","nodes","forEachNode","nodeEntries","exportNode","exportEdge","importNode","error","importEdge","mergeUndirectedEdgeWithKey","mergeDirectedEdgeWithKey","addDirectedEdgeWithKey","call","mergeUndirectedEdge","mergeDirectedEdge","addUndirectedEdge","addDirectedEdge","nullCopy","emptyCopy","copy","upgradeToMulti","toJSON","toString","pluralOrder","order","pluralSize","inspect","multiIndex","label","desc","dummy","EventEmitter","Symbol","DirectedGraph","UndirectedGraph","MultiGraph","MultiDirectedGraph","MultiUndirectedGraph","attachStaticFromMethod","from","instance"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;AAOA;;;;;;;AAOO,SAASA,MAAT,GAAkB;AACvB,MAAMC,MAAM,GAAGC,SAAS,CAAC,CAAD,CAAT,IAAgB,EAA/B;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGF,SAAS,CAACG,MAA9B,EAAsCF,CAAC,GAAGC,CAA1C,EAA6CD,CAAC,EAA9C,EAAkD;AAChD,QAAI,CAACD,SAAS,CAACC,CAAD,CAAd,EACE;;AAEF,SAAK,IAAMG,CAAX,IAAgBJ,SAAS,CAACC,CAAD,CAAzB;AACEF,MAAAA,MAAM,CAACK,CAAD,CAAN,GAAYJ,SAAS,CAACC,CAAD,CAAT,CAAaG,CAAb,CAAZ;AADF;AAED;;AAED,SAAOL,MAAP;AACD;AAED;;;;;;;;;;;;AAWO,SAASM,eAAT,CAAyBC,KAAzB,EAAgCC,MAAhC,EAAwCR,MAAxC,EAAgDS,IAAhD,EAAsD;AAC3D,MAAMC,UAAU,GAAGH,KAAK,CAACI,MAAN,CAAaC,GAAb,CAAiBJ,MAAjB,CAAnB;;AAEA,MAAIK,IAAI,GAAG,IAAX;AAEA,MAAI,CAACH,UAAL,EACE,OAAOG,IAAP;;AAEF,MAAIJ,IAAI,KAAK,OAAb,EAAsB;AACpBI,IAAAA,IAAI,GACDH,UAAU,CAACI,GAAX,IAAkBJ,UAAU,CAACI,GAAX,CAAed,MAAf,CAAnB,IACCU,UAAU,CAACK,UAAX,IAAyBL,UAAU,CAACK,UAAX,CAAsBf,MAAtB,CAF5B;AAID,GALD,MAMK,IAAIS,IAAI,KAAK,UAAb,EAAyB;AAC5BI,IAAAA,IAAI,GAAGH,UAAU,CAACI,GAAX,IAAkBJ,UAAU,CAACI,GAAX,CAAed,MAAf,CAAzB;AACD,GAFI,MAGA;AACHa,IAAAA,IAAI,GAAGH,UAAU,CAACK,UAAX,IAAyBL,UAAU,CAACK,UAAX,CAAsBf,MAAtB,CAAhC;AACD;;AAED,SAAOa,IAAP;AACD;AAED;;;;;;;AAMO,SAASG,OAAT,CAAiBC,KAAjB,EAAwB;AAC7B,SACEA,KAAK,KAAK,IAAV,IACA,QAAOA,KAAP,MAAiB,QADjB,IAEA,OAAOA,KAAK,CAACC,wBAAb,KAA0C,UAF1C,IAGA,OAAOD,KAAK,CAACE,QAAb,KAA0B,UAJ5B;AAMD;AAED;;;;;;;AAMO,SAASC,aAAT,CAAuBH,KAAvB,EAA8B;AACnC,SACE,QAAOA,KAAP,MAAiB,QAAjB,IACAA,KAAK,KAAK,IADV,IAEAA,KAAK,CAACI,WAAN,KAAsBC,MAHxB;AAKD;AAED;;;;;;;AAMO,SAASC,WAAT,CAAqBC,OAArB,EAA8B;AACnC,MAAMC,MAAM,GAAG,KAAKD,OAApB;AAEA,MAAIE,YAAY,GAAG,EAAnB;;AAEA,OAAK,IAAIxB,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGsB,MAAM,CAACrB,MAA3B,EAAmCF,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,QAAMyB,CAAC,GAAGxB,CAAC,GAAGD,CAAJ,GAAQ,CAAlB;AAEAwB,IAAAA,YAAY,GAAGD,MAAM,CAACE,CAAD,CAAN,GAAYD,YAA3B;AAEA,QAAI,EAAE,CAACxB,CAAC,GAAG,CAAL,IAAU,CAAZ,KAAkBA,CAAC,KAAKC,CAAC,GAAG,CAAhC,EACEuB,YAAY,GAAG,MAAMA,YAArB;AACH;;AAED,SAAOA,YAAP;AACD;AAED;;;;;;;;AAOO,SAASE,eAAT,CAAyB5B,MAAzB,EAAiC6B,IAAjC,EAAuCZ,KAAvC,EAA8C;AACnDK,EAAAA,MAAM,CAACQ,cAAP,CAAsB9B,MAAtB,EAA8B6B,IAA9B,EAAoC;AAClCE,IAAAA,UAAU,EAAE,KADsB;AAElCC,IAAAA,YAAY,EAAE,KAFoB;AAGlCC,IAAAA,QAAQ,EAAE,IAHwB;AAIlChB,IAAAA,KAAK,EAALA;AAJkC,GAApC;AAMD;AAGD;;;;;;;;AAOO,SAASiB,gBAAT,CAA0BlC,MAA1B,EAAkC6B,IAAlC,EAAwCZ,KAAxC,EAA+C;AACpD,MAAMkB,UAAU,GAAG;AACjBJ,IAAAA,UAAU,EAAE,IADK;AAEjBC,IAAAA,YAAY,EAAE;AAFG,GAAnB;;AAKA,MAAI,OAAOf,KAAP,KAAiB,UAArB,EAAiC;AAC/BkB,IAAAA,UAAU,CAACvB,GAAX,GAAiBK,KAAjB;AACD,GAFD,MAGK;AACHkB,IAAAA,UAAU,CAAClB,KAAX,GAAmBA,KAAnB;AACAkB,IAAAA,UAAU,CAACF,QAAX,GAAsB,KAAtB;AACD;;AAEDX,EAAAA,MAAM,CAACQ,cAAP,CAAsB9B,MAAtB,EAA8B6B,IAA9B,EAAoCM,UAApC;AACD;AAED;;;;;;AAKO,SAASC,aAAT,GAAyB;AAC9B,MAAIlC,CAAC,GAAG,CAAR;AAEA,SAAO,YAAM;AACX,0BAAeA,CAAC,EAAhB;AACD,GAFD;AAGD;;ACvKD;;;;;;;;IAQamC,UAAb;AAAA;;AACE,sBAAYC,OAAZ,EAAqBC,IAArB,EAA2B;AAAA;;AACzB;AACA,UAAKV,IAAL,GAAY,YAAZ;AACA,UAAKS,OAAL,GAAeA,OAAO,IAAI,EAA1B;AACA,UAAKC,IAAL,GAAYA,IAAI,IAAI,EAApB;AAJyB;AAK1B;;AANH;AAAA,iCAAgCC,KAAhC;IASaC,0BAAb;AAAA;;AACE,sCAAYH,OAAZ,EAAqBC,IAArB,EAA2B;AAAA;;AACzB,oCAAMD,OAAN,EAAeC,IAAf;AACA,WAAKV,IAAL,GAAY,4BAAZ,CAFyB;;AAKzB,QAAI,OAAOW,KAAK,CAACE,iBAAb,KAAmC,UAAvC,EACEF,KAAK,CAACE,iBAAN,iCAA8BD,0BAA0B,CAACE,SAA3B,CAAqCtB,WAAnE;AANuB;AAO1B;;AARH;AAAA,EAAgDgB,UAAhD;IAWaO,kBAAb;AAAA;;AACE,8BAAYN,OAAZ,EAAqBC,IAArB,EAA2B;AAAA;;AACzB,qCAAMD,OAAN,EAAeC,IAAf;AACA,WAAKV,IAAL,GAAY,oBAAZ,CAFyB;;AAKzB,QAAI,OAAOW,KAAK,CAACE,iBAAb,KAAmC,UAAvC,EACEF,KAAK,CAACE,iBAAN,iCAA8BE,kBAAkB,CAACD,SAAnB,CAA6BtB,WAA3D;AANuB;AAO1B;;AARH;AAAA,EAAwCgB,UAAxC;IAWaQ,eAAb;AAAA;;AACE,2BAAYP,OAAZ,EAAqBC,IAArB,EAA2B;AAAA;;AACzB,qCAAMD,OAAN,EAAeC,IAAf;AACA,WAAKV,IAAL,GAAY,iBAAZ,CAFyB;;AAKzB,QAAI,OAAOW,KAAK,CAACE,iBAAb,KAAmC,UAAvC,EACEF,KAAK,CAACE,iBAAN,iCAA8BG,eAAe,CAACF,SAAhB,CAA0BtB,WAAxD;AANuB;AAO1B;;AARH;AAAA,EAAqCgB,UAArC;;ACvCA;;;;;;;;;;;AAWA;;;;;;;AAOO,SAASS,aAAT,CAAuBC,GAAvB,EAA4BC,UAA5B,EAAwC;AAE7C;AACA,OAAKD,GAAL,GAAWA,GAAX;AACA,OAAKC,UAAL,GAAkBA,UAAlB,CAJ6C;;AAO7C,OAAKC,QAAL,GAAgB,CAAhB;AACA,OAAKC,SAAL,GAAiB,CAAjB;AACA,OAAKC,gBAAL,GAAwB,CAAxB;AACA,OAAKC,iBAAL,GAAyB,CAAzB;AACA,OAAKC,mBAAL,GAA2B,CAA3B,CAX6C;;AAc7C,eAAU,EAAV;AACA,OAAKvC,GAAL,GAAW,EAAX;AACA,OAAKC,UAAL,GAAkB,EAAlB;AACD;AAED;;;;;;;;AAOO,SAASuC,gBAAT,CAA0BP,GAA1B,EAA+BC,UAA/B,EAA2C;AAEhD;AACA,OAAKD,GAAL,GAAWA,GAAX;AACA,OAAKC,UAAL,GAAkBA,UAAU,IAAI,EAAhC,CAJgD;;AAOhD,OAAKC,QAAL,GAAgB,CAAhB;AACA,OAAKC,SAAL,GAAiB,CAAjB;AACA,OAAKE,iBAAL,GAAyB,CAAzB,CATgD;;AAYhD,eAAU,EAAV;AACA,OAAKtC,GAAL,GAAW,EAAX;AACD;;AAEDwC,gBAAgB,CAACX,SAAjB,CAA2BY,cAA3B,GAA4C,YAAW;AAErD;AACA,OAAKJ,gBAAL,GAAwB,CAAxB;AACA,OAAKE,mBAAL,GAA2B,CAA3B,CAJqD;;AAOrD,OAAKtC,UAAL,GAAkB,EAAlB;AACD,CARD;AAWA;;;;;;;;;AAOO,SAASyC,kBAAT,CAA4BT,GAA5B,EAAiCC,UAAjC,EAA6C;AAElD;AACA,OAAKD,GAAL,GAAWA,GAAX;AACA,OAAKC,UAAL,GAAkBA,UAAU,IAAI,EAAhC,CAJkD;;AAOlD,OAAKG,gBAAL,GAAwB,CAAxB;AACA,OAAKE,mBAAL,GAA2B,CAA3B,CARkD;;AAWlD,OAAKtC,UAAL,GAAkB,EAAlB;AACD;;AAEDyC,kBAAkB,CAACb,SAAnB,CAA6BY,cAA7B,GAA8C,YAAW;AAEvD;AACA,OAAKN,QAAL,GAAgB,CAAhB;AACA,OAAKC,SAAL,GAAiB,CAAjB;AACA,OAAKE,iBAAL,GAAyB,CAAzB,CALuD;;AAQvD,eAAU,EAAV;AACA,OAAKtC,GAAL,GAAW,EAAX;AACD,CAVD;AAYA;;;;;;;;;;;;AAUO,SAAS2C,gBAAT,CAA0BV,GAA1B,EAA+BW,YAA/B,EAA6ClD,MAA7C,EAAqDR,MAArD,EAA6DgD,UAA7D,EAAyE;AAE9E;AACA,OAAKD,GAAL,GAAWA,GAAX;AACA,OAAKC,UAAL,GAAkBA,UAAlB,CAJ8E;;AAO9E,OAAKxC,MAAL,GAAcA,MAAd;AACA,OAAKR,MAAL,GAAcA,MAAd,CAR8E;;AAW9E,OAAK0D,YAAL,GAAoBA,YAApB;AACD;AAED;;;;;;;;;;;AAUO,SAASC,kBAAT,CAA4BZ,GAA5B,EAAiCW,YAAjC,EAA+ClD,MAA/C,EAAuDR,MAAvD,EAA+DgD,UAA/D,EAA2E;AAEhF;AACA,OAAKD,GAAL,GAAWA,GAAX;AACA,OAAKC,UAAL,GAAkBA,UAAlB,CAJgF;;AAOhF,OAAKxC,MAAL,GAAcA,MAAd;AACA,OAAKR,MAAL,GAAcA,MAAd,CARgF;;AAWhF,OAAK0D,YAAL,GAAoBA,YAApB;AACD;;ACtJD;;;;;;;AAOA;;;;;;;;;;AAUO,SAASE,oBAAT,CACLrD,KADK,EAELQ,UAFK,EAGL8C,QAHK,EAILrD,MAJK,EAKLR,MALK,EAMLU,UANK,EAOLoD,UAPK,EAQL;AACA,MAAMC,KAAK,GAAGxD,KAAK,CAACwD,KAApB;AAEA,MAAMC,MAAM,GAAGjD,UAAU,GAAG,YAAH,GAAkB,KAA3C;AAAA,MACMkD,KAAK,GAAGlD,UAAU,GAAG,YAAH,GAAkB,IAD1C,CAHA;;AAOA,MAAImD,SAAS,GAAGxD,UAAU,CAACsD,MAAD,CAAV,CAAmBhE,MAAnB,CAAhB;;AAEA,MAAI,OAAOkE,SAAP,KAAqB,WAAzB,EAAsC;AACpCA,IAAAA,SAAS,GAAGH,KAAK,GAAG,IAAII,GAAJ,EAAH,GAAeN,QAAhC;AACAnD,IAAAA,UAAU,CAACsD,MAAD,CAAV,CAAmBhE,MAAnB,IAA6BkE,SAA7B;AACD;;AAED,MAAIH,KAAJ,EACEG,SAAS,CAACE,GAAV,CAAcP,QAAd,EAfF;;AAkBA,MAAIrD,MAAM,KAAKR,MAAf,EACE,OAnBF;AAsBA;;AACA,MAAI,OAAO8D,UAAU,CAACG,KAAD,CAAV,CAAkBzD,MAAlB,CAAP,KAAqC,WAAzC,EACEsD,UAAU,CAACG,KAAD,CAAV,CAAkBzD,MAAlB,IAA4B0D,SAA5B;AACH;AAED;;;;;;;AAMO,SAASG,2BAAT,CAAqC9D,KAArC,EAA4CQ,UAA5C,EAAwD8C,QAAxD,EAAkE;AACvE,MAAME,KAAK,GAAGxD,KAAK,CAACwD,KAApB;AADuE,MAGxDrD,UAHwD,GAGtBmD,QAHsB,CAGhErD,MAHgE;AAAA,MAGpCsD,UAHoC,GAGtBD,QAHsB,CAG5C7D,MAH4C;AAKvE,MAAMQ,MAAM,GAAGE,UAAU,CAACqC,GAA1B;AAAA,MACM/C,MAAM,GAAG8D,UAAU,CAACf,GAD1B,CALuE;AASvE;;AACA,MAAMiB,MAAM,GAAGjD,UAAU,GAAG,YAAH,GAAkB,KAA3C;AAAA,MACMuD,WAAW,GAAG5D,UAAU,CAACsD,MAAD,CAD9B;AAGA,MAAMC,KAAK,GAAGlD,UAAU,GAAG,YAAH,GAAkB,IAA1C;;AAEA,MAAIf,MAAM,IAAIsE,WAAd,EAA2B;AAEzB,QAAIP,KAAJ,EAAW;AACT,UAAMQ,GAAG,GAAGD,WAAW,CAACtE,MAAD,CAAvB;;AAEA,UAAIuE,GAAG,CAACC,IAAJ,KAAa,CAAjB,EAAoB;AAClB,eAAOF,WAAW,CAACtE,MAAD,CAAlB;AACA,eAAO8D,UAAU,CAACG,KAAD,CAAV,CAAkBzD,MAAlB,CAAP;AACD,OAHD,MAIK;AACH+D,QAAAA,GAAG,UAAH,CAAWV,QAAX;AACD;AACF,KAVD,MAYE,OAAOS,WAAW,CAACtE,MAAD,CAAlB;AACH;;AAED,MAAI+D,KAAJ,EACE;AAEF,MAAMU,WAAW,GAAGX,UAAU,CAACG,KAAD,CAA9B;AAEA,SAAOQ,WAAW,CAACjE,MAAD,CAAlB;AACD;AAED;;;;;;AAKO,SAASkE,mBAAT,CAA6BnE,KAA7B,EAAoC;AACzCA,EAAAA,KAAK,CAACI,MAAN,CAAagE,OAAb,CAAqB,UAAApC,IAAI,EAAI;AAE3B;AACA,QAAI,OAAOA,IAAI,MAAX,KAAmB,WAAvB,EAAoC;AAClCA,MAAAA,IAAI,MAAJ,GAAU,EAAV;AACAA,MAAAA,IAAI,CAACzB,GAAL,GAAW,EAAX;AACD;;AAED,QAAI,OAAOyB,IAAI,CAACxB,UAAZ,KAA2B,WAA/B,EAA4C;AAC1CwB,MAAAA,IAAI,CAACxB,UAAL,GAAkB,EAAlB;AACD;AACF,GAXD;AAYD;AAED;;;;;;AAKO,SAAS6D,4BAAT,CAAsCrE,KAAtC,EAA6C;AAClDA,EAAAA,KAAK,CAACI,MAAN,CAAagE,OAAb,CAAqB,UAACpC,IAAD,EAAOsC,IAAP,EAAgB;AAEnC;AACA,QAAItC,IAAI,CAACzB,GAAT,EAAc;AAEZ,WAAK,IAAMgE,QAAX,IAAuBvC,IAAI,CAACzB,GAA5B,EAAiC;AAC/B,YAAMiE,KAAK,GAAG,IAAIZ,GAAJ,EAAd;AACAY,QAAAA,KAAK,CAACX,GAAN,CAAU7B,IAAI,CAACzB,GAAL,CAASgE,QAAT,CAAV;AACAvC,QAAAA,IAAI,CAACzB,GAAL,CAASgE,QAAT,IAAqBC,KAArB;AACAxE,QAAAA,KAAK,CAACI,MAAN,CAAaC,GAAb,CAAiBkE,QAAjB,QAA8BD,IAA9B,IAAsCE,KAAtC;AACD;AACF,KAXkC;;;AAcnC,QAAIxC,IAAI,CAACxB,UAAT,EAAqB;AACnB,WAAK,IAAM+D,SAAX,IAAuBvC,IAAI,CAACxB,UAA5B,EAAwC;AACtC,YAAI+D,SAAQ,GAAGD,IAAf,EACE;;AAEF,YAAME,MAAK,GAAG,IAAIZ,GAAJ,EAAd;;AACAY,QAAAA,MAAK,CAACX,GAAN,CAAU7B,IAAI,CAACxB,UAAL,CAAgB+D,SAAhB,CAAV;;AACAvC,QAAAA,IAAI,CAACxB,UAAL,CAAgB+D,SAAhB,IAA4BC,MAA5B;AACAxE,QAAAA,KAAK,CAACI,MAAN,CAAaC,GAAb,CAAiBkE,SAAjB,EAA2B/D,UAA3B,CAAsC8D,IAAtC,IAA8CE,MAA9C;AACD;AACF;AACF,GAzBD;AA0BD;;ACtJD;;;;;;;AAwBA;;;;;;;;;AAQA,SAASC,qBAAT,CAA+BC,KAA/B,EAAsCC,MAAtC,EAA8CzE,IAA9C,EAAoD0E,aAApD,EAAmE;AAEjE;;;;;;;;;;;;;;;;;AAiBAF,EAAAA,KAAK,CAACtC,SAAN,CAAgBuC,MAAhB,IAA0B,UAASE,OAAT,EAAkBvD,IAAlB,EAAwB;AAChD,QAAIU,IAAJ;AAEA,QAAI,KAAK9B,IAAL,KAAc,OAAd,IAAyBA,IAAI,KAAK,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE,MAAM,IAAIoC,eAAJ,iBAA6BqC,MAA7B,sDAA+E,KAAKzE,IAApF,aAAN;;AAEF,QAAIR,SAAS,CAACG,MAAV,GAAmB,CAAvB,EAA0B;AAExB,UAAI,KAAK2D,KAAT,EACE,MAAM,IAAIlB,eAAJ,iBAA6BqC,MAA7B,2JAAN;AAEF,UAAM1E,MAAM,GAAG,KAAK4E,OAApB;AAAA,UACMpF,MAAM,GAAG,KAAK6B,IADpB;AAGAA,MAAAA,IAAI,GAAG5B,SAAS,CAAC,CAAD,CAAhB;AAEAsC,MAAAA,IAAI,GAAGjC,eAAe,CAAC,IAAD,EAAOE,MAAP,EAAeR,MAAf,EAAuBS,IAAvB,CAAtB;AAEA,UAAI,CAAC8B,IAAL,EACE,MAAM,IAAIK,kBAAJ,iBAAgCsC,MAAhC,4DAAuF1E,MAAvF,oBAAqGR,MAArG,UAAN;AACH,KAdD,MAeK;AACHoF,MAAAA,OAAO,GAAG,KAAKA,OAAf;AACA7C,MAAAA,IAAI,GAAG,KAAK8C,MAAL,CAAYzE,GAAZ,CAAgBwE,OAAhB,CAAP;AAEA,UAAI,CAAC7C,IAAL,EACE,MAAM,IAAIK,kBAAJ,iBAAgCsC,MAAhC,oCAA+DE,OAA/D,2BAAN;AACH;;AAED,QAAI3E,IAAI,KAAK,OAAT,IAAoB,EAAE8B,IAAI,YAAY4C,aAAlB,CAAxB,EACE,MAAM,IAAIvC,kBAAJ,iBAAgCsC,MAAhC,oCAA+DE,OAA/D,gBAA2E3E,IAA3E,yBAAN;AAEF,WAAO8B,IAAI,CAACS,UAAL,CAAgBnB,IAAhB,CAAP;AACD,GAjCD;AAkCD;AAED;;;;;;;;;;AAQA,SAASyD,sBAAT,CAAgCL,KAAhC,EAAuCC,MAAvC,EAA+CzE,IAA/C,EAAqD0E,aAArD,EAAoE;AAElE;;;;;;;;;;;;;;;AAeAF,EAAAA,KAAK,CAACtC,SAAN,CAAgBuC,MAAhB,IAA0B,UAASE,OAAT,EAAkB;AAC1C,QAAI7C,IAAJ;AAEA,QAAI,KAAK9B,IAAL,KAAc,OAAd,IAAyBA,IAAI,KAAK,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE,MAAM,IAAIoC,eAAJ,iBAA6BqC,MAA7B,sDAA+E,KAAKzE,IAApF,aAAN;;AAEF,QAAIR,SAAS,CAACG,MAAV,GAAmB,CAAvB,EAA0B;AAExB,UAAI,KAAK2D,KAAT,EACE,MAAM,IAAIlB,eAAJ,iBAA6BqC,MAA7B,2JAAN;AAEF,UAAM1E,MAAM,GAAG,KAAK4E,OAApB;AAAA,UACMpF,MAAM,GAAG,KAAKC,SAAS,CAAC,CAAD,CAD7B;AAGAsC,MAAAA,IAAI,GAAGjC,eAAe,CAAC,IAAD,EAAOE,MAAP,EAAeR,MAAf,EAAuBS,IAAvB,CAAtB;AAEA,UAAI,CAAC8B,IAAL,EACE,MAAM,IAAIK,kBAAJ,iBAAgCsC,MAAhC,4DAAuF1E,MAAvF,oBAAqGR,MAArG,UAAN;AACH,KAZD,MAaK;AACHoF,MAAAA,OAAO,GAAG,KAAKA,OAAf;AACA7C,MAAAA,IAAI,GAAG,KAAK8C,MAAL,CAAYzE,GAAZ,CAAgBwE,OAAhB,CAAP;AAEA,UAAI,CAAC7C,IAAL,EACE,MAAM,IAAIK,kBAAJ,iBAAgCsC,MAAhC,oCAA+DE,OAA/D,2BAAN;AACH;;AAED,QAAI3E,IAAI,KAAK,OAAT,IAAoB,EAAE8B,IAAI,YAAY4C,aAAlB,CAAxB,EACE,MAAM,IAAIvC,kBAAJ,iBAAgCsC,MAAhC,oCAA+DE,OAA/D,gBAA2E3E,IAA3E,yBAAN;AAEF,WAAO8B,IAAI,CAACS,UAAZ;AACD,GA/BD;AAgCD;AAED;;;;;;;;;;AAQA,SAASuC,sBAAT,CAAgCN,KAAhC,EAAuCC,MAAvC,EAA+CzE,IAA/C,EAAqD0E,aAArD,EAAoE;AAElE;;;;;;;;;;;;;;;;;AAiBAF,EAAAA,KAAK,CAACtC,SAAN,CAAgBuC,MAAhB,IAA0B,UAASE,OAAT,EAAkBvD,IAAlB,EAAwB;AAChD,QAAIU,IAAJ;AAEA,QAAI,KAAK9B,IAAL,KAAc,OAAd,IAAyBA,IAAI,KAAK,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE,MAAM,IAAIoC,eAAJ,iBAA6BqC,MAA7B,sDAA+E,KAAKzE,IAApF,aAAN;;AAEF,QAAIR,SAAS,CAACG,MAAV,GAAmB,CAAvB,EAA0B;AAExB,UAAI,KAAK2D,KAAT,EACE,MAAM,IAAIlB,eAAJ,iBAA6BqC,MAA7B,2JAAN;AAEF,UAAM1E,MAAM,GAAG,KAAK4E,OAApB;AAAA,UACMpF,MAAM,GAAG,KAAK6B,IADpB;AAGAA,MAAAA,IAAI,GAAG5B,SAAS,CAAC,CAAD,CAAhB;AAEAsC,MAAAA,IAAI,GAAGjC,eAAe,CAAC,IAAD,EAAOE,MAAP,EAAeR,MAAf,EAAuBS,IAAvB,CAAtB;AAEA,UAAI,CAAC8B,IAAL,EACE,MAAM,IAAIK,kBAAJ,iBAAgCsC,MAAhC,4DAAuF1E,MAAvF,oBAAqGR,MAArG,UAAN;AACH,KAdD,MAeK;AACHoF,MAAAA,OAAO,GAAG,KAAKA,OAAf;AACA7C,MAAAA,IAAI,GAAG,KAAK8C,MAAL,CAAYzE,GAAZ,CAAgBwE,OAAhB,CAAP;AAEA,UAAI,CAAC7C,IAAL,EACE,MAAM,IAAIK,kBAAJ,iBAAgCsC,MAAhC,oCAA+DE,OAA/D,2BAAN;AACH;;AAED,QAAI3E,IAAI,KAAK,OAAT,IAAoB,EAAE8B,IAAI,YAAY4C,aAAlB,CAAxB,EACE,MAAM,IAAIvC,kBAAJ,iBAAgCsC,MAAhC,oCAA+DE,OAA/D,gBAA2E3E,IAA3E,yBAAN;AAEF,WAAO8B,IAAI,CAACS,UAAL,CAAgBwC,cAAhB,CAA+B3D,IAA/B,CAAP;AACD,GAjCD;AAkCD;AAED;;;;;;;;;;AAQA,SAAS4D,qBAAT,CAA+BR,KAA/B,EAAsCC,MAAtC,EAA8CzE,IAA9C,EAAoD0E,aAApD,EAAmE;AAEjE;;;;;;;;;;;;;;;;;;;AAmBAF,EAAAA,KAAK,CAACtC,SAAN,CAAgBuC,MAAhB,IAA0B,UAASE,OAAT,EAAkBvD,IAAlB,EAAwBZ,KAAxB,EAA+B;AACvD,QAAIsB,IAAJ;AAEA,QAAI,KAAK9B,IAAL,KAAc,OAAd,IAAyBA,IAAI,KAAK,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE,MAAM,IAAIoC,eAAJ,iBAA6BqC,MAA7B,sDAA+E,KAAKzE,IAApF,aAAN;;AAEF,QAAIR,SAAS,CAACG,MAAV,GAAmB,CAAvB,EAA0B;AAExB,UAAI,KAAK2D,KAAT,EACE,MAAM,IAAIlB,eAAJ,iBAA6BqC,MAA7B,2JAAN;AAEF,UAAM1E,MAAM,GAAG,KAAK4E,OAApB;AAAA,UACMpF,MAAM,GAAG,KAAK6B,IADpB;AAGAA,MAAAA,IAAI,GAAG5B,SAAS,CAAC,CAAD,CAAhB;AACAgB,MAAAA,KAAK,GAAGhB,SAAS,CAAC,CAAD,CAAjB;AAEAsC,MAAAA,IAAI,GAAGjC,eAAe,CAAC,IAAD,EAAOE,MAAP,EAAeR,MAAf,EAAuBS,IAAvB,CAAtB;AAEA,UAAI,CAAC8B,IAAL,EACE,MAAM,IAAIK,kBAAJ,iBAAgCsC,MAAhC,4DAAuF1E,MAAvF,oBAAqGR,MAArG,UAAN;AACH,KAfD,MAgBK;AACHoF,MAAAA,OAAO,GAAG,KAAKA,OAAf;AACA7C,MAAAA,IAAI,GAAG,KAAK8C,MAAL,CAAYzE,GAAZ,CAAgBwE,OAAhB,CAAP;AAEA,UAAI,CAAC7C,IAAL,EACE,MAAM,IAAIK,kBAAJ,iBAAgCsC,MAAhC,oCAA+DE,OAA/D,2BAAN;AACH;;AAED,QAAI3E,IAAI,KAAK,OAAT,IAAoB,EAAE8B,IAAI,YAAY4C,aAAlB,CAAxB,EACE,MAAM,IAAIvC,kBAAJ,iBAAgCsC,MAAhC,oCAA+DE,OAA/D,gBAA2E3E,IAA3E,yBAAN;AAEF8B,IAAAA,IAAI,CAACS,UAAL,CAAgBnB,IAAhB,IAAwBZ,KAAxB,CAjCuD;;AAoCvD,SAAKyE,IAAL,CAAU,uBAAV,EAAmC;AACjC3C,MAAAA,GAAG,EAAER,IAAI,CAACQ,GADuB;AAEjCtC,MAAAA,IAAI,EAAE,KAF2B;AAGjCkF,MAAAA,IAAI,EAAE;AACJ9D,QAAAA,IAAI,EAAJA,IADI;AAEJZ,QAAAA,KAAK,EAALA;AAFI;AAH2B,KAAnC;AASA,WAAO,IAAP;AACD,GA9CD;AA+CD;AAED;;;;;;;;;;AAQA,SAAS2E,sBAAT,CAAgCX,KAAhC,EAAuCC,MAAvC,EAA+CzE,IAA/C,EAAqD0E,aAArD,EAAoE;AAElE;;;;;;;;;;;;;;;;;;;;AAoBAF,EAAAA,KAAK,CAACtC,SAAN,CAAgBuC,MAAhB,IAA0B,UAASE,OAAT,EAAkBvD,IAAlB,EAAwBgE,OAAxB,EAAiC;AACzD,QAAItD,IAAJ;AAEA,QAAI,KAAK9B,IAAL,KAAc,OAAd,IAAyBA,IAAI,KAAK,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE,MAAM,IAAIoC,eAAJ,iBAA6BqC,MAA7B,sDAA+E,KAAKzE,IAApF,aAAN;;AAEF,QAAIR,SAAS,CAACG,MAAV,GAAmB,CAAvB,EAA0B;AAExB,UAAI,KAAK2D,KAAT,EACE,MAAM,IAAIlB,eAAJ,iBAA6BqC,MAA7B,2JAAN;AAEF,UAAM1E,MAAM,GAAG,KAAK4E,OAApB;AAAA,UACMpF,MAAM,GAAG,KAAK6B,IADpB;AAGAA,MAAAA,IAAI,GAAG5B,SAAS,CAAC,CAAD,CAAhB;AACA4F,MAAAA,OAAO,GAAG5F,SAAS,CAAC,CAAD,CAAnB;AAEAsC,MAAAA,IAAI,GAAGjC,eAAe,CAAC,IAAD,EAAOE,MAAP,EAAeR,MAAf,EAAuBS,IAAvB,CAAtB;AAEA,UAAI,CAAC8B,IAAL,EACE,MAAM,IAAIK,kBAAJ,iBAAgCsC,MAAhC,4DAAuF1E,MAAvF,oBAAqGR,MAArG,UAAN;AACH,KAfD,MAgBK;AACHoF,MAAAA,OAAO,GAAG,KAAKA,OAAf;AACA7C,MAAAA,IAAI,GAAG,KAAK8C,MAAL,CAAYzE,GAAZ,CAAgBwE,OAAhB,CAAP;AAEA,UAAI,CAAC7C,IAAL,EACE,MAAM,IAAIK,kBAAJ,iBAAgCsC,MAAhC,oCAA+DE,OAA/D,2BAAN;AACH;;AAED,QAAI,OAAOS,OAAP,KAAmB,UAAvB,EACE,MAAM,IAAIpD,0BAAJ,iBAAwCyC,MAAxC,qCAAN;AAEF,QAAIzE,IAAI,KAAK,OAAT,IAAoB,EAAE8B,IAAI,YAAY4C,aAAlB,CAAxB,EACE,MAAM,IAAIvC,kBAAJ,iBAAgCsC,MAAhC,oCAA+DE,OAA/D,gBAA2E3E,IAA3E,yBAAN;AAEF8B,IAAAA,IAAI,CAACS,UAAL,CAAgBnB,IAAhB,IAAwBgE,OAAO,CAACtD,IAAI,CAACS,UAAL,CAAgBnB,IAAhB,CAAD,CAA/B,CApCyD;;AAuCzD,SAAK6D,IAAL,CAAU,uBAAV,EAAmC;AACjC3C,MAAAA,GAAG,EAAER,IAAI,CAACQ,GADuB;AAEjCtC,MAAAA,IAAI,EAAE,KAF2B;AAGjCkF,MAAAA,IAAI,EAAE;AACJ9D,QAAAA,IAAI,EAAJA,IADI;AAEJZ,QAAAA,KAAK,EAAEsB,IAAI,CAACS,UAAL,CAAgBnB,IAAhB;AAFH;AAH2B,KAAnC;AASA,WAAO,IAAP;AACD,GAjDD;AAkDD;AAED;;;;;;;;;;AAQA,SAASiE,sBAAT,CAAgCb,KAAhC,EAAuCC,MAAvC,EAA+CzE,IAA/C,EAAqD0E,aAArD,EAAoE;AAElE;;;;;;;;;;;;;;;;;AAiBAF,EAAAA,KAAK,CAACtC,SAAN,CAAgBuC,MAAhB,IAA0B,UAASE,OAAT,EAAkBvD,IAAlB,EAAwB;AAChD,QAAIU,IAAJ;AAEA,QAAI,KAAK9B,IAAL,KAAc,OAAd,IAAyBA,IAAI,KAAK,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE,MAAM,IAAIoC,eAAJ,iBAA6BqC,MAA7B,sDAA+E,KAAKzE,IAApF,aAAN;;AAEF,QAAIR,SAAS,CAACG,MAAV,GAAmB,CAAvB,EAA0B;AAExB,UAAI,KAAK2D,KAAT,EACE,MAAM,IAAIlB,eAAJ,iBAA6BqC,MAA7B,2JAAN;AAEF,UAAM1E,MAAM,GAAG,KAAK4E,OAApB;AAAA,UACMpF,MAAM,GAAG,KAAK6B,IADpB;AAGAA,MAAAA,IAAI,GAAG5B,SAAS,CAAC,CAAD,CAAhB;AAEAsC,MAAAA,IAAI,GAAGjC,eAAe,CAAC,IAAD,EAAOE,MAAP,EAAeR,MAAf,EAAuBS,IAAvB,CAAtB;AAEA,UAAI,CAAC8B,IAAL,EACE,MAAM,IAAIK,kBAAJ,iBAAgCsC,MAAhC,4DAAuF1E,MAAvF,oBAAqGR,MAArG,UAAN;AACH,KAdD,MAeK;AACHoF,MAAAA,OAAO,GAAG,KAAKA,OAAf;AACA7C,MAAAA,IAAI,GAAG,KAAK8C,MAAL,CAAYzE,GAAZ,CAAgBwE,OAAhB,CAAP;AAEA,UAAI,CAAC7C,IAAL,EACE,MAAM,IAAIK,kBAAJ,iBAAgCsC,MAAhC,oCAA+DE,OAA/D,2BAAN;AACH;;AAED,QAAI3E,IAAI,KAAK,OAAT,IAAoB,EAAE8B,IAAI,YAAY4C,aAAlB,CAAxB,EACE,MAAM,IAAIvC,kBAAJ,iBAAgCsC,MAAhC,oCAA+DE,OAA/D,gBAA2E3E,IAA3E,yBAAN;AAEF,WAAO8B,IAAI,CAACS,UAAL,CAAgBnB,IAAhB,CAAP,CAhCgD;;AAmChD,SAAK6D,IAAL,CAAU,uBAAV,EAAmC;AACjC3C,MAAAA,GAAG,EAAER,IAAI,CAACQ,GADuB;AAEjCtC,MAAAA,IAAI,EAAE,QAF2B;AAGjCkF,MAAAA,IAAI,EAAE;AACJ9D,QAAAA,IAAI,EAAJA;AADI;AAH2B,KAAnC;AAQA,WAAO,IAAP;AACD,GA5CD;AA6CD;AAED;;;;;;;;;;AAQA,SAASkE,wBAAT,CAAkCd,KAAlC,EAAyCC,MAAzC,EAAiDzE,IAAjD,EAAuD0E,aAAvD,EAAsE;AAEpE;;;;;;;;;;;;;;;;;AAiBAF,EAAAA,KAAK,CAACtC,SAAN,CAAgBuC,MAAhB,IAA0B,UAASE,OAAT,EAAkBpC,UAAlB,EAA8B;AACtD,QAAIT,IAAJ;AAEA,QAAI,KAAK9B,IAAL,KAAc,OAAd,IAAyBA,IAAI,KAAK,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE,MAAM,IAAIoC,eAAJ,iBAA6BqC,MAA7B,sDAA+E,KAAKzE,IAApF,aAAN;;AAEF,QAAIR,SAAS,CAACG,MAAV,GAAmB,CAAvB,EAA0B;AAExB,UAAI,KAAK2D,KAAT,EACE,MAAM,IAAIlB,eAAJ,iBAA6BqC,MAA7B,2JAAN;AAEF,UAAM1E,MAAM,GAAG,KAAK4E,OAApB;AAAA,UACMpF,MAAM,GAAG,KAAKgD,UADpB;AAGAA,MAAAA,UAAU,GAAG/C,SAAS,CAAC,CAAD,CAAtB;AAEAsC,MAAAA,IAAI,GAAGjC,eAAe,CAAC,IAAD,EAAOE,MAAP,EAAeR,MAAf,EAAuBS,IAAvB,CAAtB;AAEA,UAAI,CAAC8B,IAAL,EACE,MAAM,IAAIK,kBAAJ,iBAAgCsC,MAAhC,4DAAuF1E,MAAvF,oBAAqGR,MAArG,UAAN;AACH,KAdD,MAeK;AACHoF,MAAAA,OAAO,GAAG,KAAKA,OAAf;AACA7C,MAAAA,IAAI,GAAG,KAAK8C,MAAL,CAAYzE,GAAZ,CAAgBwE,OAAhB,CAAP;AAEA,UAAI,CAAC7C,IAAL,EACE,MAAM,IAAIK,kBAAJ,iBAAgCsC,MAAhC,oCAA+DE,OAA/D,2BAAN;AACH;;AAED,QAAI,CAAChE,aAAa,CAAC4B,UAAD,CAAlB,EACE,MAAM,IAAIP,0BAAJ,iBAAwCyC,MAAxC,mDAAN;AAEF,QAAIzE,IAAI,KAAK,OAAT,IAAoB,EAAE8B,IAAI,YAAY4C,aAAlB,CAAxB,EACE,MAAM,IAAIvC,kBAAJ,iBAAgCsC,MAAhC,oCAA+DE,OAA/D,gBAA2E3E,IAA3E,yBAAN;AAEF,QAAMuF,aAAa,GAAGzD,IAAI,CAACS,UAA3B;AAEAT,IAAAA,IAAI,CAACS,UAAL,GAAkBA,UAAlB,CArCsD;;AAwCtD,SAAK0C,IAAL,CAAU,uBAAV,EAAmC;AACjC3C,MAAAA,GAAG,EAAER,IAAI,CAACQ,GADuB;AAEjCtC,MAAAA,IAAI,EAAE,SAF2B;AAGjCkF,MAAAA,IAAI,EAAE;AACJM,QAAAA,MAAM,EAAED,aADJ;AAEJE,QAAAA,KAAK,EAAElD;AAFH;AAH2B,KAAnC;AASA,WAAO,IAAP;AACD,GAlDD;AAmDD;AAED;;;;;;;;;;AAQA,SAASmD,sBAAT,CAAgClB,KAAhC,EAAuCC,MAAvC,EAA+CzE,IAA/C,EAAqD0E,aAArD,EAAoE;AAElE;;;;;;;;;;;;;;;;;AAiBAF,EAAAA,KAAK,CAACtC,SAAN,CAAgBuC,MAAhB,IAA0B,UAASE,OAAT,EAAkBpC,UAAlB,EAA8B;AACtD,QAAIT,IAAJ;AAEA,QAAI,KAAK9B,IAAL,KAAc,OAAd,IAAyBA,IAAI,KAAK,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE,MAAM,IAAIoC,eAAJ,iBAA6BqC,MAA7B,sDAA+E,KAAKzE,IAApF,aAAN;;AAEF,QAAIR,SAAS,CAACG,MAAV,GAAmB,CAAvB,EAA0B;AAExB,UAAI,KAAK2D,KAAT,EACE,MAAM,IAAIlB,eAAJ,iBAA6BqC,MAA7B,2JAAN;AAEF,UAAM1E,MAAM,GAAG,KAAK4E,OAApB;AAAA,UACMpF,MAAM,GAAG,KAAKgD,UADpB;AAGAA,MAAAA,UAAU,GAAG/C,SAAS,CAAC,CAAD,CAAtB;AAEAsC,MAAAA,IAAI,GAAGjC,eAAe,CAAC,IAAD,EAAOE,MAAP,EAAeR,MAAf,EAAuBS,IAAvB,CAAtB;AAEA,UAAI,CAAC8B,IAAL,EACE,MAAM,IAAIK,kBAAJ,iBAAgCsC,MAAhC,4DAAuF1E,MAAvF,oBAAqGR,MAArG,UAAN;AACH,KAdD,MAeK;AACHoF,MAAAA,OAAO,GAAG,KAAKA,OAAf;AACA7C,MAAAA,IAAI,GAAG,KAAK8C,MAAL,CAAYzE,GAAZ,CAAgBwE,OAAhB,CAAP;AAEA,UAAI,CAAC7C,IAAL,EACE,MAAM,IAAIK,kBAAJ,iBAAgCsC,MAAhC,oCAA+DE,OAA/D,2BAAN;AACH;;AAED,QAAI,CAAChE,aAAa,CAAC4B,UAAD,CAAlB,EACE,MAAM,IAAIP,0BAAJ,iBAAwCyC,MAAxC,mDAAN;AAEF,QAAIzE,IAAI,KAAK,OAAT,IAAoB,EAAE8B,IAAI,YAAY4C,aAAlB,CAAxB,EACE,MAAM,IAAIvC,kBAAJ,iBAAgCsC,MAAhC,oCAA+DE,OAA/D,gBAA2E3E,IAA3E,yBAAN;AAEFV,IAAAA,MAAM,CAACwC,IAAI,CAACS,UAAN,EAAkBA,UAAlB,CAAN,CAnCsD;;AAsCtD,SAAK0C,IAAL,CAAU,uBAAV,EAAmC;AACjC3C,MAAAA,GAAG,EAAER,IAAI,CAACQ,GADuB;AAEjCtC,MAAAA,IAAI,EAAE,OAF2B;AAGjCkF,MAAAA,IAAI,EAAE;AACJpD,QAAAA,IAAI,EAAES;AADF;AAH2B,KAAnC;AAQA,WAAO,IAAP;AACD,GA/CD;AAgDD;AAED;;;;;AAGA,IAAMoD,kBAAkB,GAAG,CACzB;AACEvE,EAAAA,IAAI,EAAE,cAAAuD,OAAO;AAAA,wBAAUA,OAAV;AAAA,GADf;AAEEiB,EAAAA,QAAQ,EAAErB;AAFZ,CADyB,EAKzB;AACEnD,EAAAA,IAAI,EAAE,cAAAuD,OAAO;AAAA,wBAAUA,OAAV;AAAA,GADf;AAEEiB,EAAAA,QAAQ,EAAEf;AAFZ,CALyB,EASzB;AACEzD,EAAAA,IAAI,EAAE,cAAAuD,OAAO;AAAA,wBAAUA,OAAV;AAAA,GADf;AAEEiB,EAAAA,QAAQ,EAAEd;AAFZ,CATyB,EAazB;AACE1D,EAAAA,IAAI,EAAE,cAAAuD,OAAO;AAAA,wBAAUA,OAAV;AAAA,GADf;AAEEiB,EAAAA,QAAQ,EAAEZ;AAFZ,CAbyB,EAiBzB;AACE5D,EAAAA,IAAI,EAAE,cAAAuD,OAAO;AAAA,2BAAaA,OAAb;AAAA,GADf;AAEEiB,EAAAA,QAAQ,EAAET;AAFZ,CAjByB,EAqBzB;AACE/D,EAAAA,IAAI,EAAE,cAAAuD,OAAO;AAAA,2BAAaA,OAAb;AAAA,GADf;AAEEiB,EAAAA,QAAQ,EAAEP;AAFZ,CArByB,EAyBzB;AACEjE,EAAAA,IAAI,EAAE,cAAAuD,OAAO;AAAA,4BAAcA,OAAd;AAAA,GADf;AAEEiB,EAAAA,QAAQ,EAAEN;AAFZ,CAzByB,EA6BzB;AACElE,EAAAA,IAAI,EAAE,cAAAuD,OAAO;AAAA,0BAAYA,OAAZ;AAAA,GADf;AAEEiB,EAAAA,QAAQ,EAAEF;AAFZ,CA7ByB,CAA3B;AAmCA;;;;;;AAKO,SAASG,uBAAT,CAAiCC,KAAjC,EAAwC;AAC7CH,EAAAA,kBAAkB,CAACzB,OAAnB,CAA2B,gBAA2B;AAAA,QAAjB9C,IAAiB,QAAjBA,IAAiB;AAAA,QAAXwE,QAAW,QAAXA,QAAW;AAEpD;AACAA,IAAAA,QAAQ,CACNE,KADM,EAEN1E,IAAI,CAAC,MAAD,CAFE,EAGN,OAHM,EAIN4B,gBAJM,CAAR,CAHoD;;AAWpD4C,IAAAA,QAAQ,CACNE,KADM,EAEN1E,IAAI,CAAC,cAAD,CAFE,EAGN,UAHM,EAIN4B,gBAJM,CAAR,CAXoD;;AAmBpD4C,IAAAA,QAAQ,CACNE,KADM,EAEN1E,IAAI,CAAC,gBAAD,CAFE,EAGN,YAHM,EAIN8B,kBAJM,CAAR;AAMD,GAzBD;AA0BD;;AC9pBD;;;;;;;AAkBA;;;;AAGA,IAAM6C,eAAe,GAAG,CACtB;AACE3E,EAAAA,IAAI,EAAE,OADR;AAEEpB,EAAAA,IAAI,EAAE;AAFR,CADsB,EAKtB;AACEoB,EAAAA,IAAI,EAAE,SADR;AAEEpB,EAAAA,IAAI,EAAE,UAFR;AAGEgG,EAAAA,SAAS,EAAE;AAHb,CALsB,EAUtB;AACE5E,EAAAA,IAAI,EAAE,UADR;AAEEpB,EAAAA,IAAI,EAAE,UAFR;AAGEgG,EAAAA,SAAS,EAAE;AAHb,CAVsB,EAetB;AACE5E,EAAAA,IAAI,EAAE,cADR;AAEEpB,EAAAA,IAAI,EAAE,OAFR;AAGEgG,EAAAA,SAAS,EAAE;AAHb,CAfsB,EAoBtB;AACE5E,EAAAA,IAAI,EAAE,eADR;AAEEpB,EAAAA,IAAI,EAAE,OAFR;AAGEgG,EAAAA,SAAS,EAAE;AAHb,CApBsB,EAyBtB;AACE5E,EAAAA,IAAI,EAAE,eADR;AAEEpB,EAAAA,IAAI,EAAE;AAFR,CAzBsB,EA6BtB;AACEoB,EAAAA,IAAI,EAAE,iBADR;AAEEpB,EAAAA,IAAI,EAAE;AAFR,CA7BsB,CAAxB;AAmCA;;;;;;;;AAOA,SAASiG,OAAT,CAAiB3B,KAAjB,EAAwB4B,MAAxB,EAAgC;AAC9B,OAAK,IAAMtG,CAAX,IAAgBsG,MAAhB,EAAwB;AACtB,QAAIA,MAAM,CAACtG,CAAD,CAAN,YAAqB8D,GAAzB,EACEwC,MAAM,CAACtG,CAAD,CAAN,CAAUsE,OAAV,CAAkB,UAAAd,QAAQ;AAAA,aAAIkB,KAAK,CAAC6B,IAAN,CAAW/C,QAAQ,CAACd,GAApB,CAAJ;AAAA,KAA1B,EADF,KAGEgC,KAAK,CAAC6B,IAAN,CAAWD,MAAM,CAACtG,CAAD,CAAN,CAAU0C,GAArB;AACH;AACF;AAED;;;;;;;;AAMA,SAAS8D,aAAT,CAAuBF,MAAvB,EAA+BG,QAA/B,EAAyC;AACvC,OAAK,IAAMzG,CAAX,IAAgBsG,MAAhB,EAAwB;AACtB,QAAM9C,QAAQ,GAAG8C,MAAM,CAACtG,CAAD,CAAvB;AAEAyG,IAAAA,QAAQ,CACNjD,QAAQ,CAACd,GADH,EAENc,QAAQ,CAACb,UAFH,EAGNa,QAAQ,CAACrD,MAAT,CAAgBuC,GAHV,EAINc,QAAQ,CAAC7D,MAAT,CAAgB+C,GAJV,EAKNc,QAAQ,CAACrD,MAAT,CAAgBwC,UALV,EAMNa,QAAQ,CAAC7D,MAAT,CAAgBgD,UANV,CAAR;AAQD;AACF;;AAED,SAAS+D,YAAT,CAAsBJ,MAAtB,EAA8BG,QAA9B,EAAwC;AACtC,OAAK,IAAMzG,CAAX,IAAgBsG,MAAhB,EAAwB;AACtBA,IAAAA,MAAM,CAACtG,CAAD,CAAN,CAAUsE,OAAV,CAAkB,UAAAd,QAAQ;AAAA,aAAIiD,QAAQ,CACpCjD,QAAQ,CAACd,GAD2B,EAEpCc,QAAQ,CAACb,UAF2B,EAGpCa,QAAQ,CAACrD,MAAT,CAAgBuC,GAHoB,EAIpCc,QAAQ,CAAC7D,MAAT,CAAgB+C,GAJoB,EAKpCc,QAAQ,CAACrD,MAAT,CAAgBwC,UALoB,EAMpCa,QAAQ,CAAC7D,MAAT,CAAgBgD,UANoB,CAAZ;AAAA,KAA1B;AAQD;AACF;AAED;;;;;;;;AAMA,SAASgE,cAAT,CAAwBL,MAAxB,EAAgC;AAC9B,MAAMM,IAAI,GAAG3F,MAAM,CAAC2F,IAAP,CAAYN,MAAZ,CAAb;AAAA,MACMxG,CAAC,GAAG8G,IAAI,CAAC7G,MADf;AAGA,MAAI8G,KAAK,GAAG,IAAZ;AAAA,MACIhH,CAAC,GAAG,CADR;AAGA,SAAO,IAAIiH,QAAJ,CAAa,SAASC,IAAT,GAAgB;AAClC,QAAIvD,QAAJ;;AAEA,QAAIqD,KAAJ,EAAW;AACT,UAAMG,IAAI,GAAGH,KAAK,CAACE,IAAN,EAAb;;AAEA,UAAIC,IAAI,CAACC,IAAT,EAAe;AACbJ,QAAAA,KAAK,GAAG,IAAR;AACAhH,QAAAA,CAAC;AACD,eAAOkH,IAAI,EAAX;AACD;;AAEDvD,MAAAA,QAAQ,GAAGwD,IAAI,CAACpG,KAAhB;AACD,KAVD,MAWK;AACH,UAAIf,CAAC,IAAIC,CAAT,EACE,OAAO;AAACmH,QAAAA,IAAI,EAAE;AAAP,OAAP;AAEF,UAAMjH,CAAC,GAAG4G,IAAI,CAAC/G,CAAD,CAAd;AAEA2D,MAAAA,QAAQ,GAAG8C,MAAM,CAACtG,CAAD,CAAjB;;AAEA,UAAIwD,QAAQ,YAAYM,GAAxB,EAA6B;AAC3B+C,QAAAA,KAAK,GAAGrD,QAAQ,CAAC0D,MAAT,EAAR;AACA,eAAOH,IAAI,EAAX;AACD;;AAEDlH,MAAAA,CAAC;AACF;;AAED,WAAO;AACLoH,MAAAA,IAAI,EAAE,KADD;AAELrG,MAAAA,KAAK,EAAE,CACL4C,QAAQ,CAACd,GADJ,EAELc,QAAQ,CAACb,UAFJ,EAGLa,QAAQ,CAACrD,MAAT,CAAgBuC,GAHX,EAILc,QAAQ,CAAC7D,MAAT,CAAgB+C,GAJX,EAKLc,QAAQ,CAACrD,MAAT,CAAgBwC,UALX,EAMLa,QAAQ,CAAC7D,MAAT,CAAgBgD,UANX;AAFF,KAAP;AAWD,GAzCM,CAAP;AA0CD;AAED;;;;;;;;;;AAQA,SAASwE,aAAT,CAAuBzC,KAAvB,EAA8B4B,MAA9B,EAAsCtG,CAAtC,EAAyC;AAEvC,MAAI,EAAEA,CAAC,IAAIsG,MAAP,CAAJ,EACE;AAEF,MAAIA,MAAM,CAACtG,CAAD,CAAN,YAAqB8D,GAAzB,EACEwC,MAAM,CAACtG,CAAD,CAAN,CAAUsE,OAAV,CAAkB,UAAAd,QAAQ;AAAA,WAAIkB,KAAK,CAAC6B,IAAN,CAAW/C,QAAQ,CAACd,GAApB,CAAJ;AAAA,GAA1B,EADF,KAGEgC,KAAK,CAAC6B,IAAN,CAAWD,MAAM,CAACtG,CAAD,CAAN,CAAU0C,GAArB;AAEF;AACD;AAED;;;;;;;;;;AAQA,SAAS0E,aAAT,CAAuBd,MAAvB,EAA+BtG,CAA/B,EAAkCyG,QAAlC,EAA4C;AAE1C,MAAI,EAAEzG,CAAC,IAAIsG,MAAP,CAAJ,EACE;AAEF,MAAIA,MAAM,CAACtG,CAAD,CAAN,YAAqB8D,GAAzB,EACEwC,MAAM,CAACtG,CAAD,CAAN,CAAUsE,OAAV,CAAkB,UAAAd,QAAQ;AAAA,WAAIiD,QAAQ,CACpCjD,QAAQ,CAACd,GAD2B,EAEpCc,QAAQ,CAACb,UAF2B,EAGpCa,QAAQ,CAACrD,MAAT,CAAgBuC,GAHoB,EAIpCc,QAAQ,CAAC7D,MAAT,CAAgB+C,GAJoB,EAKpCc,QAAQ,CAACrD,MAAT,CAAgBwC,UALoB,EAMpCa,QAAQ,CAAC7D,MAAT,CAAgBgD,UANoB,CAAZ;AAAA,GAA1B,EADF,KASK;AACH,QAAMa,QAAQ,GAAG8C,MAAM,CAACtG,CAAD,CAAvB;AAEAyG,IAAAA,QAAQ,CACNjD,QAAQ,CAACd,GADH,EAENc,QAAQ,CAACb,UAFH,EAGNa,QAAQ,CAACrD,MAAT,CAAgBuC,GAHV,EAINc,QAAQ,CAAC7D,MAAT,CAAgB+C,GAJV,EAKNc,QAAQ,CAACrD,MAAT,CAAgBwC,UALV,EAMNa,QAAQ,CAAC7D,MAAT,CAAgBgD,UANV,CAAR;AAQD;AAED;AACD;AAED;;;;;;;;;AAOA,SAAS0E,oBAAT,CAA8Bf,MAA9B,EAAsCtG,CAAtC,EAAyC;AACvC,MAAMsH,CAAC,GAAGhB,MAAM,CAACtG,CAAD,CAAhB;;AAEA,MAAIsH,CAAC,YAAYxD,GAAjB,EAAsB;AACpB,QAAMyD,QAAQ,GAAGD,CAAC,CAACJ,MAAF,EAAjB;AAEA,WAAO,IAAIJ,QAAJ,CAAa,YAAW;AAC7B,UAAME,IAAI,GAAGO,QAAQ,CAACR,IAAT,EAAb;AAEA,UAAIC,IAAI,CAACC,IAAT,EACE,OAAOD,IAAP;AAEF,UAAMxD,QAAQ,GAAGwD,IAAI,CAACpG,KAAtB;AAEA,aAAO;AACLqG,QAAAA,IAAI,EAAE,KADD;AAELrG,QAAAA,KAAK,EAAE,CACL4C,QAAQ,CAACd,GADJ,EAELc,QAAQ,CAACb,UAFJ,EAGLa,QAAQ,CAACrD,MAAT,CAAgBuC,GAHX,EAILc,QAAQ,CAAC7D,MAAT,CAAgB+C,GAJX,EAKLc,QAAQ,CAACrD,MAAT,CAAgBwC,UALX,EAMLa,QAAQ,CAAC7D,MAAT,CAAgBgD,UANX;AAFF,OAAP;AAWD,KAnBM,CAAP;AAoBD;;AAED,SAAOmE,QAAQ,CAACU,EAAT,CAAY,CACjBF,CAAC,CAAC5E,GADe,EAEjB4E,CAAC,CAAC3E,UAFe,EAGjB2E,CAAC,CAACnH,MAAF,CAASuC,GAHQ,EAIjB4E,CAAC,CAAC3H,MAAF,CAAS+C,GAJQ,EAKjB4E,CAAC,CAACnH,MAAF,CAASwC,UALQ,EAMjB2E,CAAC,CAAC3H,MAAF,CAASgD,UANQ,CAAZ,CAAP;AAQD;AAED;;;;;;;;;AAOA,SAAS8E,eAAT,CAAyBvH,KAAzB,EAAgCE,IAAhC,EAAsC;AACpC,MAAIF,KAAK,CAACiE,IAAN,KAAe,CAAnB,EACE,OAAO,EAAP;AAEF,MAAI/D,IAAI,KAAK,OAAT,IAAoBA,IAAI,KAAKF,KAAK,CAACE,IAAvC,EACE,OAAOsH,IAAI,CAACxH,KAAK,CAAC8E,MAAN,CAAa4B,IAAb,EAAD,EAAsB1G,KAAK,CAAC8E,MAAN,CAAab,IAAnC,CAAX;AAEF,MAAMA,IAAI,GAAG/D,IAAI,KAAK,YAAT,GACXF,KAAK,CAACyH,cADK,GAEXzH,KAAK,CAAC0H,YAFR;AAIA,MAAMC,IAAI,GAAG,IAAIC,KAAJ,CAAU3D,IAAV,CAAb;AAAA,MACM4D,IAAI,GAAG3H,IAAI,KAAK,YADtB;AAGA,MAAIP,CAAC,GAAG,CAAR;;AAEAK,EAAAA,KAAK,CAAC8E,MAAN,CAAaV,OAAb,CAAqB,UAACpC,IAAD,EAAO1B,IAAP,EAAgB;AAEnC,QAAK0B,IAAI,YAAYoB,kBAAjB,KAAyCyE,IAA7C,EACEF,IAAI,CAAChI,CAAC,EAAF,CAAJ,GAAYW,IAAZ;AACH,GAJD;;AAMA,SAAOqH,IAAP;AACD;AAED;;;;;;;;;AAOA,SAASG,WAAT,CAAqB9H,KAArB,EAA4BE,IAA5B,EAAkCqG,QAAlC,EAA4C;AAC1C,MAAIvG,KAAK,CAACiE,IAAN,KAAe,CAAnB,EACE;;AAEF,MAAI/D,IAAI,KAAK,OAAT,IAAoBA,IAAI,KAAKF,KAAK,CAACE,IAAvC,EAA6C;AAC3CF,IAAAA,KAAK,CAAC8E,MAAN,CAAaV,OAAb,CAAqB,UAACpC,IAAD,EAAOQ,GAAP,EAAe;AAAA,UAE3BC,UAF2B,GAEGT,IAFH,CAE3BS,UAF2B;AAAA,UAEfxC,MAFe,GAEG+B,IAFH,CAEf/B,MAFe;AAAA,UAEPR,MAFO,GAEGuC,IAFH,CAEPvC,MAFO;AAIlC8G,MAAAA,QAAQ,CACN/D,GADM,EAENC,UAFM,EAGNxC,MAAM,CAACuC,GAHD,EAIN/C,MAAM,CAAC+C,GAJD,EAKNvC,MAAM,CAACwC,UALD,EAMNhD,MAAM,CAACgD,UAND,CAAR;AAQD,KAZD;AAaD,GAdD,MAeK;AACH,QAAMoF,IAAI,GAAG3H,IAAI,KAAK,YAAtB;;AAEAF,IAAAA,KAAK,CAAC8E,MAAN,CAAaV,OAAb,CAAqB,UAACpC,IAAD,EAAOQ,GAAP,EAAe;AAClC,UAAKR,IAAI,YAAYoB,kBAAjB,KAAyCyE,IAA7C,EAAmD;AAAA,YAE1CpF,UAF0C,GAEZT,IAFY,CAE1CS,UAF0C;AAAA,YAE9BxC,MAF8B,GAEZ+B,IAFY,CAE9B/B,MAF8B;AAAA,YAEtBR,MAFsB,GAEZuC,IAFY,CAEtBvC,MAFsB;AAIjD8G,QAAAA,QAAQ,CACN/D,GADM,EAENC,UAFM,EAGNxC,MAAM,CAACuC,GAHD,EAIN/C,MAAM,CAAC+C,GAJD,EAKNvC,MAAM,CAACwC,UALD,EAMNhD,MAAM,CAACgD,UAND,CAAR;AAQD;AACF,KAdD;AAeD;AACF;AAED;;;;;;;;;AAOA,SAASsF,kBAAT,CAA4B/H,KAA5B,EAAmCE,IAAnC,EAAyC;AACvC,MAAIF,KAAK,CAACiE,IAAN,KAAe,CAAnB,EACE,OAAO2C,QAAQ,CAACoB,KAAT,EAAP;AAEF,MAAIX,QAAJ;;AAEA,MAAInH,IAAI,KAAK,OAAb,EAAsB;AACpBmH,IAAAA,QAAQ,GAAGrH,KAAK,CAAC8E,MAAN,CAAakC,MAAb,EAAX;AAEA,WAAO,IAAIJ,QAAJ,CAAa,SAASC,IAAT,GAAgB;AAClC,UAAMC,IAAI,GAAGO,QAAQ,CAACR,IAAT,EAAb;AAEA,UAAIC,IAAI,CAACC,IAAT,EACE,OAAOD,IAAP;AAEF,UAAM9E,IAAI,GAAG8E,IAAI,CAACpG,KAAlB;AAEA,UAAMA,KAAK,GAAG,CACZsB,IAAI,CAACQ,GADO,EAEZR,IAAI,CAACS,UAFO,EAGZT,IAAI,CAAC/B,MAAL,CAAYuC,GAHA,EAIZR,IAAI,CAACvC,MAAL,CAAY+C,GAJA,EAKZR,IAAI,CAAC/B,MAAL,CAAYwC,UALA,EAMZT,IAAI,CAACvC,MAAL,CAAYgD,UANA,CAAd;AASA,aAAO;AAAC/B,QAAAA,KAAK,EAALA,KAAD;AAAQqG,QAAAA,IAAI,EAAE;AAAd,OAAP;AACD,KAlBM,CAAP;AAmBD;;AAEDM,EAAAA,QAAQ,GAAGrH,KAAK,CAAC8E,MAAN,CAAakC,MAAb,EAAX;AAEA,SAAO,IAAIJ,QAAJ,CAAa,SAASC,IAAT,GAAgB;AAClC,QAAMC,IAAI,GAAGO,QAAQ,CAACR,IAAT,EAAb;AAEA,QAAIC,IAAI,CAACC,IAAT,EACE,OAAOD,IAAP;AAEF,QAAM9E,IAAI,GAAG8E,IAAI,CAACpG,KAAlB;;AAEA,QAAKsB,IAAI,YAAYoB,kBAAjB,MAA0ClD,IAAI,KAAK,YAAnD,CAAJ,EAAsE;AACpE,UAAMQ,KAAK,GAAG,CACZsB,IAAI,CAACQ,GADO,EAEZR,IAAI,CAACS,UAFO,EAGZT,IAAI,CAAC/B,MAAL,CAAYuC,GAHA,EAIZR,IAAI,CAACvC,MAAL,CAAY+C,GAJA,EAKZR,IAAI,CAAC/B,MAAL,CAAYwC,UALA,EAMZT,IAAI,CAACvC,MAAL,CAAYgD,UANA,CAAd;AASA,aAAO;AAAC/B,QAAAA,KAAK,EAALA,KAAD;AAAQqG,QAAAA,IAAI,EAAE;AAAd,OAAP;AACD;;AAED,WAAOF,IAAI,EAAX;AACD,GAtBM,CAAP;AAuBD;AAED;;;;;;;;;;AAQA,SAASoB,sBAAT,CAAgC/H,IAAhC,EAAsCgG,SAAtC,EAAiDgC,QAAjD,EAA2D;AACzD,MAAM1D,KAAK,GAAG,EAAd;;AAEA,MAAItE,IAAI,KAAK,YAAb,EAA2B;AACzB,QAAIgG,SAAS,KAAK,KAAlB,EACEC,OAAO,CAAC3B,KAAD,EAAQ0D,QAAQ,MAAhB,CAAP;AACF,QAAIhC,SAAS,KAAK,IAAlB,EACEC,OAAO,CAAC3B,KAAD,EAAQ0D,QAAQ,CAAC3H,GAAjB,CAAP;AACH;;AAED,MAAIL,IAAI,KAAK,UAAb,EAAyB;AACvBiG,IAAAA,OAAO,CAAC3B,KAAD,EAAQ0D,QAAQ,CAAC1H,UAAjB,CAAP;AACD;;AAED,SAAOgE,KAAP;AACD;AAED;;;;;;;;;;;AASA,SAAS2D,kBAAT,CAA4B3E,KAA5B,EAAmCtD,IAAnC,EAAyCgG,SAAzC,EAAoDgC,QAApD,EAA8D3B,QAA9D,EAAwE;AACtE,MAAM6B,EAAE,GAAG5E,KAAK,GAAGgD,YAAH,GAAkBF,aAAlC;;AAEA,MAAIpG,IAAI,KAAK,YAAb,EAA2B;AACzB,QAAIgG,SAAS,KAAK,KAAlB,EACEkC,EAAE,CAACF,QAAQ,MAAT,EAAc3B,QAAd,CAAF;AACF,QAAIL,SAAS,KAAK,IAAlB,EACEkC,EAAE,CAACF,QAAQ,CAAC3H,GAAV,EAAegG,QAAf,CAAF;AACH;;AAED,MAAIrG,IAAI,KAAK,UAAb,EAAyB;AACvBkI,IAAAA,EAAE,CAACF,QAAQ,CAAC1H,UAAV,EAAsB+F,QAAtB,CAAF;AACD;AACF;AAED;;;;;;;;;;AAQA,SAAS8B,yBAAT,CAAmCnI,IAAnC,EAAyCgG,SAAzC,EAAoDgC,QAApD,EAA8D;AAC5D,MAAIb,QAAQ,GAAGT,QAAQ,CAACoB,KAAT,EAAf;;AAEA,MAAI9H,IAAI,KAAK,YAAb,EAA2B;AACzB,QAAIgG,SAAS,KAAK,KAAd,IAAuB,OAAOgC,QAAQ,MAAf,KAAuB,WAAlD,EACEb,QAAQ,GAAGiB,KAAK,CAACjB,QAAD,EAAWZ,cAAc,CAACyB,QAAQ,MAAT,CAAzB,CAAhB;AACF,QAAIhC,SAAS,KAAK,IAAd,IAAsB,OAAOgC,QAAQ,CAAC3H,GAAhB,KAAwB,WAAlD,EACE8G,QAAQ,GAAGiB,KAAK,CAACjB,QAAD,EAAWZ,cAAc,CAACyB,QAAQ,CAAC3H,GAAV,CAAzB,CAAhB;AACH;;AAED,MAAIL,IAAI,KAAK,UAAT,IAAuB,OAAOgI,QAAQ,CAAC1H,UAAhB,KAA+B,WAA1D,EAAuE;AACrE6G,IAAAA,QAAQ,GAAGiB,KAAK,CAACjB,QAAD,EAAWZ,cAAc,CAACyB,QAAQ,CAAC1H,UAAV,CAAzB,CAAhB;AACD;;AAED,SAAO6G,QAAP;AACD;AAED;;;;;;;;;;;AASA,SAASkB,sBAAT,CAAgCrI,IAAhC,EAAsCgG,SAAtC,EAAiD/F,UAAjD,EAA6DV,MAA7D,EAAqE;AACnE,MAAM+E,KAAK,GAAG,EAAd;;AAEA,MAAItE,IAAI,KAAK,YAAb,EAA2B;AAEzB,QAAI,OAAOC,UAAU,MAAjB,KAAyB,WAAzB,IAAwC+F,SAAS,KAAK,KAA1D,EACEe,aAAa,CAACzC,KAAD,EAAQrE,UAAU,MAAlB,EAAuBV,MAAvB,CAAb;AAEF,QAAI,OAAOU,UAAU,CAACI,GAAlB,KAA0B,WAA1B,IAAyC2F,SAAS,KAAK,IAA3D,EACEe,aAAa,CAACzC,KAAD,EAAQrE,UAAU,CAACI,GAAnB,EAAwBd,MAAxB,CAAb;AACH;;AAED,MAAIS,IAAI,KAAK,UAAb,EAAyB;AACvB,QAAI,OAAOC,UAAU,CAACK,UAAlB,KAAiC,WAArC,EACEyG,aAAa,CAACzC,KAAD,EAAQrE,UAAU,CAACK,UAAnB,EAA+Bf,MAA/B,CAAb;AACH;;AAED,SAAO+E,KAAP;AACD;AAED;;;;;;;;;;;AASA,SAASgE,kBAAT,CAA4BtI,IAA5B,EAAkCgG,SAAlC,EAA6C/F,UAA7C,EAAyDV,MAAzD,EAAiE8G,QAAjE,EAA2E;AACzE,MAAIrG,IAAI,KAAK,YAAb,EAA2B;AAEzB,QAAI,OAAOC,UAAU,MAAjB,KAAyB,WAAzB,IAAwC+F,SAAS,KAAK,KAA1D,EACEgB,aAAa,CAAC/G,UAAU,MAAX,EAAgBV,MAAhB,EAAwB8G,QAAxB,CAAb;AAEF,QAAI,OAAOpG,UAAU,CAACI,GAAlB,KAA0B,WAA1B,IAAyC2F,SAAS,KAAK,IAA3D,EACEgB,aAAa,CAAC/G,UAAU,CAACI,GAAZ,EAAiBd,MAAjB,EAAyB8G,QAAzB,CAAb;AACH;;AAED,MAAIrG,IAAI,KAAK,UAAb,EAAyB;AACvB,QAAI,OAAOC,UAAU,CAACK,UAAlB,KAAiC,WAArC,EACE0G,aAAa,CAAC/G,UAAU,CAACK,UAAZ,EAAwBf,MAAxB,EAAgC8G,QAAhC,CAAb;AACH;AACF;AAED;;;;;;;;;;;AASA,SAASkC,yBAAT,CAAmCvI,IAAnC,EAAyCgG,SAAzC,EAAoD/F,UAApD,EAAgEV,MAAhE,EAAwE;AACtE,MAAI4H,QAAQ,GAAGT,QAAQ,CAACoB,KAAT,EAAf;;AAEA,MAAI9H,IAAI,KAAK,YAAb,EAA2B;AAEzB,QACE,OAAOC,UAAU,MAAjB,KAAyB,WAAzB,IACA+F,SAAS,KAAK,KADd,IAEAzG,MAAM,IAAIU,UAAU,MAHtB,EAKEkH,QAAQ,GAAGiB,KAAK,CAACjB,QAAD,EAAWF,oBAAoB,CAAChH,UAAU,MAAX,EAAgBV,MAAhB,CAA/B,CAAhB;AAEF,QACE,OAAOU,UAAU,CAACI,GAAlB,KAA0B,WAA1B,IACA2F,SAAS,KAAK,IADd,IAEAzG,MAAM,IAAIU,UAAU,CAACI,GAHvB,EAKE8G,QAAQ,GAAGiB,KAAK,CAACjB,QAAD,EAAWF,oBAAoB,CAAChH,UAAU,CAACI,GAAZ,EAAiBd,MAAjB,CAA/B,CAAhB;AACH;;AAED,MAAIS,IAAI,KAAK,UAAb,EAAyB;AACvB,QACE,OAAOC,UAAU,CAACK,UAAlB,KAAiC,WAAjC,IACAf,MAAM,IAAIU,UAAU,CAACK,UAFvB,EAIE6G,QAAQ,GAAGiB,KAAK,CAACjB,QAAD,EAAWF,oBAAoB,CAAChH,UAAU,CAACK,UAAZ,EAAwBf,MAAxB,CAA/B,CAAhB;AACH;;AAED,SAAO4H,QAAP;AACD;AAED;;;;;;;;AAMA,SAASqB,sBAAT,CAAgChE,KAAhC,EAAuCiE,WAAvC,EAAoD;AAAA,MAEhDrH,IAFgD,GAK9CqH,WAL8C,CAEhDrH,IAFgD;AAAA,MAGhDpB,IAHgD,GAK9CyI,WAL8C,CAGhDzI,IAHgD;AAAA,MAIhDgG,SAJgD,GAK9CyC,WAL8C,CAIhDzC,SAJgD;AAOlD;;;;;;;;;;;;;;;;;AAgBAxB,EAAAA,KAAK,CAACtC,SAAN,CAAgBd,IAAhB,IAAwB,UAASrB,MAAT,EAAiBR,MAAjB,EAAyB;AAE/C;AACA,QAAIS,IAAI,KAAK,OAAT,IAAoB,KAAKA,IAAL,KAAc,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE,OAAO,EAAP;AAEF,QAAI,CAACR,SAAS,CAACG,MAAf,EACE,OAAO0H,eAAe,CAAC,IAAD,EAAOrH,IAAP,CAAtB;;AAEF,QAAIR,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;AAC1BI,MAAAA,MAAM,GAAG,KAAKA,MAAd;;AAEA,UAAMiI,QAAQ,GAAG,KAAK9H,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAjB;;AAEA,UAAI,OAAOiI,QAAP,KAAoB,WAAxB,EACE,MAAM,IAAI7F,kBAAJ,iBAAgCf,IAAhC,oCAA6DrB,MAA7D,2BAAN,CANwB;;AAS1B,aAAOgI,sBAAsB,CAC3B/H,IAAI,KAAK,OAAT,GAAmB,KAAKA,IAAxB,GAA+BA,IADJ,EAE3BgG,SAF2B,EAG3BgC,QAH2B,CAA7B;AAKD;;AAED,QAAIxI,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;AAC1BI,MAAAA,MAAM,GAAG,KAAKA,MAAd;AACAR,MAAAA,MAAM,GAAG,KAAKA,MAAd;;AAEA,UAAMU,UAAU,GAAG,KAAKC,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAnB;;AAEA,UAAI,CAACE,UAAL,EACE,MAAM,IAAIkC,kBAAJ,iBAAgCf,IAAhC,qCAA8DrB,MAA9D,kCAAN;AAEF,UAAI,CAAC,KAAKG,MAAL,CAAYwI,GAAZ,CAAgBnJ,MAAhB,CAAL,EACE,MAAM,IAAI4C,kBAAJ,iBAAgCf,IAAhC,qCAA8D7B,MAA9D,kCAAN,CAVwB;;AAa1B,aAAO8I,sBAAsB,CAACrI,IAAD,EAAOgG,SAAP,EAAkB/F,UAAlB,EAA8BV,MAA9B,CAA7B;AACD;;AAED,UAAM,IAAIyC,0BAAJ,iBAAwCZ,IAAxC,+DAAiG5B,SAAS,CAACG,MAA3G,QAAN;AACD,GA1CD;AA2CD;AAED;;;;;;;;AAMA,SAASgJ,iBAAT,CAA2BnE,KAA3B,EAAkCiE,WAAlC,EAA+C;AAAA,MAE3CrH,IAF2C,GAKzCqH,WALyC,CAE3CrH,IAF2C;AAAA,MAG3CpB,IAH2C,GAKzCyI,WALyC,CAG3CzI,IAH2C;AAAA,MAI3CgG,SAJ2C,GAKzCyC,WALyC,CAI3CzC,SAJ2C;AAO7C,MAAM4C,WAAW,GAAG,YAAYxH,IAAI,CAAC,CAAD,CAAJ,CAAQyH,WAAR,EAAZ,GAAoCzH,IAAI,CAAC0H,KAAL,CAAW,CAAX,EAAc,CAAC,CAAf,CAAxD;AAEA;;;;;;;;;;;;;;;;;;;;;AAoBAtE,EAAAA,KAAK,CAACtC,SAAN,CAAgB0G,WAAhB,IAA+B,UAAS7I,MAAT,EAAiBR,MAAjB,EAAyB8G,QAAzB,EAAmC;AAEhE;AACA,QAAIrG,IAAI,KAAK,OAAT,IAAoB,KAAKA,IAAL,KAAc,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE;;AAEF,QAAIR,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;AAC1B0G,MAAAA,QAAQ,GAAGtG,MAAX;AACA,aAAO6H,WAAW,CAAC,IAAD,EAAO5H,IAAP,EAAaqG,QAAb,CAAlB;AACD;;AAED,QAAI7G,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;AAC1BI,MAAAA,MAAM,GAAG,KAAKA,MAAd;AACAsG,MAAAA,QAAQ,GAAG9G,MAAX;;AAEA,UAAMyI,QAAQ,GAAG,KAAK9H,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAjB;;AAEA,UAAI,OAAOiI,QAAP,KAAoB,WAAxB,EACE,MAAM,IAAI7F,kBAAJ,iBAAgCyG,WAAhC,oCAAoE7I,MAApE,2BAAN,CAPwB;AAU1B;;AACA,aAAOkI,kBAAkB,CACvB,KAAK3E,KADkB,EAEvBtD,IAAI,KAAK,OAAT,GAAmB,KAAKA,IAAxB,GAA+BA,IAFR,EAGvBgG,SAHuB,EAIvBgC,QAJuB,EAKvB3B,QALuB,CAAzB;AAOD;;AAED,QAAI7G,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;AAC1BI,MAAAA,MAAM,GAAG,KAAKA,MAAd;AACAR,MAAAA,MAAM,GAAG,KAAKA,MAAd;;AAEA,UAAMU,UAAU,GAAG,KAAKC,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAnB;;AAEA,UAAI,CAACE,UAAL,EACE,MAAM,IAAIkC,kBAAJ,iBAAgCyG,WAAhC,qCAAqE7I,MAArE,kCAAN;AAEF,UAAI,CAAC,KAAKG,MAAL,CAAYwI,GAAZ,CAAgBnJ,MAAhB,CAAL,EACE,MAAM,IAAI4C,kBAAJ,iBAAgCyG,WAAhC,qCAAqErJ,MAArE,kCAAN,CAVwB;;AAa1B,aAAO+I,kBAAkB,CAACtI,IAAD,EAAOgG,SAAP,EAAkB/F,UAAlB,EAA8BV,MAA9B,EAAsC8G,QAAtC,CAAzB;AACD;;AAED,UAAM,IAAIrE,0BAAJ,iBAAwC4G,WAAxC,+DAAwGpJ,SAAS,CAACG,MAAlH,QAAN;AACD,GAhDD;AAiDD;AAED;;;;;;;;AAMO,SAASoJ,yBAAT,CAAmCvE,KAAnC,EAA0CiE,WAA1C,EAAuD;AAAA,MAEpDO,YAFoD,GAKxDP,WALwD,CAE1DrH,IAF0D;AAAA,MAG1DpB,IAH0D,GAKxDyI,WALwD,CAG1DzI,IAH0D;AAAA,MAI1DgG,SAJ0D,GAKxDyC,WALwD,CAI1DzC,SAJ0D;AAO5D,MAAM5E,IAAI,GAAG4H,YAAY,CAACF,KAAb,CAAmB,CAAnB,EAAsB,CAAC,CAAvB,IAA4B,SAAzC;AAEA;;;;;;;;;;;;;;;;;AAgBAtE,EAAAA,KAAK,CAACtC,SAAN,CAAgBd,IAAhB,IAAwB,UAASrB,MAAT,EAAiBR,MAAjB,EAAyB;AAE/C;AACA,QAAIS,IAAI,KAAK,OAAT,IAAoB,KAAKA,IAAL,KAAc,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE,OAAO0G,QAAQ,CAACoB,KAAT,EAAP;AAEF,QAAI,CAACtI,SAAS,CAACG,MAAf,EACE,OAAOkI,kBAAkB,CAAC,IAAD,EAAO7H,IAAP,CAAzB;;AAEF,QAAIR,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;AAC1BI,MAAAA,MAAM,GAAG,KAAKA,MAAd;;AAEA,UAAME,UAAU,GAAG,KAAKC,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAnB;;AAEA,UAAI,CAACE,UAAL,EACE,MAAM,IAAIkC,kBAAJ,iBAAgCf,IAAhC,oCAA6DrB,MAA7D,2BAAN,CANwB;;AAS1B,aAAOoI,yBAAyB,CAACnI,IAAD,EAAOgG,SAAP,EAAkB/F,UAAlB,CAAhC;AACD;;AAED,QAAIT,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;AAC1BI,MAAAA,MAAM,GAAG,KAAKA,MAAd;AACAR,MAAAA,MAAM,GAAG,KAAKA,MAAd;;AAEA,UAAMU,WAAU,GAAG,KAAKC,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAnB;;AAEA,UAAI,CAACE,WAAL,EACE,MAAM,IAAIkC,kBAAJ,iBAAgCf,IAAhC,qCAA8DrB,MAA9D,kCAAN;AAEF,UAAI,CAAC,KAAKG,MAAL,CAAYwI,GAAZ,CAAgBnJ,MAAhB,CAAL,EACE,MAAM,IAAI4C,kBAAJ,iBAAgCf,IAAhC,qCAA8D7B,MAA9D,kCAAN,CAVwB;;AAa1B,aAAOgJ,yBAAyB,CAACvI,IAAD,EAAOgG,SAAP,EAAkB/F,WAAlB,EAA8BV,MAA9B,CAAhC;AACD;;AAED,UAAM,IAAIyC,0BAAJ,iBAAwCZ,IAAxC,+DAAiG5B,SAAS,CAACG,MAA3G,QAAN;AACD,GAtCD;AAuCD;AAED;;;;;;AAKO,SAASsJ,0BAAT,CAAoCnD,KAApC,EAA2C;AAChDC,EAAAA,eAAe,CAAC7B,OAAhB,CAAwB,UAAAuE,WAAW,EAAI;AACrCD,IAAAA,sBAAsB,CAAC1C,KAAD,EAAQ2C,WAAR,CAAtB;AACAE,IAAAA,iBAAiB,CAAC7C,KAAD,EAAQ2C,WAAR,CAAjB;AACAM,IAAAA,yBAAyB,CAACjD,KAAD,EAAQ2C,WAAR,CAAzB;AACD,GAJD;AAKD;;ACrzBD;;;;;;;AAgBA;;;;AAGA,IAAMS,mBAAmB,GAAG,CAC1B;AACE9H,EAAAA,IAAI,EAAE,WADR;AAEEpB,EAAAA,IAAI,EAAE;AAFR,CAD0B,EAK1B;AACEoB,EAAAA,IAAI,EAAE,aADR;AAEEpB,EAAAA,IAAI,EAAE,UAFR;AAGEgG,EAAAA,SAAS,EAAE;AAHb,CAL0B,EAU1B;AACE5E,EAAAA,IAAI,EAAE,cADR;AAEEpB,EAAAA,IAAI,EAAE,UAFR;AAGEgG,EAAAA,SAAS,EAAE;AAHb,CAV0B,EAe1B;AACE5E,EAAAA,IAAI,EAAE,kBADR;AAEEpB,EAAAA,IAAI,EAAE,OAFR;AAGEgG,EAAAA,SAAS,EAAE;AAHb,CAf0B,EAoB1B;AACE5E,EAAAA,IAAI,EAAE,mBADR;AAEEpB,EAAAA,IAAI,EAAE,OAFR;AAGEgG,EAAAA,SAAS,EAAE;AAHb,CApB0B,EAyB1B;AACE5E,EAAAA,IAAI,EAAE,mBADR;AAEEpB,EAAAA,IAAI,EAAE;AAFR,CAzB0B,EA6B1B;AACEoB,EAAAA,IAAI,EAAE,qBADR;AAEEpB,EAAAA,IAAI,EAAE;AAFR,CA7B0B,CAA5B;AAmCA;;;;;;;AAMA,SAASmJ,KAAT,CAAeC,SAAf,EAA0BlD,MAA1B,EAAkC;AAChC,MAAI,OAAOA,MAAP,KAAkB,WAAtB,EACE;;AAEF,OAAK,IAAM7B,QAAX,IAAuB6B,MAAvB;AACEkD,IAAAA,SAAS,CAACzF,GAAV,CAAcU,QAAd;AADF;AAED;AAED;;;;;;;;;;AAQA,SAASgF,0BAAT,CAAoCrJ,IAApC,EAA0CgG,SAA1C,EAAqDgC,QAArD,EAA+D;AAE7D;AACA,MAAIhI,IAAI,KAAK,OAAb,EAAsB;AACpB,QAAIA,IAAI,KAAK,YAAb,EACE,OAAOa,MAAM,CAAC2F,IAAP,CAAYwB,QAAQ,CAAC1H,UAArB,CAAP;AAEF,QAAI,OAAO0F,SAAP,KAAqB,QAAzB,EACE,OAAOnF,MAAM,CAAC2F,IAAP,CAAYwB,QAAQ,CAAChC,SAAD,CAApB,CAAP;AACH,GAT4D;;;AAY7D,MAAMoD,SAAS,GAAG,IAAI1F,GAAJ,EAAlB;;AAEA,MAAI1D,IAAI,KAAK,YAAb,EAA2B;AAEzB,QAAIgG,SAAS,KAAK,KAAlB,EAAyB;AACvBmD,MAAAA,KAAK,CAACC,SAAD,EAAYpB,QAAQ,MAApB,CAAL;AACD;;AACD,QAAIhC,SAAS,KAAK,IAAlB,EAAwB;AACtBmD,MAAAA,KAAK,CAACC,SAAD,EAAYpB,QAAQ,CAAC3H,GAArB,CAAL;AACD;AACF;;AAED,MAAIL,IAAI,KAAK,UAAb,EAAyB;AACvBmJ,IAAAA,KAAK,CAACC,SAAD,EAAYpB,QAAQ,CAAC1H,UAArB,CAAL;AACD;;AAED,SAAOgH,IAAI,CAAC8B,SAAS,CAACtC,MAAV,EAAD,EAAqBsC,SAAS,CAACrF,IAA/B,CAAX;AACD;AAED;;;;;;;;;;;AASA,SAASuF,eAAT,CAAyBtB,QAAzB,EAAmC9B,MAAnC,EAA2CG,QAA3C,EAAqD;AACnD,OAAK,IAAMzG,CAAX,IAAgBsG,MAAhB,EAAwB;AACtB,QAAI9C,QAAQ,GAAG8C,MAAM,CAACtG,CAAD,CAArB;AAEA,QAAIwD,QAAQ,YAAYM,GAAxB,EACEN,QAAQ,GAAGA,QAAQ,CAAC0D,MAAT,GAAkBH,IAAlB,GAAyBnG,KAApC;AAEF,QAAMP,UAAU,GAAGmD,QAAQ,CAACrD,MAA5B;AAAA,QACMsD,UAAU,GAAGD,QAAQ,CAAC7D,MAD5B;AAGA,QAAMgK,YAAY,GAAGtJ,UAAU,KAAK+H,QAAf,GAA0B3E,UAA1B,GAAuCpD,UAA5D;AAEAoG,IAAAA,QAAQ,CACNkD,YAAY,CAACjH,GADP,EAENiH,YAAY,CAAChH,UAFP,CAAR;AAID;AACF;;AAED,SAASiH,mBAAT,CAA6BC,OAA7B,EAAsCzB,QAAtC,EAAgD9B,MAAhD,EAAwDG,QAAxD,EAAkE;AAChE,OAAK,IAAMzG,CAAX,IAAgBsG,MAAhB,EAAwB;AACtB,QAAI9C,QAAQ,GAAG8C,MAAM,CAACtG,CAAD,CAArB;AAEA,QAAIwD,QAAQ,YAAYM,GAAxB,EACEN,QAAQ,GAAGA,QAAQ,CAAC0D,MAAT,GAAkBH,IAAlB,GAAyBnG,KAApC;AAEF,QAAMP,UAAU,GAAGmD,QAAQ,CAACrD,MAA5B;AAAA,QACMsD,UAAU,GAAGD,QAAQ,CAAC7D,MAD5B;AAGA,QAAMgK,YAAY,GAAGtJ,UAAU,KAAK+H,QAAf,GAA0B3E,UAA1B,GAAuCpD,UAA5D;AAEA,QAAIwJ,OAAO,CAACf,GAAR,CAAYa,YAAY,CAACjH,GAAzB,CAAJ,EACE;AAEFmH,IAAAA,OAAO,CAAC9F,GAAR,CAAY4F,YAAY,CAACjH,GAAzB;AAEA+D,IAAAA,QAAQ,CACNkD,YAAY,CAACjH,GADP,EAENiH,YAAY,CAAChH,UAFP,CAAR;AAID;AACF;;AAED,SAASmH,sBAAT,CAAgC1J,IAAhC,EAAsCgG,SAAtC,EAAiDgC,QAAjD,EAA2D3B,QAA3D,EAAqE;AAEnE;AACA,MAAIrG,IAAI,KAAK,OAAb,EAAsB;AACpB,QAAIA,IAAI,KAAK,YAAb,EACE,OAAOsJ,eAAe,CAACtB,QAAD,EAAWA,QAAQ,CAAC1H,UAApB,EAAgC+F,QAAhC,CAAtB;AAEF,QAAI,OAAOL,SAAP,KAAqB,QAAzB,EACE,OAAOsD,eAAe,CAACtB,QAAD,EAAWA,QAAQ,CAAChC,SAAD,CAAnB,EAAgCK,QAAhC,CAAtB;AACH,GATkE;;;AAYnE,MAAMoD,OAAO,GAAG,IAAI/F,GAAJ,EAAhB;;AAEA,MAAI1D,IAAI,KAAK,YAAb,EAA2B;AAEzB,QAAIgG,SAAS,KAAK,KAAlB,EAAyB;AACvBwD,MAAAA,mBAAmB,CAACC,OAAD,EAAUzB,QAAV,EAAoBA,QAAQ,MAA5B,EAAiC3B,QAAjC,CAAnB;AACD;;AACD,QAAIL,SAAS,KAAK,IAAlB,EAAwB;AACtBwD,MAAAA,mBAAmB,CAACC,OAAD,EAAUzB,QAAV,EAAoBA,QAAQ,CAAC3H,GAA7B,EAAkCgG,QAAlC,CAAnB;AACD;AACF;;AAED,MAAIrG,IAAI,KAAK,UAAb,EAAyB;AACvBwJ,IAAAA,mBAAmB,CAACC,OAAD,EAAUzB,QAAV,EAAoBA,QAAQ,CAAC1H,UAA7B,EAAyC+F,QAAzC,CAAnB;AACD;AACF;AAED;;;;;;;;;;AAQA,SAASsD,oBAAT,CAA8B3B,QAA9B,EAAwC9B,MAAxC,EAAgD;AAC9C,MAAMM,IAAI,GAAG3F,MAAM,CAAC2F,IAAP,CAAYN,MAAZ,CAAb;AAAA,MACMxG,CAAC,GAAG8G,IAAI,CAAC7G,MADf;AAGA,MAAIF,CAAC,GAAG,CAAR;AAEA,SAAO,IAAIiH,QAAJ,CAAa,YAAW;AAC7B,QAAIjH,CAAC,IAAIC,CAAT,EACE,OAAO;AAACmH,MAAAA,IAAI,EAAE;AAAP,KAAP;AAEF,QAAIzD,QAAQ,GAAG8C,MAAM,CAACM,IAAI,CAAC/G,CAAC,EAAF,CAAL,CAArB;AAEA,QAAI2D,QAAQ,YAAYM,GAAxB,EACEN,QAAQ,GAAGA,QAAQ,CAAC0D,MAAT,GAAkBH,IAAlB,GAAyBnG,KAApC;AAEF,QAAMP,UAAU,GAAGmD,QAAQ,CAACrD,MAA5B;AAAA,QACMsD,UAAU,GAAGD,QAAQ,CAAC7D,MAD5B;AAGA,QAAMgK,YAAY,GAAGtJ,UAAU,KAAK+H,QAAf,GAA0B3E,UAA1B,GAAuCpD,UAA5D;AAEA,WAAO;AACL4G,MAAAA,IAAI,EAAE,KADD;AAELrG,MAAAA,KAAK,EAAE,CAAC+I,YAAY,CAACjH,GAAd,EAAmBiH,YAAY,CAAChH,UAAhC;AAFF,KAAP;AAID,GAlBM,CAAP;AAmBD;;AAED,SAASqH,2BAAT,CAAqCH,OAArC,EAA8CzB,QAA9C,EAAwD9B,MAAxD,EAAgE;AAC9D,MAAMM,IAAI,GAAG3F,MAAM,CAAC2F,IAAP,CAAYN,MAAZ,CAAb;AAAA,MACMxG,CAAC,GAAG8G,IAAI,CAAC7G,MADf;AAGA,MAAIF,CAAC,GAAG,CAAR;AAEA,SAAO,IAAIiH,QAAJ,CAAa,SAASC,IAAT,GAAgB;AAClC,QAAIlH,CAAC,IAAIC,CAAT,EACE,OAAO;AAACmH,MAAAA,IAAI,EAAE;AAAP,KAAP;AAEF,QAAIzD,QAAQ,GAAG8C,MAAM,CAACM,IAAI,CAAC/G,CAAC,EAAF,CAAL,CAArB;AAEA,QAAI2D,QAAQ,YAAYM,GAAxB,EACEN,QAAQ,GAAGA,QAAQ,CAAC0D,MAAT,GAAkBH,IAAlB,GAAyBnG,KAApC;AAEF,QAAMP,UAAU,GAAGmD,QAAQ,CAACrD,MAA5B;AAAA,QACMsD,UAAU,GAAGD,QAAQ,CAAC7D,MAD5B;AAGA,QAAMgK,YAAY,GAAGtJ,UAAU,KAAK+H,QAAf,GAA0B3E,UAA1B,GAAuCpD,UAA5D;AAEA,QAAIwJ,OAAO,CAACf,GAAR,CAAYa,YAAY,CAACjH,GAAzB,CAAJ,EACE,OAAOqE,IAAI,EAAX;AAEF8C,IAAAA,OAAO,CAAC9F,GAAR,CAAY4F,YAAY,CAACjH,GAAzB;AAEA,WAAO;AACLuE,MAAAA,IAAI,EAAE,KADD;AAELrG,MAAAA,KAAK,EAAE,CAAC+I,YAAY,CAACjH,GAAd,EAAmBiH,YAAY,CAAChH,UAAhC;AAFF,KAAP;AAID,GAvBM,CAAP;AAwBD;;AAED,SAASsH,sBAAT,CAAgC7J,IAAhC,EAAsCgG,SAAtC,EAAiDgC,QAAjD,EAA2D;AAEzD;AACA,MAAIhI,IAAI,KAAK,OAAb,EAAsB;AACpB,QAAIA,IAAI,KAAK,YAAb,EACE,OAAO2J,oBAAoB,CAAC3B,QAAD,EAAWA,QAAQ,CAAC1H,UAApB,CAA3B;AAEF,QAAI,OAAO0F,SAAP,KAAqB,QAAzB,EACE,OAAO2D,oBAAoB,CAAC3B,QAAD,EAAWA,QAAQ,CAAChC,SAAD,CAAnB,CAA3B;AACH;;AAED,MAAImB,QAAQ,GAAGT,QAAQ,CAACoB,KAAT,EAAf,CAXyD;;AAczD,MAAM2B,OAAO,GAAG,IAAI/F,GAAJ,EAAhB;;AAEA,MAAI1D,IAAI,KAAK,YAAb,EAA2B;AAEzB,QAAIgG,SAAS,KAAK,KAAlB,EAAyB;AACvBmB,MAAAA,QAAQ,GAAGiB,KAAK,CAACjB,QAAD,EAAWyC,2BAA2B,CAACH,OAAD,EAAUzB,QAAV,EAAoBA,QAAQ,MAA5B,CAAtC,CAAhB;AACD;;AACD,QAAIhC,SAAS,KAAK,IAAlB,EAAwB;AACtBmB,MAAAA,QAAQ,GAAGiB,KAAK,CAACjB,QAAD,EAAWyC,2BAA2B,CAACH,OAAD,EAAUzB,QAAV,EAAoBA,QAAQ,CAAC3H,GAA7B,CAAtC,CAAhB;AACD;AACF;;AAED,MAAIL,IAAI,KAAK,UAAb,EAAyB;AACvBmH,IAAAA,QAAQ,GAAGiB,KAAK,CAACjB,QAAD,EAAWyC,2BAA2B,CAACH,OAAD,EAAUzB,QAAV,EAAoBA,QAAQ,CAAC1H,UAA7B,CAAtC,CAAhB;AACD;;AAED,SAAO6G,QAAP;AACD;AAED;;;;;;;;;;;;AAUA,SAAS2C,eAAT,CAAyBhK,KAAzB,EAAgCE,IAAhC,EAAsCgG,SAAtC,EAAiD5B,IAAjD,EAAuDC,QAAvD,EAAiE;AAE/D,MAAM2D,QAAQ,GAAGlI,KAAK,CAACI,MAAN,CAAaC,GAAb,CAAiBiE,IAAjB,CAAjB;;AAEA,MAAIpE,IAAI,KAAK,YAAb,EAA2B;AAEzB,QAAIgG,SAAS,KAAK,KAAd,IAAuB,OAAOgC,QAAQ,MAAf,KAAuB,WAAlD,EAA+D;AAC7D,WAAK,IAAMpI,CAAX,IAAgBoI,QAAQ,MAAxB;AACE,YAAIpI,CAAC,KAAKyE,QAAV,EACE,OAAO,IAAP;AAFJ;AAGD;;AACD,QAAI2B,SAAS,KAAK,IAAd,IAAsB,OAAOgC,QAAQ,CAAC3H,GAAhB,KAAwB,WAAlD,EAA+D;AAC7D,WAAK,IAAMT,EAAX,IAAgBoI,QAAQ,CAAC3H,GAAzB;AACE,YAAIT,EAAC,KAAKyE,QAAV,EACE,OAAO,IAAP;AAFJ;AAGD;AACF;;AAED,MAAIrE,IAAI,KAAK,UAAT,IAAuB,OAAOgI,QAAQ,CAAC1H,UAAhB,KAA+B,WAA1D,EAAuE;AACrE,SAAK,IAAMV,GAAX,IAAgBoI,QAAQ,CAAC1H,UAAzB;AACI,UAAIV,GAAC,KAAKyE,QAAV,EACE,OAAO,IAAP;AAFN;AAGD;;AAED,SAAO,KAAP;AACD;AAED;;;;;;;;AAMA,SAAS0F,0BAAT,CAAoCvF,KAApC,EAA2CiE,WAA3C,EAAwD;AAAA,MAEpDrH,IAFoD,GAKlDqH,WALkD,CAEpDrH,IAFoD;AAAA,MAGpDpB,IAHoD,GAKlDyI,WALkD,CAGpDzI,IAHoD;AAAA,MAIpDgG,SAJoD,GAKlDyC,WALkD,CAIpDzC,SAJoD;AAOtD;;;;;;;;;;;;;;;AAcAxB,EAAAA,KAAK,CAACtC,SAAN,CAAgBd,IAAhB,IAAwB,UAASgD,IAAT,EAAe;AAErC;AACA,QAAIpE,IAAI,KAAK,OAAT,IAAoB,KAAKA,IAAL,KAAc,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE,OAAO,EAAP;;AAEF,QAAIR,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;AAC1B,UAAMqK,KAAK,GAAG,KAAKxK,SAAS,CAAC,CAAD,CAA5B;AAAA,UACMyK,KAAK,GAAG,KAAKzK,SAAS,CAAC,CAAD,CAD5B;AAGA,UAAI,CAAC,KAAKU,MAAL,CAAYwI,GAAZ,CAAgBsB,KAAhB,CAAL,EACE,MAAM,IAAI7H,kBAAJ,iBAAgCf,IAAhC,oCAA6D4I,KAA7D,2BAAN;AAEF,UAAI,CAAC,KAAK9J,MAAL,CAAYwI,GAAZ,CAAgBuB,KAAhB,CAAL,EACE,MAAM,IAAI9H,kBAAJ,iBAAgCf,IAAhC,oCAA6D6I,KAA7D,2BAAN,CARwB;;AAW1B,aAAOH,eAAe,CACpB,IADoB,EAEpB9J,IAFoB,EAGpBgG,SAHoB,EAIpBgE,KAJoB,EAKpBC,KALoB,CAAtB;AAOD,KAlBD,MAmBK,IAAIzK,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;AAC/ByE,MAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,UAAM4D,QAAQ,GAAG,KAAK9H,MAAL,CAAYC,GAAZ,CAAgBiE,IAAhB,CAAjB;;AAEA,UAAI,OAAO4D,QAAP,KAAoB,WAAxB,EACE,MAAM,IAAI7F,kBAAJ,iBAAgCf,IAAhC,oCAA6DgD,IAA7D,2BAAN,CAN6B;;AAS/B,UAAMgF,SAAS,GAAGC,0BAA0B,CAC1CrJ,IAAI,KAAK,OAAT,GAAmB,KAAKA,IAAxB,GAA+BA,IADW,EAE1CgG,SAF0C,EAG1CgC,QAH0C,CAA5C;AAMA,aAAOoB,SAAP;AACD;;AAED,UAAM,IAAIpH,0BAAJ,iBAAwCZ,IAAxC,qEAAuG5B,SAAS,CAACG,MAAjH,QAAN;AACD,GA5CD;AA6CD;AAED;;;;;;;;AAMA,SAASuK,qBAAT,CAA+B1F,KAA/B,EAAsCiE,WAAtC,EAAmD;AAAA,MAE/CrH,IAF+C,GAK7CqH,WAL6C,CAE/CrH,IAF+C;AAAA,MAG/CpB,IAH+C,GAK7CyI,WAL6C,CAG/CzI,IAH+C;AAAA,MAI/CgG,SAJ+C,GAK7CyC,WAL6C,CAI/CzC,SAJ+C;AAOjD,MAAM4C,WAAW,GAAG,YAAYxH,IAAI,CAAC,CAAD,CAAJ,CAAQyH,WAAR,EAAZ,GAAoCzH,IAAI,CAAC0H,KAAL,CAAW,CAAX,EAAc,CAAC,CAAf,CAAxD;AAEA;;;;;;;;;;AASAtE,EAAAA,KAAK,CAACtC,SAAN,CAAgB0G,WAAhB,IAA+B,UAASxE,IAAT,EAAeiC,QAAf,EAAyB;AAEtD;AACA,QAAIrG,IAAI,KAAK,OAAT,IAAoB,KAAKA,IAAL,KAAc,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE;AAEFoE,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAM4D,QAAQ,GAAG,KAAK9H,MAAL,CAAYC,GAAZ,CAAgBiE,IAAhB,CAAjB;;AAEA,QAAI,OAAO4D,QAAP,KAAoB,WAAxB,EACE,MAAM,IAAI7F,kBAAJ,iBAAgCyG,WAAhC,oCAAoExE,IAApE,2BAAN,CAXoD;;AActDsF,IAAAA,sBAAsB,CACpB1J,IAAI,KAAK,OAAT,GAAmB,KAAKA,IAAxB,GAA+BA,IADX,EAEpBgG,SAFoB,EAGpBgC,QAHoB,EAIpB3B,QAJoB,CAAtB;AAMD,GApBD;AAqBD;AAED;;;;;;;;AAMA,SAAS8D,6BAAT,CAAuC3F,KAAvC,EAA8CiE,WAA9C,EAA2D;AAAA,MAEvDrH,IAFuD,GAKrDqH,WALqD,CAEvDrH,IAFuD;AAAA,MAGvDpB,IAHuD,GAKrDyI,WALqD,CAGvDzI,IAHuD;AAAA,MAIvDgG,SAJuD,GAKrDyC,WALqD,CAIvDzC,SAJuD;AAOzD,MAAMoE,YAAY,GAAGhJ,IAAI,CAAC0H,KAAL,CAAW,CAAX,EAAc,CAAC,CAAf,IAAoB,SAAzC;AAEA;;;;;;;;;AAQAtE,EAAAA,KAAK,CAACtC,SAAN,CAAgBkI,YAAhB,IAAgC,UAAShG,IAAT,EAAe;AAE7C;AACA,QAAIpE,IAAI,KAAK,OAAT,IAAoB,KAAKA,IAAL,KAAc,OAAlC,IAA6CA,IAAI,KAAK,KAAKA,IAA/D,EACE,OAAO0G,QAAQ,CAACoB,KAAT,EAAP;AAEF1D,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAM4D,QAAQ,GAAG,KAAK9H,MAAL,CAAYC,GAAZ,CAAgBiE,IAAhB,CAAjB;;AAEA,QAAI,OAAO4D,QAAP,KAAoB,WAAxB,EACE,MAAM,IAAI7F,kBAAJ,iBAAgCiI,YAAhC,oCAAqEhG,IAArE,2BAAN,CAX2C;;AAc7C,WAAOyF,sBAAsB,CAC3B7J,IAAI,KAAK,OAAT,GAAmB,KAAKA,IAAxB,GAA+BA,IADJ,EAE3BgG,SAF2B,EAG3BgC,QAH2B,CAA7B;AAKD,GAnBD;AAoBD;AAED;;;;;;;AAKO,SAASqC,8BAAT,CAAwCvE,KAAxC,EAA+C;AACpDoD,EAAAA,mBAAmB,CAAChF,OAApB,CAA4B,UAAAuE,WAAW,EAAI;AACzCsB,IAAAA,0BAA0B,CAACjE,KAAD,EAAQ2C,WAAR,CAA1B;AACAyB,IAAAA,qBAAqB,CAACpE,KAAD,EAAQ2C,WAAR,CAArB;AACA0B,IAAAA,6BAA6B,CAACrE,KAAD,EAAQ2C,WAAR,CAA7B;AACD,GAJD;AAKD;;ACtfD;;;;;;;;;;;;;;;;AAmBA;;;;;;;;AAOO,SAAS6B,aAAT,CAAuBhI,GAAvB,EAA4BR,IAA5B,EAAkC;AACvC,MAAMyI,UAAU,GAAG;AAACjI,IAAAA,GAAG,EAAHA;AAAD,GAAnB;AAEA,MAAIzB,MAAM,CAAC2F,IAAP,CAAY1E,IAAI,CAACS,UAAjB,EAA6B5C,MAAjC,EACE4K,UAAU,CAAChI,UAAX,GAAwBjD,MAAM,CAAC,EAAD,EAAKwC,IAAI,CAACS,UAAV,CAA9B;AAEF,SAAOgI,UAAP;AACD;AAED;;;;;;;;AAOO,SAASC,aAAT,CAAuBlI,GAAvB,EAA4BR,IAA5B,EAAkC;AACvC,MAAMyI,UAAU,GAAG;AACjBxK,IAAAA,MAAM,EAAE+B,IAAI,CAAC/B,MAAL,CAAYuC,GADH;AAEjB/C,IAAAA,MAAM,EAAEuC,IAAI,CAACvC,MAAL,CAAY+C;AAFH,GAAnB,CADuC;;AAOvC,MAAI,CAACR,IAAI,CAACmB,YAAV,EACEsH,UAAU,CAACjI,GAAX,GAAiBA,GAAjB;AAEF,MAAIzB,MAAM,CAAC2F,IAAP,CAAY1E,IAAI,CAACS,UAAjB,EAA6B5C,MAAjC,EACE4K,UAAU,CAAChI,UAAX,GAAwBjD,MAAM,CAAC,EAAD,EAAKwC,IAAI,CAACS,UAAV,CAA9B;AAEF,MAAIT,IAAI,YAAYoB,kBAApB,EACEqH,UAAU,CAACjK,UAAX,GAAwB,IAAxB;AAEF,SAAOiK,UAAP;AACD;AAED;;;;;;;AAMO,SAASE,sBAAT,CAAgCjK,KAAhC,EAAuC;AAC5C,MAAI,CAACG,aAAa,CAACH,KAAD,CAAlB,EACE,OAAO,YAAP;AAEF,MAAI,EAAE,SAASA,KAAX,CAAJ,EACE,OAAO,QAAP;AAEF,MAAI,gBAAgBA,KAAhB,KACC,CAACG,aAAa,CAACH,KAAK,CAAC+B,UAAP,CAAd,IAAoC/B,KAAK,CAAC+B,UAAN,KAAqB,IAD1D,CAAJ,EAEE,OAAO,oBAAP;AAEF,SAAO,IAAP;AACD;AAED;;;;;;;AAMO,SAASmI,sBAAT,CAAgClK,KAAhC,EAAuC;AAC5C,MAAI,CAACG,aAAa,CAACH,KAAD,CAAlB,EACE,OAAO,YAAP;AAEF,MAAI,EAAE,YAAYA,KAAd,CAAJ,EACE,OAAO,WAAP;AAEF,MAAI,EAAE,YAAYA,KAAd,CAAJ,EACE,OAAO,WAAP;AAEF,MAAI,gBAAgBA,KAAhB,KACC,CAACG,aAAa,CAACH,KAAK,CAAC+B,UAAP,CAAd,IAAoC/B,KAAK,CAAC+B,UAAN,KAAqB,IAD1D,CAAJ,EAEE,OAAO,oBAAP;AAEF,MAAI,gBAAgB/B,KAAhB,IACC,OAAOA,KAAK,CAACF,UAAb,KAA4B,SADjC,EAEE,OAAO,oBAAP;AAEF,SAAO,IAAP;AACD;;ACpDD;;;;AAGA,IAAMqK,KAAK,GAAG,IAAIjH,GAAJ,CAAQ,CACpB,UADoB,EAEpB,YAFoB,EAGpB,OAHoB,CAAR,CAAd;AAMA,IAAMkH,aAAa,GAAG,IAAIlH,GAAJ,CAAQ,CAC5B,QAD4B,EAE5B,SAF4B,EAG5B,cAH4B,EAI5B,eAJ4B,CAAR,CAAtB;AAOA,IAAMmH,gBAAgB,GAAG,CACvB;AACEzJ,EAAAA,IAAI,EAAE,cAAA0J,IAAI;AAAA,qBAAOA,IAAP;AAAA,GADZ;AAEEC,EAAAA,WAAW,EAAE;AAFf,CADuB,EAKvB;AACE3J,EAAAA,IAAI,EAAE,cAAA0J,IAAI;AAAA,qBAAOA,IAAP;AAAA,GADZ;AAEEC,EAAAA,WAAW,EAAE,IAFf;AAGE/K,EAAAA,IAAI,EAAE;AAHR,CALuB,EAUvB;AACEoB,EAAAA,IAAI,EAAE,cAAA0J,IAAI;AAAA,qBAAOA,IAAP;AAAA,GADZ;AAEEC,EAAAA,WAAW,EAAE,IAFf;AAGE/K,EAAAA,IAAI,EAAE;AAHR,CAVuB,EAevB;AACEoB,EAAAA,IAAI,EAAE,cAAA0J,IAAI;AAAA,qBAAOA,IAAP;AAAA;AADZ,CAfuB,EAkBvB;AACE1J,EAAAA,IAAI,EAAE,cAAA0J,IAAI;AAAA,qBAAOA,IAAP;AAAA,GADZ;AAEE9K,EAAAA,IAAI,EAAE;AAFR,CAlBuB,EAsBvB;AACEoB,EAAAA,IAAI,EAAE,cAAA0J,IAAI;AAAA,qBAAOA,IAAP;AAAA,GADZ;AAEE9K,EAAAA,IAAI,EAAE;AAFR,CAtBuB,CAAzB;AA4BA;;;;AAGA,IAAMgL,QAAQ,GAAG;AACfC,EAAAA,cAAc,EAAE,IADD;AAEfC,EAAAA,gBAAgB,EAAE,IAFH;AAGf5H,EAAAA,KAAK,EAAE,KAHQ;AAIftD,EAAAA,IAAI,EAAE;AAJS,CAAjB;AAOA;;;;AAIA;;;;;;;;;;;;;;;;;;;AAkBA,SAASmL,OAAT,CACErL,KADF,EAEEsB,IAFF,EAGEgK,eAHF,EAIE9K,UAJF,EAKEF,IALF,EAMEL,MANF,EAOER,MAPF,EAQEgD,UARF,EASE;AAEA;AACA,MAAI,CAACjC,UAAD,IAAeR,KAAK,CAACE,IAAN,KAAe,YAAlC,EACE,MAAM,IAAIoC,eAAJ,iBAA6BhB,IAA7B,gHAAN;AAEF,MAAId,UAAU,IAAIR,KAAK,CAACE,IAAN,KAAe,UAAjC,EACE,MAAM,IAAIoC,eAAJ,iBAA6BhB,IAA7B,8GAAN;AAEF,MAAImB,UAAU,IAAI,CAAC5B,aAAa,CAAC4B,UAAD,CAAhC,EACE,MAAM,IAAIP,0BAAJ,iBAAwCZ,IAAxC,iEAAkGmB,UAAlG,QAAN,CAVF;;AAaAxC,EAAAA,MAAM,GAAG,KAAKA,MAAd;AACAR,EAAAA,MAAM,GAAG,KAAKA,MAAd;AACAgD,EAAAA,UAAU,GAAGA,UAAU,IAAI,EAA3B;AAEA,MAAI,CAACzC,KAAK,CAACmL,cAAP,IAAyBlL,MAAM,KAAKR,MAAxC,EACE,MAAM,IAAI6C,eAAJ,iBAA6BhB,IAA7B,+CAAqErB,MAArE,wGAAN;;AAEF,MAAME,UAAU,GAAGH,KAAK,CAACI,MAAN,CAAaC,GAAb,CAAiBJ,MAAjB,CAAnB;AAAA,MACMsD,UAAU,GAAGvD,KAAK,CAACI,MAAN,CAAaC,GAAb,CAAiBZ,MAAjB,CADnB;;AAGA,MAAI,CAACU,UAAL,EACE,MAAM,IAAIkC,kBAAJ,iBAAgCf,IAAhC,6BAAsDrB,MAAtD,mBAAN;AAEF,MAAI,CAACsD,UAAL,EACE,MAAM,IAAIlB,kBAAJ,iBAAgCf,IAAhC,6BAAsD7B,MAAtD,mBAAN,CA3BF;;AA8BA,MAAM8L,SAAS,GAAG;AAChB/I,IAAAA,GAAG,EAAE,IADW;AAEhBhC,IAAAA,UAAU,EAAVA,UAFgB;AAGhBP,IAAAA,MAAM,EAANA,MAHgB;AAIhBR,IAAAA,MAAM,EAANA,MAJgB;AAKhBgD,IAAAA,UAAU,EAAVA;AALgB,GAAlB;AAQA,MAAI6I,eAAJ,EACEhL,IAAI,GAAGN,KAAK,CAACwL,iBAAN,CAAwBD,SAAxB,CAAP,CAvCF;;AA0CAjL,EAAAA,IAAI,GAAG,KAAKA,IAAZ,CA1CA;;AA6CA,MAAIN,KAAK,CAAC8E,MAAN,CAAa8D,GAAb,CAAiBtI,IAAjB,CAAJ,EACE,MAAM,IAAIgC,eAAJ,iBAA6BhB,IAA7B,qBAA2ChB,IAA3C,0CAAN,CA9CF;;AAiDA,MACE,CAACN,KAAK,CAACwD,KAAP,KAEEhD,UAAU,GACR,OAAOL,UAAU,CAACK,UAAX,CAAsBf,MAAtB,CAAP,KAAyC,WADjC,GAER,OAAOU,UAAU,CAACI,GAAX,CAAed,MAAf,CAAP,KAAkC,WAJtC,CADF,EAOE;AACA,UAAM,IAAI6C,eAAJ,iBAA6BhB,IAA7B,iCAAuDrB,MAAvD,qBAAsER,MAAtE,mJAAN;AACD,GA1DD;;;AA6DA,MAAMgM,SAAS,GAAGjL,UAAU,GAAG4C,kBAAH,GAAwBF,gBAApD;AAEA,MAAMI,QAAQ,GAAG,IAAImI,SAAJ,CACfnL,IADe,EAEfgL,eAFe,EAGfnL,UAHe,EAIfoD,UAJe,EAKfd,UALe,CAAjB,CA/DA;;AAwEAzC,EAAAA,KAAK,CAAC8E,MAAN,CAAad,GAAb,CAAiB1D,IAAjB,EAAuBgD,QAAvB,EAxEA;;;AA2EA,MAAIrD,MAAM,KAAKR,MAAf,EAAuB;AACrB,QAAIe,UAAJ,EACEL,UAAU,CAAC2C,mBAAX,GADF,KAGE3C,UAAU,CAAC0C,iBAAX;AACH,GALD,MAMK;AACH,QAAIrC,UAAJ,EAAgB;AACdL,MAAAA,UAAU,CAACyC,gBAAX;AACAW,MAAAA,UAAU,CAACX,gBAAX;AACD,KAHD,MAIK;AACHzC,MAAAA,UAAU,CAACwC,SAAX;AACAY,MAAAA,UAAU,CAACb,QAAX;AACD;AACF,GA1FD;;;AA6FAW,EAAAA,oBAAoB,CAClBrD,KADkB,EAElBQ,UAFkB,EAGlB8C,QAHkB,EAIlBrD,MAJkB,EAKlBR,MALkB,EAMlBU,UANkB,EAOlBoD,UAPkB,CAApB;AAUA,MAAI/C,UAAJ,EACER,KAAK,CAAC0L,eAAN,GADF,KAGE1L,KAAK,CAAC2L,aAAN,GA1GF;;AA6GAJ,EAAAA,SAAS,CAAC/I,GAAV,GAAgBlC,IAAhB;AAEAN,EAAAA,KAAK,CAACmF,IAAN,CAAW,WAAX,EAAwBoG,SAAxB;AAEA,SAAOjL,IAAP;AACD;AAED;;;;;;;;;;;;;;;;;;;;AAkBA,SAASsL,SAAT,CACE5L,KADF,EAEEsB,IAFF,EAGEgK,eAHF,EAIE9K,UAJF,EAKEF,IALF,EAMEL,MANF,EAOER,MAPF,EAQEgD,UARF,EASE;AAEA;AACA,MAAI,CAACjC,UAAD,IAAeR,KAAK,CAACE,IAAN,KAAe,YAAlC,EACE,MAAM,IAAIoC,eAAJ,iBAA6BhB,IAA7B,gHAAN;AAEF,MAAId,UAAU,IAAIR,KAAK,CAACE,IAAN,KAAe,UAAjC,EACE,MAAM,IAAIoC,eAAJ,iBAA6BhB,IAA7B,8GAAN;AAEF,MAAImB,UAAU,IAAI,CAAC5B,aAAa,CAAC4B,UAAD,CAAhC,EACE,MAAM,IAAIP,0BAAJ,iBAAwCZ,IAAxC,iEAAkGmB,UAAlG,QAAN,CAVF;;AAaAxC,EAAAA,MAAM,GAAG,KAAKA,MAAd;AACAR,EAAAA,MAAM,GAAG,KAAKA,MAAd;AACAgD,EAAAA,UAAU,GAAGA,UAAU,IAAI,EAA3B;AAEA,MAAI,CAACzC,KAAK,CAACmL,cAAP,IAAyBlL,MAAM,KAAKR,MAAxC,EACE,MAAM,IAAI6C,eAAJ,iBAA6BhB,IAA7B,+CAAqErB,MAArE,wGAAN;;AAEF,MAAIE,UAAU,GAAGH,KAAK,CAACI,MAAN,CAAaC,GAAb,CAAiBJ,MAAjB,CAAjB;AAAA,MACIsD,UAAU,GAAGvD,KAAK,CAACI,MAAN,CAAaC,GAAb,CAAiBZ,MAAjB,CADjB;AAAA,MAEI6D,QAFJ,CApBA;;;AAyBA,MAAIuI,mBAAmB,GAAG,IAA1B;;AAEA,MAAI,CAACP,eAAL,EAAsB;AACpBhI,IAAAA,QAAQ,GAAGtD,KAAK,CAAC8E,MAAN,CAAazE,GAAb,CAAiBC,IAAjB,CAAX;;AAEA,QAAIgD,QAAJ,EAAc;AAEZ;AACA;AACA,UACGA,QAAQ,CAACrD,MAAT,KAAoBA,MAApB,IAA8BqD,QAAQ,CAAC7D,MAAT,KAAoBA,MAAnD,IACCe,UAAU,KAAK8C,QAAQ,CAACrD,MAAT,KAAoBR,MAApB,IAA8B6D,QAAQ,CAAC7D,MAAT,KAAoBQ,MAAvD,CAFb,EAGE;AACA,cAAM,IAAIqC,eAAJ,iBAA6BhB,IAA7B,qEAA2FhB,IAA3F,4BAA+GL,MAA/G,2BAAoIR,MAApI,4BAA2J6D,QAAQ,CAACrD,MAApK,eAA+KqD,QAAQ,CAAC7D,MAAxL,QAAN;AACD;;AAEDoM,MAAAA,mBAAmB,GAAGvL,IAAtB;AACD;AACF;;AAED,MAAIwL,uBAAJ,CA7CA;;AAgDA,MACE,CAACD,mBAAD,IACA,CAAC7L,KAAK,CAACwD,KADP,IAEArD,UAFA,KAIEK,UAAU,GACR,OAAOL,UAAU,CAACK,UAAX,CAAsBf,MAAtB,CAAP,KAAyC,WADjC,GAER,OAAOU,UAAU,CAACI,GAAX,CAAed,MAAf,CAAP,KAAkC,WANtC,CADF,EASE;AACAqM,IAAAA,uBAAuB,GAAG/L,eAAe,CAACC,KAAD,EAAQC,MAAR,EAAgBR,MAAhB,EAAwBe,UAAU,GAAG,YAAH,GAAkB,UAApD,CAAzC;AACD,GA3DD;;;AA8DA,MAAIsL,uBAAJ,EAA6B;AAE3B;AACA,QAAI,CAACrJ,UAAL,EACE,OAAOoJ,mBAAP,CAJyB;;AAO3BrM,IAAAA,MAAM,CAACsM,uBAAuB,CAACrJ,UAAzB,EAAqCA,UAArC,CAAN;AACA,WAAOoJ,mBAAP;AACD,GAvED;;;AA0EA,MAAMN,SAAS,GAAG;AAChB/I,IAAAA,GAAG,EAAE,IADW;AAEhBhC,IAAAA,UAAU,EAAVA,UAFgB;AAGhBP,IAAAA,MAAM,EAANA,MAHgB;AAIhBR,IAAAA,MAAM,EAANA,MAJgB;AAKhBgD,IAAAA,UAAU,EAAVA;AALgB,GAAlB;AAQA,MAAI6I,eAAJ,EACEhL,IAAI,GAAGN,KAAK,CAACwL,iBAAN,CAAwBD,SAAxB,CAAP,CAnFF;;AAsFAjL,EAAAA,IAAI,GAAG,KAAKA,IAAZ,CAtFA;;AAyFA,MAAIN,KAAK,CAAC8E,MAAN,CAAa8D,GAAb,CAAiBtI,IAAjB,CAAJ,EACE,MAAM,IAAIgC,eAAJ,iBAA6BhB,IAA7B,qBAA2ChB,IAA3C,0CAAN;;AAEF,MAAI,CAACH,UAAL,EAAiB;AACfH,IAAAA,KAAK,CAAC+L,OAAN,CAAc9L,MAAd;AACAE,IAAAA,UAAU,GAAGH,KAAK,CAACI,MAAN,CAAaC,GAAb,CAAiBJ,MAAjB,CAAb;AAEA,QAAIA,MAAM,KAAKR,MAAf,EACE8D,UAAU,GAAGpD,UAAb;AACH;;AACD,MAAI,CAACoD,UAAL,EAAiB;AACfvD,IAAAA,KAAK,CAAC+L,OAAN,CAActM,MAAd;AACA8D,IAAAA,UAAU,GAAGvD,KAAK,CAACI,MAAN,CAAaC,GAAb,CAAiBZ,MAAjB,CAAb;AACD,GAtGD;;;AAyGA,MAAMgM,SAAS,GAAGjL,UAAU,GAAG4C,kBAAH,GAAwBF,gBAApD;AAEAI,EAAAA,QAAQ,GAAG,IAAImI,SAAJ,CACTnL,IADS,EAETgL,eAFS,EAGTnL,UAHS,EAIToD,UAJS,EAKTd,UALS,CAAX,CA3GA;;AAoHAzC,EAAAA,KAAK,CAAC8E,MAAN,CAAad,GAAb,CAAiB1D,IAAjB,EAAuBgD,QAAvB,EApHA;;;AAuHA,MAAIrD,MAAM,KAAKR,MAAf,EAAuB;AACrB,QAAIe,UAAJ,EACEL,UAAU,CAAC2C,mBAAX,GADF,KAGE3C,UAAU,CAAC0C,iBAAX;AACH,GALD,MAMK;AACH,QAAIrC,UAAJ,EAAgB;AACdL,MAAAA,UAAU,CAACyC,gBAAX;AACAW,MAAAA,UAAU,CAACX,gBAAX;AACD,KAHD,MAIK;AACHzC,MAAAA,UAAU,CAACwC,SAAX;AACAY,MAAAA,UAAU,CAACb,QAAX;AACD;AACF,GAtID;;;AAyIAW,EAAAA,oBAAoB,CAClBrD,KADkB,EAElBQ,UAFkB,EAGlB8C,QAHkB,EAIlBrD,MAJkB,EAKlBR,MALkB,EAMlBU,UANkB,EAOlBoD,UAPkB,CAApB;AAUA,MAAI/C,UAAJ,EACER,KAAK,CAAC0L,eAAN,GADF,KAGE1L,KAAK,CAAC2L,aAAN,GAtJF;;AAyJAJ,EAAAA,SAAS,CAAC/I,GAAV,GAAgBlC,IAAhB;AAEAN,EAAAA,KAAK,CAACmF,IAAN,CAAW,WAAX,EAAwBoG,SAAxB;AAEA,SAAOjL,IAAP;AACD;AAED;;;;;;;;;;;;;;IAYqB0F;;;AACnB,iBAAYgG,OAAZ,EAAqB;AAAA;;AACnB,6CADmB;;AAInBA,IAAAA,OAAO,GAAGxM,MAAM,CAAC,EAAD,EAAK0L,QAAL,EAAec,OAAf,CAAhB,CAJmB;;AAOnB,QAAIA,OAAO,CAACZ,gBAAR,IAA4B,OAAOY,OAAO,CAACZ,gBAAf,KAAoC,UAApE,EACE,MAAM,IAAIlJ,0BAAJ,gGAAsH8J,OAAO,CAACZ,gBAA9H,SAAN;AAEF,QAAI,OAAOY,OAAO,CAACxI,KAAf,KAAyB,SAA7B,EACE,MAAM,IAAItB,0BAAJ,oFAA0G8J,OAAO,CAACxI,KAAlH,SAAN;AAEF,QAAI,CAACqH,KAAK,CAACjC,GAAN,CAAUoD,OAAO,CAAC9L,IAAlB,CAAL,EACE,MAAM,IAAIgC,0BAAJ,0HAA0I8J,OAAO,CAAC9L,IAAlJ,SAAN;AAEF,QAAI,OAAO8L,OAAO,CAACb,cAAf,KAAkC,SAAtC,EACE,MAAM,IAAIjJ,0BAAJ,6FAAmH8J,OAAO,CAACb,cAA3H,SAAN,CAjBiB;AAqBnB;;AACA,QAAMc,aAAa,GAAGD,OAAO,CAAC9L,IAAR,KAAiB,OAAjB,GACpBqC,aADoB,GAEnByJ,OAAO,CAAC9L,IAAR,KAAiB,UAAlB,GACE6C,gBADF,GAEEE,kBAJJ;AAMA5B,IAAAA,eAAe,gCAAO,eAAP,EAAwB4K,aAAxB,CAAf,CA5BmB;;AA+BnB5K,IAAAA,eAAe,gCAAO,aAAP,EAAsB,EAAtB,CAAf;AACAA,IAAAA,eAAe,gCAAO,QAAP,EAAiB,IAAI6K,GAAJ,EAAjB,CAAf;AACA7K,IAAAA,eAAe,gCAAO,QAAP,EAAiB,IAAI6K,GAAJ,EAAjB,CAAf;AACA7K,IAAAA,eAAe,gCAAO,eAAP,EAAwB,CAAxB,CAAf;AACAA,IAAAA,eAAe,gCAAO,iBAAP,EAA0B,CAA1B,CAAf;AACAA,IAAAA,eAAe,gCAAO,mBAAP,EAA4B2K,OAAO,CAACZ,gBAAR,IAA4BvJ,aAAa,EAArE,CAAf,CApCmB;;AAuCnBR,IAAAA,eAAe,gCAAO,UAAP,EAAmB2K,OAAnB,CAAf,CAvCmB;;AA0CnBlB,IAAAA,aAAa,CAAC1G,OAAd,CAAsB,UAAA+H,IAAI;AAAA,aAAI9K,eAAe,gCAAO8K,IAAP,EAAa,MAAKA,IAAL,CAAb,CAAnB;AAAA,KAA1B,EA1CmB;;AA6CnBxK,IAAAA,gBAAgB,gCAAO,OAAP,EAAgB;AAAA,aAAM,MAAKvB,MAAL,CAAY6D,IAAlB;AAAA,KAAhB,CAAhB;AACAtC,IAAAA,gBAAgB,gCAAO,MAAP,EAAe;AAAA,aAAM,MAAKmD,MAAL,CAAYb,IAAlB;AAAA,KAAf,CAAhB;AACAtC,IAAAA,gBAAgB,gCAAO,cAAP,EAAuB;AAAA,aAAM,MAAKgK,aAAX;AAAA,KAAvB,CAAhB;AACAhK,IAAAA,gBAAgB,gCAAO,gBAAP,EAAyB;AAAA,aAAM,MAAK+J,eAAX;AAAA,KAAzB,CAAhB;AACA/J,IAAAA,gBAAgB,gCAAO,OAAP,EAAgB,MAAKyK,QAAL,CAAc5I,KAA9B,CAAhB;AACA7B,IAAAA,gBAAgB,gCAAO,MAAP,EAAe,MAAKyK,QAAL,CAAclM,IAA7B,CAAhB;AACAyB,IAAAA,gBAAgB,gCAAO,gBAAP,EAAyB,MAAKyK,QAAL,CAAcjB,cAAvC,CAAhB;AAnDmB;AAoDpB;AAED;;;;;AAKA;;;;;;;;;;SAMAkB,UAAA,iBAAQ/H,IAAR,EAAc;AACZ,WAAO,KAAKlE,MAAL,CAAYwI,GAAZ,CAAgB,KAAKtE,IAArB,CAAP;AACD;AAED;;;;;;;;;;;;;;;;SAcAgI,kBAAA,yBAAgBrM,MAAhB,EAAwBR,MAAxB,EAAgC;AAE9B;AACA,QAAI,KAAKS,IAAL,KAAc,YAAlB,EACE,OAAO,KAAP;;AAEF,QAAIR,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;AAC1B,UAAMS,IAAI,GAAG,KAAKL,MAAlB;;AAEA,UAAMqD,QAAQ,GAAG,KAAKwB,MAAL,CAAYzE,GAAZ,CAAgBC,IAAhB,CAAjB;;AAEA,aACE,CAAC,CAACgD,QAAF,IACAA,QAAQ,YAAYJ,gBAFtB;AAID,KATD,MAUK,IAAIxD,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;AAE/BI,MAAAA,MAAM,GAAG,KAAKA,MAAd;AACAR,MAAAA,MAAM,GAAG,KAAKA,MAAd,CAH+B;;AAM/B,UAAMyI,QAAQ,GAAG,KAAK9H,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAjB;;AAEA,UAAI,CAACiI,QAAL,EACE,OAAO,KAAP,CAT6B;;AAY/B,UAAM1D,KAAK,GAAG0D,QAAQ,CAAC3H,GAAT,CAAad,MAAb,CAAd;AAEA,UAAI,CAAC+E,KAAL,EACE,OAAO,KAAP;AAEF,aAAO,KAAKhB,KAAL,GAAa,CAAC,CAACgB,KAAK,CAACP,IAArB,GAA4B,IAAnC;AACD;;AAED,UAAM,IAAI/B,0BAAJ,iDAAwExC,SAAS,CAACG,MAAlF,0HAAN;AACD;AAED;;;;;;;;;;;;;;;;SAcA0M,oBAAA,2BAAkBtM,MAAlB,EAA0BR,MAA1B,EAAkC;AAEhC;AACA,QAAI,KAAKS,IAAL,KAAc,UAAlB,EACE,OAAO,KAAP;;AAEF,QAAIR,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;AAC1B,UAAMS,IAAI,GAAG,KAAKL,MAAlB;;AAEA,UAAMqD,QAAQ,GAAG,KAAKwB,MAAL,CAAYzE,GAAZ,CAAgBC,IAAhB,CAAjB;;AAEA,aACE,CAAC,CAACgD,QAAF,IACAA,QAAQ,YAAYF,kBAFtB;AAID,KATD,MAUK,IAAI1D,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;AAE/BI,MAAAA,MAAM,GAAG,KAAKA,MAAd;AACAR,MAAAA,MAAM,GAAG,KAAKA,MAAd,CAH+B;;AAM/B,UAAMyI,QAAQ,GAAG,KAAK9H,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAjB;;AAEA,UAAI,CAACiI,QAAL,EACE,OAAO,KAAP,CAT6B;;AAY/B,UAAM1D,KAAK,GAAG0D,QAAQ,CAAC1H,UAAT,CAAoBf,MAApB,CAAd;AAEA,UAAI,CAAC+E,KAAL,EACE,OAAO,KAAP;AAEF,aAAO,KAAKhB,KAAL,GAAa,CAAC,CAACgB,KAAK,CAACP,IAArB,GAA4B,IAAnC;AACD;;AAED,UAAM,IAAI/B,0BAAJ,iDAAwExC,SAAS,CAACG,MAAlF,0HAAN;AACD;AAED;;;;;;;;;;;;;;;;SAcA2M,UAAA,iBAAQvM,MAAR,EAAgBR,MAAhB,EAAwB;AAEtB,QAAIC,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;AAC1B,UAAMS,IAAI,GAAG,KAAKL,MAAlB;AAEA,aAAO,KAAK6E,MAAL,CAAY8D,GAAZ,CAAgBtI,IAAhB,CAAP;AACD,KAJD,MAKK,IAAIZ,SAAS,CAACG,MAAV,KAAqB,CAAzB,EAA4B;AAE/BI,MAAAA,MAAM,GAAG,KAAKA,MAAd;AACAR,MAAAA,MAAM,GAAG,KAAKA,MAAd,CAH+B;;AAM/B,UAAMyI,QAAQ,GAAG,KAAK9H,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAjB;;AAEA,UAAI,CAACiI,QAAL,EACE,OAAO,KAAP,CAT6B;;AAY/B,UAAI1D,KAAK,GAAG,OAAO0D,QAAQ,CAAC3H,GAAhB,KAAwB,WAAxB,IAAuC2H,QAAQ,CAAC3H,GAAT,CAAad,MAAb,CAAnD;AAEA,UAAI,CAAC+E,KAAL,EACEA,KAAK,GAAG,OAAO0D,QAAQ,CAAC1H,UAAhB,KAA+B,WAA/B,IAA8C0H,QAAQ,CAAC1H,UAAT,CAAoBf,MAApB,CAAtD;AAEF,UAAI,CAAC+E,KAAL,EACE,OAAO,KAAP;AAEF,aAAO,KAAKhB,KAAL,GAAa,CAAC,CAACgB,KAAK,CAACP,IAArB,GAA4B,IAAnC;AACD;;AAED,UAAM,IAAI/B,0BAAJ,yCAAgExC,SAAS,CAACG,MAA1E,0HAAN;AACD;AAED;;;;;;;;;;;;;SAWA4M,eAAA,sBAAaxM,MAAb,EAAqBR,MAArB,EAA6B;AAE3B,QAAI,KAAKS,IAAL,KAAc,YAAlB,EACE;AAEFD,IAAAA,MAAM,GAAG,KAAKA,MAAd;AACAR,IAAAA,MAAM,GAAG,KAAKA,MAAd;AAEA,QAAI,KAAK+D,KAAT,EACE,MAAM,IAAIlB,eAAJ,CAAoB,0JAApB,CAAN;;AAEF,QAAMnC,UAAU,GAAG,KAAKC,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAnB;;AAEA,QAAI,CAACE,UAAL,EACE,MAAM,IAAIkC,kBAAJ,oDAAkEpC,MAAlE,kCAAN;AAEF,QAAI,CAAC,KAAKG,MAAL,CAAYwI,GAAZ,CAAgBnJ,MAAhB,CAAL,EACE,MAAM,IAAI4C,kBAAJ,oDAAkE5C,MAAlE,kCAAN;AAEF,QAAM6D,QAAQ,GAAInD,UAAU,CAACI,GAAX,IAAkBJ,UAAU,CAACI,GAAX,CAAed,MAAf,CAAnB,IAA8CiN,SAA/D;AAEA,QAAIpJ,QAAJ,EACE,OAAOA,QAAQ,CAACd,GAAhB;AACH;AAED;;;;;;;;;;;;;SAWAmK,iBAAA,wBAAe1M,MAAf,EAAuBR,MAAvB,EAA+B;AAE7B,QAAI,KAAKS,IAAL,KAAc,UAAlB,EACE;AAEFD,IAAAA,MAAM,GAAG,KAAKA,MAAd;AACAR,IAAAA,MAAM,GAAG,KAAKA,MAAd;AAEA,QAAI,KAAK+D,KAAT,EACE,MAAM,IAAIlB,eAAJ,CAAoB,8JAApB,CAAN;;AAEF,QAAMnC,UAAU,GAAG,KAAKC,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAnB;;AAEA,QAAI,CAACE,UAAL,EACE,MAAM,IAAIkC,kBAAJ,sDAAoEpC,MAApE,kCAAN;AAEF,QAAI,CAAC,KAAKG,MAAL,CAAYwI,GAAZ,CAAgBnJ,MAAhB,CAAL,EACE,MAAM,IAAI4C,kBAAJ,sDAAoE5C,MAApE,kCAAN;AAEF,QAAM6D,QAAQ,GAAInD,UAAU,CAACK,UAAX,IAAyBL,UAAU,CAACK,UAAX,CAAsBf,MAAtB,CAA1B,IAA4DiN,SAA7E;AAEA,QAAIpJ,QAAJ,EACE,OAAOA,QAAQ,CAACd,GAAhB;AACH;AAED;;;;;;;;;;;;;SAWAlC,OAAA,cAAKL,MAAL,EAAaR,MAAb,EAAqB;AACnB,QAAI,KAAK+D,KAAT,EACE,MAAM,IAAIlB,eAAJ,CAAoB,0IAApB,CAAN;AAEFrC,IAAAA,MAAM,GAAG,KAAKA,MAAd;AACAR,IAAAA,MAAM,GAAG,KAAKA,MAAd;;AAEA,QAAMU,UAAU,GAAG,KAAKC,MAAL,CAAYC,GAAZ,CAAgBJ,MAAhB,CAAnB;;AAEA,QAAI,CAACE,UAAL,EACE,MAAM,IAAIkC,kBAAJ,4CAA0DpC,MAA1D,kCAAN;AAEF,QAAI,CAAC,KAAKG,MAAL,CAAYwI,GAAZ,CAAgBnJ,MAAhB,CAAL,EACE,MAAM,IAAI4C,kBAAJ,4CAA0D5C,MAA1D,kCAAN;AAEF,QAAM6D,QAAQ,GACXnD,UAAU,CAACI,GAAX,IAAkBJ,UAAU,CAACI,GAAX,CAAed,MAAf,CAAnB,IACCU,UAAU,CAACK,UAAX,IAAyBL,UAAU,CAACK,UAAX,CAAsBf,MAAtB,CAD1B,IAEAiN,SAHF;AAMA,QAAIpJ,QAAJ,EACE,OAAOA,QAAQ,CAACd,GAAhB;AACH;AAED;;;;;;;;;;;;SAUAE,WAAA,kBAAS4B,IAAT,EAAiC;AAAA,QAAlBsI,SAAkB,uEAAN,IAAM;AAC/B,QAAI,OAAOA,SAAP,KAAqB,SAAzB,EACE,MAAM,IAAI1K,0BAAJ,yDAA+E0K,SAA/E,sEAAN;AAEFtI,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAM4D,QAAQ,GAAG,KAAK9H,MAAL,CAAYC,GAAZ,CAAgBiE,IAAhB,CAAjB;;AAEA,QAAI,CAAC4D,QAAL,EACE,MAAM,IAAI7F,kBAAJ,gDAA8DiC,IAA9D,2BAAN;AAEF,QAAI,KAAKpE,IAAL,KAAc,YAAlB,EACE,OAAO,CAAP;AAEF,QAAM2M,KAAK,GAAGD,SAAS,GAAG1E,QAAQ,CAACrF,iBAAZ,GAAgC,CAAvD;AAEA,WAAOqF,QAAQ,CAACxF,QAAT,GAAoBmK,KAA3B;AACD;AAED;;;;;;;;;;;;SAUAlK,YAAA,mBAAU2B,IAAV,EAAkC;AAAA,QAAlBsI,SAAkB,uEAAN,IAAM;AAChC,QAAI,OAAOA,SAAP,KAAqB,SAAzB,EACE,MAAM,IAAI1K,0BAAJ,0DAAgF0K,SAAhF,sEAAN;AAEFtI,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAM4D,QAAQ,GAAG,KAAK9H,MAAL,CAAYC,GAAZ,CAAgBiE,IAAhB,CAAjB;;AAEA,QAAI,CAAC4D,QAAL,EACE,MAAM,IAAI7F,kBAAJ,iDAA+DiC,IAA/D,2BAAN;AAEF,QAAI,KAAKpE,IAAL,KAAc,YAAlB,EACE,OAAO,CAAP;AAEF,QAAM2M,KAAK,GAAGD,SAAS,GAAG1E,QAAQ,CAACrF,iBAAZ,GAAgC,CAAvD;AAEA,WAAOqF,QAAQ,CAACvF,SAAT,GAAqBkK,KAA5B;AACD;AAED;;;;;;;;;;;;SAUAC,iBAAA,wBAAexI,IAAf,EAAuC;AAAA,QAAlBsI,SAAkB,uEAAN,IAAM;AACrC,QAAI,OAAOA,SAAP,KAAqB,SAAzB,EACE,MAAM,IAAI1K,0BAAJ,+DAAqF0K,SAArF,sEAAN;AAEFtI,IAAAA,IAAI,GAAG,KAAKA,IAAZ;AAEA,QAAI,CAAC,KAAK+H,OAAL,CAAa/H,IAAb,CAAL,EACE,MAAM,IAAIjC,kBAAJ,sDAAoEiC,IAApE,2BAAN;AAEF,QAAI,KAAKpE,IAAL,KAAc,YAAlB,EACE,OAAO,CAAP;AAEF,WAAO,KAAKwC,QAAL,CAAc4B,IAAd,EAAoBsI,SAApB,IAAiC,KAAKjK,SAAL,CAAe2B,IAAf,EAAqBsI,SAArB,CAAxC;AACD;AAED;;;;;;;;;;;;SAUAhK,mBAAA,0BAAiB0B,IAAjB,EAAyC;AAAA,QAAlBsI,SAAkB,uEAAN,IAAM;AACvC,QAAI,OAAOA,SAAP,KAAqB,SAAzB,EACE,MAAM,IAAI1K,0BAAJ,iEAAuF0K,SAAvF,sEAAN;AAEFtI,IAAAA,IAAI,GAAG,KAAKA,IAAZ;AAEA,QAAI,CAAC,KAAK+H,OAAL,CAAa/H,IAAb,CAAL,EACE,MAAM,IAAIjC,kBAAJ,wDAAsEiC,IAAtE,2BAAN;AAEF,QAAI,KAAKpE,IAAL,KAAc,UAAlB,EACE,OAAO,CAAP;;AAEF,QAAM8B,IAAI,GAAG,KAAK5B,MAAL,CAAYC,GAAZ,CAAgBiE,IAAhB,CAAb;AAAA,QACMuI,KAAK,GAAGD,SAAS,GAAI5K,IAAI,CAACc,mBAAL,GAA2B,CAA/B,GAAoC,CAD3D;;AAGA,WAAOd,IAAI,CAACY,gBAAL,GAAwBiK,KAA/B;AACD;AAED;;;;;;;;;;;;SAUAE,SAAA,gBAAOzI,IAAP,EAA+B;AAAA,QAAlBsI,SAAkB,uEAAN,IAAM;AAC7B,QAAI,OAAOA,SAAP,KAAqB,SAAzB,EACE,MAAM,IAAI1K,0BAAJ,uDAA6E0K,SAA7E,sEAAN;AAEFtI,IAAAA,IAAI,GAAG,KAAKA,IAAZ;AAEA,QAAI,CAAC,KAAK+H,OAAL,CAAa/H,IAAb,CAAL,EACE,MAAM,IAAIjC,kBAAJ,8CAA4DiC,IAA5D,2BAAN;AAEF,QAAIyI,MAAM,GAAG,CAAb;AAEA,QAAI,KAAK7M,IAAL,KAAc,YAAlB,EACE6M,MAAM,IAAI,KAAKD,cAAL,CAAoBxI,IAApB,EAA0BsI,SAA1B,CAAV;AAEF,QAAI,KAAK1M,IAAL,KAAc,UAAlB,EACE6M,MAAM,IAAI,KAAKnK,gBAAL,CAAsB0B,IAAtB,EAA4BsI,SAA5B,CAAV;AAEF,WAAOG,MAAP;AACD;AAED;;;;;;;;;;SAQA9M,SAAA,gBAAOK,IAAP,EAAa;AACXA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAM0B,IAAI,GAAG,KAAK8C,MAAL,CAAYzE,GAAZ,CAAgBC,IAAhB,CAAb;;AAEA,QAAI,CAAC0B,IAAL,EACE,MAAM,IAAIK,kBAAJ,8CAA4D/B,IAA5D,2BAAN;AAEF,WAAO0B,IAAI,CAAC/B,MAAL,CAAYuC,GAAnB;AACD;AAED;;;;;;;;;;SAQA/C,SAAA,gBAAOa,IAAP,EAAa;AACXA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAM0B,IAAI,GAAG,KAAK8C,MAAL,CAAYzE,GAAZ,CAAgBC,IAAhB,CAAb;;AAEA,QAAI,CAAC0B,IAAL,EACE,MAAM,IAAIK,kBAAJ,8CAA4D/B,IAA5D,2BAAN;AAEF,WAAO0B,IAAI,CAACvC,MAAL,CAAY+C,GAAnB;AACD;AAED;;;;;;;;;;SAQAwK,cAAA,qBAAY1M,IAAZ,EAAkB;AAChBA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMgD,QAAQ,GAAG,KAAKwB,MAAL,CAAYzE,GAAZ,CAAgBC,IAAhB,CAAjB;;AAEA,QAAI,CAACgD,QAAL,EACE,MAAM,IAAIjB,kBAAJ,mDAAiE/B,IAAjE,2BAAN;AAEF,WAAO,CACLgD,QAAQ,CAACrD,MAAT,CAAgBuC,GADX,EAELc,QAAQ,CAAC7D,MAAT,CAAgB+C,GAFX,CAAP;AAID;AAED;;;;;;;;;;;SASAyK,WAAA,kBAAS3I,IAAT,EAAehE,IAAf,EAAqB;AACnBgE,IAAAA,IAAI,GAAG,KAAKA,IAAZ;AACAhE,IAAAA,IAAI,GAAG,KAAKA,IAAZ;AAEA,QAAI,CAAC,KAAKF,MAAL,CAAYwI,GAAZ,CAAgBtE,IAAhB,CAAL,EACE,MAAM,IAAIjC,kBAAJ,gDAA8DiC,IAA9D,2BAAN;;AAEF,QAAMtC,IAAI,GAAG,KAAK8C,MAAL,CAAYzE,GAAZ,CAAgBC,IAAhB,CAAb;;AAEA,QAAI,CAAC0B,IAAL,EACE,MAAM,IAAIK,kBAAJ,gDAA8D/B,IAA9D,2BAAN;AAViB,QAYJH,UAZI,GAY8B6B,IAZ9B,CAYZ/B,MAZY;AAAA,QAYgBsD,UAZhB,GAY8BvB,IAZ9B,CAYQvC,MAZR;AAcnB,QAAMQ,MAAM,GAAGE,UAAU,CAACqC,GAA1B;AAAA,QACM/C,MAAM,GAAG8D,UAAU,CAACf,GAD1B;AAGA,QAAI8B,IAAI,KAAKrE,MAAT,IAAmBqE,IAAI,KAAK7E,MAAhC,EACE,MAAM,IAAI4C,kBAAJ,iCAA+CiC,IAA/C,8CAAqFhE,IAArF,sBAAoGL,MAApG,eAA+GR,MAA/G,QAAN;AAEF,WAAO6E,IAAI,KAAKrE,MAAT,GAAkBR,MAAlB,GAA2BQ,MAAlC;AACD;AAED;;;;;;;;;;SAQAO,aAAA,oBAAWF,IAAX,EAAiB;AACfA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAM0B,IAAI,GAAG,KAAK8C,MAAL,CAAYzE,GAAZ,CAAgBC,IAAhB,CAAb;;AAEA,QAAI,CAAC0B,IAAL,EACE,MAAM,IAAIK,kBAAJ,kDAAgE/B,IAAhE,2BAAN;AAEF,WAAO0B,IAAI,YAAYoB,kBAAvB;AACD;AAED;;;;;;;;;;SAQA8J,WAAA,kBAAS5M,IAAT,EAAe;AACbA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAM0B,IAAI,GAAG,KAAK8C,MAAL,CAAYzE,GAAZ,CAAgBC,IAAhB,CAAb;;AAEA,QAAI,CAAC0B,IAAL,EACE,MAAM,IAAIK,kBAAJ,gDAA8D/B,IAA9D,2BAAN;AAEF,WAAO0B,IAAI,YAAYkB,gBAAvB;AACD;AAED;;;;;;;;;;SAQAiK,WAAA,kBAAS7M,IAAT,EAAe;AACbA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAM0B,IAAI,GAAG,KAAK8C,MAAL,CAAYzE,GAAZ,CAAgBC,IAAhB,CAAb;;AAEA,QAAI,CAAC0B,IAAL,EACE,MAAM,IAAIK,kBAAJ,gDAA8D/B,IAA9D,2BAAN;AAEF,WAAO0B,IAAI,CAAC/B,MAAL,KAAgB+B,IAAI,CAACvC,MAA5B;AACD;AAED;;;;;AAKA;;;;;;;;;;;;SAUAsM,UAAA,iBAAQzH,IAAR,EAAc7B,UAAd,EAA0B;AACxB,QAAIA,UAAU,IAAI,CAAC5B,aAAa,CAAC4B,UAAD,CAAhC,EACE,MAAM,IAAIP,0BAAJ,4EAAkGO,UAAlG,QAAN,CAFsB;;AAKxB6B,IAAAA,IAAI,GAAG,KAAKA,IAAZ;AACA7B,IAAAA,UAAU,GAAGA,UAAU,IAAI,EAA3B;AAEA,QAAI,KAAKrC,MAAL,CAAYwI,GAAZ,CAAgBtE,IAAhB,CAAJ,EACE,MAAM,IAAIhC,eAAJ,gCAA2CgC,IAA3C,yCAAN;AAEF,QAAMtC,IAAI,GAAG,IAAI,KAAKiK,aAAT,CAAuB3H,IAAvB,EAA6B7B,UAA7B,CAAb,CAXwB;;AAcxB,SAAKrC,MAAL,CAAY4D,GAAZ,CAAgBM,IAAhB,EAAsBtC,IAAtB,EAdwB;;;AAiBxB,SAAKmD,IAAL,CAAU,WAAV,EAAuB;AACrB3C,MAAAA,GAAG,EAAE8B,IADgB;AAErB7B,MAAAA,UAAU,EAAVA;AAFqB,KAAvB;AAKA,WAAO6B,IAAP;AACD;AAED;;;;;;;;;SAOA8I,YAAA,mBAAU9I,IAAV,EAAgB7B,UAAhB,EAA4B;AAC1B,QAAIA,UAAU,IAAI,CAAC5B,aAAa,CAAC4B,UAAD,CAAhC,EACE,MAAM,IAAIP,0BAAJ,8EAAoGO,UAApG,QAAN,CAFwB;;AAK1B6B,IAAAA,IAAI,GAAG,KAAKA,IAAZ;AACA7B,IAAAA,UAAU,GAAGA,UAAU,IAAI,EAA3B,CAN0B;;AAS1B,QAAIT,IAAI,GAAG,KAAK5B,MAAL,CAAYC,GAAZ,CAAgBiE,IAAhB,CAAX;;AAEA,QAAItC,IAAJ,EAAU;AACR,UAAIS,UAAJ,EACEjD,MAAM,CAACwC,IAAI,CAACS,UAAN,EAAkBA,UAAlB,CAAN;AACF,aAAO6B,IAAP;AACD;;AAEDtC,IAAAA,IAAI,GAAG,IAAI,KAAKiK,aAAT,CAAuB3H,IAAvB,EAA6B7B,UAA7B,CAAP,CAjB0B;;AAoB1B,SAAKrC,MAAL,CAAY4D,GAAZ,CAAgBM,IAAhB,EAAsBtC,IAAtB,EApB0B;;;AAuB1B,SAAKmD,IAAL,CAAU,WAAV,EAAuB;AACrB3C,MAAAA,GAAG,EAAE8B,IADgB;AAErB7B,MAAAA,UAAU,EAAVA;AAFqB,KAAvB;AAKA,WAAO6B,IAAP;AACD;AAED;;;;;;;;;;SAQA1D,WAAA,kBAAS0D,IAAT,EAAe;AACbA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;AAEA,QAAI,CAAC,KAAK+H,OAAL,CAAa/H,IAAb,CAAL,EACE,MAAM,IAAIjC,kBAAJ,gDAA8DiC,IAA9D,2BAAN,CAJW;;AAOb,QAAME,KAAK,GAAG,KAAKA,KAAL,CAAWF,IAAX,CAAd,CAPa;;AAUb,SAAK,IAAI3E,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG4E,KAAK,CAAC3E,MAA1B,EAAkCF,CAAC,GAAGC,CAAtC,EAAyCD,CAAC,EAA1C;AACE,WAAK0N,QAAL,CAAc7I,KAAK,CAAC7E,CAAD,CAAnB;AADF;;AAGA,QAAMqC,IAAI,GAAG,KAAK5B,MAAL,CAAYC,GAAZ,CAAgBiE,IAAhB,CAAb,CAba;;;AAgBb,SAAKlE,MAAL,WAAmBkE,IAAnB,EAhBa;;;AAmBb,SAAKa,IAAL,CAAU,aAAV,EAAyB;AACvB3C,MAAAA,GAAG,EAAE8B,IADkB;AAEvB7B,MAAAA,UAAU,EAAET,IAAI,CAACS;AAFM,KAAzB;AAID;AAED;;;;;;;;;;;;;;;;SAcA4K,WAAA,kBAAS/M,IAAT,EAAe;AACb,QAAIgD,QAAJ;;AAEA,QAAI5D,SAAS,CAACG,MAAV,GAAmB,CAAvB,EAA0B;AACxB,UAAMI,MAAM,GAAG,KAAKP,SAAS,CAAC,CAAD,CAA7B;AAAA,UACMD,MAAM,GAAG,KAAKC,SAAS,CAAC,CAAD,CAD7B;AAGA4D,MAAAA,QAAQ,GAAGvD,eAAe,CAAC,IAAD,EAAOE,MAAP,EAAeR,MAAf,EAAuB,KAAKS,IAA5B,CAA1B;AAEA,UAAI,CAACoD,QAAL,EACE,MAAM,IAAIjB,kBAAJ,gDAA8DpC,MAA9D,qBAA6ER,MAA7E,2BAAN;AACH,KARD,MASK;AACHa,MAAAA,IAAI,GAAG,KAAKA,IAAZ;AAEAgD,MAAAA,QAAQ,GAAG,KAAKwB,MAAL,CAAYzE,GAAZ,CAAgBC,IAAhB,CAAX;AAEA,UAAI,CAACgD,QAAL,EACE,MAAM,IAAIjB,kBAAJ,gDAA8D/B,IAA9D,2BAAN;AACH,KAnBY;;;AAsBb,SAAKwE,MAAL,WAAmBxB,QAAQ,CAACd,GAA5B,EAtBa;;;AAAA,oBA6BTc,QA7BS;AAAA,QA0BHnD,UA1BG,aA0BXF,MA1BW;AAAA,QA2BHsD,UA3BG,aA2BX9D,MA3BW;AAAA,QA4BXgD,UA5BW,aA4BXA,UA5BW;AA+Bb,QAAMjC,UAAU,GAAG8C,QAAQ,YAAYF,kBAAvC;;AAEA,QAAIjD,UAAU,KAAKoD,UAAnB,EAA+B;AAC7BpD,MAAAA,UAAU,CAACyM,SAAX;AACD,KAFD,MAGK;AACH,UAAIpM,UAAJ,EAAgB;AACdL,QAAAA,UAAU,CAACyC,gBAAX;AACAW,QAAAA,UAAU,CAACX,gBAAX;AACD,OAHD,MAIK;AACHzC,QAAAA,UAAU,CAACwC,SAAX;AACAY,QAAAA,UAAU,CAACb,QAAX;AACD;AACF,KA7CY;;;AAgDboB,IAAAA,2BAA2B,CAAC,IAAD,EAAOtD,UAAP,EAAmB8C,QAAnB,CAA3B;AAEA,QAAI9C,UAAJ,EACE,KAAKkL,eAAL,GADF,KAGE,KAAKC,aAAL,GArDW;;AAwDb,SAAKxG,IAAL,CAAU,aAAV,EAAyB;AACvB3C,MAAAA,GAAG,EAAElC,IADkB;AAEvBmC,MAAAA,UAAU,EAAVA,UAFuB;AAGvBxC,MAAAA,MAAM,EAAEE,UAAU,CAACqC,GAHI;AAIvB/C,MAAAA,MAAM,EAAE8D,UAAU,CAACf,GAJI;AAKvBhC,MAAAA,UAAU,EAAVA;AALuB,KAAzB;AAQA,WAAO,IAAP;AACD;AAED;;;;;;;SAKA8M,QAAA,iBAAQ;AAEN;AACA,SAAKxI,MAAL,CAAYwI,KAAZ,GAHM;;;AAMN,SAAKlN,MAAL,CAAYkN,KAAZ,GANM;;;AASN,SAAKnI,IAAL,CAAU,SAAV;AACD;AAED;;;;;;;SAKAoI,aAAA,sBAAa;AAEX;AACA,SAAKzI,MAAL,CAAYwI,KAAZ,GAHW;;;AAMX,SAAKE,UAAL,GANW;;AASX,SAAKrI,IAAL,CAAU,cAAV;AACD;AAED;;;;;AAKA;;;;;;;;SAMAsI,eAAA,sBAAanM,IAAb,EAAmB;AACjB,WAAO,KAAKoM,WAAL,CAAiBpM,IAAjB,CAAP;AACD;AAED;;;;;;;SAKAqM,gBAAA,yBAAgB;AACd,WAAO,KAAKD,WAAZ;AACD;AAED;;;;;;;;SAMAE,eAAA,sBAAatM,IAAb,EAAmB;AACjB,WAAO,KAAKoM,WAAL,CAAiBzI,cAAjB,CAAgC3D,IAAhC,CAAP;AACD;AAED;;;;;;;;;SAOAuM,eAAA,sBAAavM,IAAb,EAAmBZ,KAAnB,EAA0B;AACxB,SAAKgN,WAAL,CAAiBpM,IAAjB,IAAyBZ,KAAzB,CADwB;;AAIxB,SAAKyE,IAAL,CAAU,mBAAV,EAA+B;AAC7BjF,MAAAA,IAAI,EAAE,KADuB;AAE7BkF,MAAAA,IAAI,EAAE;AACJ9D,QAAAA,IAAI,EAAJA,IADI;AAEJZ,QAAAA,KAAK,EAALA;AAFI;AAFuB,KAA/B;AAQA,WAAO,IAAP;AACD;AAED;;;;;;;;;SAOAoN,kBAAA,yBAAgBxM,IAAhB,EAAsBgE,OAAtB,EAA+B;AAC7B,QAAI,OAAOA,OAAP,KAAmB,UAAvB,EACE,MAAM,IAAIpD,0BAAJ,CAA+B,sDAA/B,CAAN;AAEF,SAAKwL,WAAL,CAAiBpM,IAAjB,IAAyBgE,OAAO,CAAC,KAAKoI,WAAL,CAAiBpM,IAAjB,CAAD,CAAhC,CAJ6B;;AAO7B,SAAK6D,IAAL,CAAU,mBAAV,EAA+B;AAC7BjF,MAAAA,IAAI,EAAE,KADuB;AAE7BkF,MAAAA,IAAI,EAAE;AACJ9D,QAAAA,IAAI,EAAJA,IADI;AAEJZ,QAAAA,KAAK,EAAE,KAAKgN,WAAL,CAAiBpM,IAAjB;AAFH;AAFuB,KAA/B;AAQA,WAAO,IAAP;AACD;AAED;;;;;;;;SAMAyM,kBAAA,yBAAgBzM,IAAhB,EAAsB;AACpB,WAAO,KAAKoM,WAAL,CAAiBpM,IAAjB,CAAP,CADoB;;AAIpB,SAAK6D,IAAL,CAAU,mBAAV,EAA+B;AAC7BjF,MAAAA,IAAI,EAAE,QADuB;AAE7BkF,MAAAA,IAAI,EAAE;AACJ9D,QAAAA,IAAI,EAAJA;AADI;AAFuB,KAA/B;AAOA,WAAO,IAAP;AACD;AAED;;;;;;;;;;SAQA0M,oBAAA,2BAAkBvL,UAAlB,EAA8B;AAC5B,QAAI,CAAC5B,aAAa,CAAC4B,UAAD,CAAlB,EACE,MAAM,IAAIP,0BAAJ,CAA+B,sEAA/B,CAAN;AAEF,QAAMwD,MAAM,GAAG,KAAKgI,WAApB;AAEA,SAAKA,WAAL,GAAmBjL,UAAnB,CAN4B;;AAS5B,SAAK0C,IAAL,CAAU,mBAAV,EAA+B;AAC7BjF,MAAAA,IAAI,EAAE,SADuB;AAE7BkF,MAAAA,IAAI,EAAE;AACJM,QAAAA,MAAM,EAANA,MADI;AAEJC,QAAAA,KAAK,EAAElD;AAFH;AAFuB,KAA/B;AAQA,WAAO,IAAP;AACD;AAED;;;;;;;;;;SAQAwL,kBAAA,yBAAgBxL,UAAhB,EAA4B;AAC1B,QAAI,CAAC5B,aAAa,CAAC4B,UAAD,CAAlB,EACE,MAAM,IAAIP,0BAAJ,CAA+B,oEAA/B,CAAN;AAEF,SAAKwL,WAAL,GAAmBlO,MAAM,CAAC,KAAKkO,WAAN,EAAmBjL,UAAnB,CAAzB,CAJ0B;;AAO1B,SAAK0C,IAAL,CAAU,mBAAV,EAA+B;AAC7BjF,MAAAA,IAAI,EAAE,OADuB;AAE7BkF,MAAAA,IAAI,EAAE;AACJpD,QAAAA,IAAI,EAAE,KAAK0L;AADP;AAFuB,KAA/B;AAOA,WAAO,IAAP;AACD;AAED;;;;;;;;;;;SASAQ,mBAAA,0BAAiB5J,IAAjB,EAAuBhD,IAAvB,EAA6B;AAC3BgD,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMtC,IAAI,GAAG,KAAK5B,MAAL,CAAYC,GAAZ,CAAgBiE,IAAhB,CAAb;;AAEA,QAAI,CAACtC,IAAL,EACE,MAAM,IAAIK,kBAAJ,wDAAsEiC,IAAtE,2BAAN;AAEF,WAAOtC,IAAI,CAACS,UAAL,CAAgBnB,IAAhB,CAAP;AACD;AAED;;;;;;;;;;SAQA6M,oBAAA,2BAAkB7J,IAAlB,EAAwB;AACtBA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMtC,IAAI,GAAG,KAAK5B,MAAL,CAAYC,GAAZ,CAAgBiE,IAAhB,CAAb;;AAEA,QAAI,CAACtC,IAAL,EACE,MAAM,IAAIK,kBAAJ,yDAAuEiC,IAAvE,2BAAN;AAEF,WAAOtC,IAAI,CAACS,UAAZ;AACD;AAED;;;;;;;;;;;SASA2L,mBAAA,0BAAiB9J,IAAjB,EAAuBhD,IAAvB,EAA6B;AAC3BgD,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMtC,IAAI,GAAG,KAAK5B,MAAL,CAAYC,GAAZ,CAAgBiE,IAAhB,CAAb;;AAEA,QAAI,CAACtC,IAAL,EACE,MAAM,IAAIK,kBAAJ,wDAAsEiC,IAAtE,2BAAN;AAEF,WAAOtC,IAAI,CAACS,UAAL,CAAgBwC,cAAhB,CAA+B3D,IAA/B,CAAP;AACD;AAED;;;;;;;;;;;;;SAWA+M,mBAAA,0BAAiB/J,IAAjB,EAAuBhD,IAAvB,EAA6BZ,KAA7B,EAAoC;AAClC4D,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMtC,IAAI,GAAG,KAAK5B,MAAL,CAAYC,GAAZ,CAAgBiE,IAAhB,CAAb;;AAEA,QAAI,CAACtC,IAAL,EACE,MAAM,IAAIK,kBAAJ,wDAAsEiC,IAAtE,2BAAN;AAEF,QAAI5E,SAAS,CAACG,MAAV,GAAmB,CAAvB,EACE,MAAM,IAAIqC,0BAAJ,CAA+B,sLAA/B,CAAN;AAEFF,IAAAA,IAAI,CAACS,UAAL,CAAgBnB,IAAhB,IAAwBZ,KAAxB,CAXkC;;AAclC,SAAKyE,IAAL,CAAU,uBAAV,EAAmC;AACjC3C,MAAAA,GAAG,EAAE8B,IAD4B;AAEjCpE,MAAAA,IAAI,EAAE,KAF2B;AAGjCkF,MAAAA,IAAI,EAAE;AACJ9D,QAAAA,IAAI,EAAJA,IADI;AAEJZ,QAAAA,KAAK,EAALA;AAFI;AAH2B,KAAnC;AASA,WAAO,IAAP;AACD;AAED;;;;;;;;;;;;;;SAYA4N,sBAAA,6BAAoBhK,IAApB,EAA0BhD,IAA1B,EAAgCgE,OAAhC,EAAyC;AACvChB,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMtC,IAAI,GAAG,KAAK5B,MAAL,CAAYC,GAAZ,CAAgBiE,IAAhB,CAAb;;AAEA,QAAI,CAACtC,IAAL,EACE,MAAM,IAAIK,kBAAJ,2DAAyEiC,IAAzE,2BAAN;AAEF,QAAI5E,SAAS,CAACG,MAAV,GAAmB,CAAvB,EACE,MAAM,IAAIqC,0BAAJ,CAA+B,2LAA/B,CAAN;AAEF,QAAI,OAAOoD,OAAP,KAAmB,UAAvB,EACE,MAAM,IAAIpD,0BAAJ,CAA+B,sDAA/B,CAAN;AAEF,QAAMO,UAAU,GAAGT,IAAI,CAACS,UAAxB;AAEAA,IAAAA,UAAU,CAACnB,IAAD,CAAV,GAAmBgE,OAAO,CAAC7C,UAAU,CAACnB,IAAD,CAAX,CAA1B,CAhBuC;;AAmBvC,SAAK6D,IAAL,CAAU,uBAAV,EAAmC;AACjC3C,MAAAA,GAAG,EAAE8B,IAD4B;AAEjCpE,MAAAA,IAAI,EAAE,KAF2B;AAGjCkF,MAAAA,IAAI,EAAE;AACJ9D,QAAAA,IAAI,EAAJA,IADI;AAEJZ,QAAAA,KAAK,EAAE+B,UAAU,CAACnB,IAAD;AAFb;AAH2B,KAAnC;AASA,WAAO,IAAP;AACD;AAED;;;;;;;;;;;SASAiN,sBAAA,6BAAoBjK,IAApB,EAA0BhD,IAA1B,EAAgC;AAC9BgD,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMtC,IAAI,GAAG,KAAK5B,MAAL,CAAYC,GAAZ,CAAgBiE,IAAhB,CAAb;;AAEA,QAAI,CAACtC,IAAL,EACE,MAAM,IAAIK,kBAAJ,wDAAsEiC,IAAtE,2BAAN;AAEF,WAAOtC,IAAI,CAACS,UAAL,CAAgBnB,IAAhB,CAAP,CAR8B;;AAW9B,SAAK6D,IAAL,CAAU,uBAAV,EAAmC;AACjC3C,MAAAA,GAAG,EAAE8B,IAD4B;AAEjCpE,MAAAA,IAAI,EAAE,QAF2B;AAGjCkF,MAAAA,IAAI,EAAE;AACJ9D,QAAAA,IAAI,EAAJA;AADI;AAH2B,KAAnC;AAQA,WAAO,IAAP;AACD;AAED;;;;;;;;;;;;SAUAkN,wBAAA,+BAAsBlK,IAAtB,EAA4B7B,UAA5B,EAAwC;AACtC6B,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMtC,IAAI,GAAG,KAAK5B,MAAL,CAAYC,GAAZ,CAAgBiE,IAAhB,CAAb;;AAEA,QAAI,CAACtC,IAAL,EACE,MAAM,IAAIK,kBAAJ,6DAA2EiC,IAA3E,2BAAN;AAEF,QAAI,CAACzD,aAAa,CAAC4B,UAAD,CAAlB,EACE,MAAM,IAAIP,0BAAJ,CAA+B,0EAA/B,CAAN;AAEF,QAAMuD,aAAa,GAAGzD,IAAI,CAACS,UAA3B;AAEAT,IAAAA,IAAI,CAACS,UAAL,GAAkBA,UAAlB,CAbsC;;AAgBtC,SAAK0C,IAAL,CAAU,uBAAV,EAAmC;AACjC3C,MAAAA,GAAG,EAAE8B,IAD4B;AAEjCpE,MAAAA,IAAI,EAAE,SAF2B;AAGjCkF,MAAAA,IAAI,EAAE;AACJM,QAAAA,MAAM,EAAED,aADJ;AAEJE,QAAAA,KAAK,EAAElD;AAFH;AAH2B,KAAnC;AASA,WAAO,IAAP;AACD;AAED;;;;;;;;;;;;SAUAgM,sBAAA,6BAAoBnK,IAApB,EAA0B7B,UAA1B,EAAsC;AACpC6B,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMtC,IAAI,GAAG,KAAK5B,MAAL,CAAYC,GAAZ,CAAgBiE,IAAhB,CAAb;;AAEA,QAAI,CAACtC,IAAL,EACE,MAAM,IAAIK,kBAAJ,2DAAyEiC,IAAzE,2BAAN;AAEF,QAAI,CAACzD,aAAa,CAAC4B,UAAD,CAAlB,EACE,MAAM,IAAIP,0BAAJ,CAA+B,wEAA/B,CAAN;AAEF1C,IAAAA,MAAM,CAACwC,IAAI,CAACS,UAAN,EAAkBA,UAAlB,CAAN,CAXoC;;AAcpC,SAAK0C,IAAL,CAAU,uBAAV,EAAmC;AACjC3C,MAAAA,GAAG,EAAE8B,IAD4B;AAEjCpE,MAAAA,IAAI,EAAE,OAF2B;AAGjCkF,MAAAA,IAAI,EAAE;AACJpD,QAAAA,IAAI,EAAES;AADF;AAH2B,KAAnC;AAQA,WAAO,IAAP;AACD;AAED;;;;;AAKA;;;;;;;SAKA2B,UAAA,iBAAQmC,QAAR,EAAkB;AAChB,QAAI,OAAOA,QAAP,KAAoB,UAAxB,EACE,MAAM,IAAIrE,0BAAJ,CAA+B,sCAA/B,CAAN;;AAEF,SAAK4C,MAAL,CAAYV,OAAZ,CAAoB,UAACd,QAAD,EAAWd,GAAX,EAAmB;AACrC,UAAMrC,UAAU,GAAGmD,QAAQ,CAACrD,MAA5B;AAAA,UACMsD,UAAU,GAAGD,QAAQ,CAAC7D,MAD5B;AAGA8G,MAAAA,QAAQ,CACNpG,UAAU,CAACqC,GADL,EAENe,UAAU,CAACf,GAFL,EAGNrC,UAAU,CAACsC,UAHL,EAINc,UAAU,CAACd,UAJL,EAKND,GALM,EAMNc,QAAQ,CAACb,UANH,CAAR;AAQD,KAZD;AAaD;AAED;;;;;;;SAKAiM,YAAA,qBAAY;AACV,QAAMrH,QAAQ,GAAG,KAAKvC,MAAL,CAAYkC,MAAZ,EAAjB;;AAEA,WAAO,IAAIJ,QAAJ,CAAa,YAAW;AAC7B,UAAME,IAAI,GAAGO,QAAQ,CAACR,IAAT,EAAb;AAEA,UAAIC,IAAI,CAACC,IAAT,EACE,OAAOD,IAAP;AAEF,UAAMxD,QAAQ,GAAGwD,IAAI,CAACpG,KAAtB;AAEA,UAAMP,UAAU,GAAGmD,QAAQ,CAACrD,MAA5B;AAAA,UACMsD,UAAU,GAAGD,QAAQ,CAAC7D,MAD5B;AAGA,aAAO;AACLsH,QAAAA,IAAI,EAAE,KADD;AAELrG,QAAAA,KAAK,EAAE,CACLP,UAAU,CAACqC,GADN,EAELe,UAAU,CAACf,GAFN,EAGLrC,UAAU,CAACsC,UAHN,EAILc,UAAU,CAACd,UAJN,EAKLa,QAAQ,CAACd,GALJ,EAMLc,QAAQ,CAACb,UANJ;AAFF,OAAP;AAWD,KAtBM,CAAP;AAuBD;AAED;;;;;;;SAKAkM,QAAA,iBAAQ;AACN,WAAOnH,IAAI,CAAC,KAAKpH,MAAL,CAAYsG,IAAZ,EAAD,EAAqB,KAAKtG,MAAL,CAAY6D,IAAjC,CAAX;AACD;AAED;;;;;;;SAKA2K,cAAA,qBAAYrI,QAAZ,EAAsB;AACpB,QAAI,OAAOA,QAAP,KAAoB,UAAxB,EACE,MAAM,IAAIrE,0BAAJ,CAA+B,0CAA/B,CAAN;;AAEF,SAAK9B,MAAL,CAAYgE,OAAZ,CAAoB,UAACpC,IAAD,EAAOQ,GAAP,EAAe;AACjC+D,MAAAA,QAAQ,CAAC/D,GAAD,EAAMR,IAAI,CAACS,UAAX,CAAR;AACD,KAFD;AAGD;AAED;;;;;;;SAKAoM,cAAA,uBAAc;AACZ,QAAMxH,QAAQ,GAAG,KAAKjH,MAAL,CAAY4G,MAAZ,EAAjB;;AAEA,WAAO,IAAIJ,QAAJ,CAAa,YAAM;AACxB,UAAME,IAAI,GAAGO,QAAQ,CAACR,IAAT,EAAb;AAEA,UAAIC,IAAI,CAACC,IAAT,EACE,OAAOD,IAAP;AAEF,UAAM9E,IAAI,GAAG8E,IAAI,CAACpG,KAAlB;AAEA,aAAO;AAACA,QAAAA,KAAK,EAAE,CAACsB,IAAI,CAACQ,GAAN,EAAWR,IAAI,CAACS,UAAhB,CAAR;AAAqCsE,QAAAA,IAAI,EAAE;AAA3C,OAAP;AACD,KATM,CAAP;AAUD;AAED;;;;;AAKA;;;;;;;;;;SAQA+H,aAAA,oBAAWxK,IAAX,EAAiB;AACfA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAMtC,IAAI,GAAG,KAAK5B,MAAL,CAAYC,GAAZ,CAAgBiE,IAAhB,CAAb;;AAEA,QAAI,CAACtC,IAAL,EACE,MAAM,IAAIK,kBAAJ,kDAAgEiC,IAAhE,2BAAN;AAEF,WAAOkG,aAAa,CAAClG,IAAD,EAAOtC,IAAP,CAApB;AACD;AAED;;;;;;;;;;SAQA+M,aAAA,oBAAWzO,IAAX,EAAiB;AACfA,IAAAA,IAAI,GAAG,KAAKA,IAAZ;;AAEA,QAAM0B,IAAI,GAAG,KAAK8C,MAAL,CAAYzE,GAAZ,CAAgBC,IAAhB,CAAb;;AAEA,QAAI,CAAC0B,IAAL,EACE,MAAM,IAAIK,kBAAJ,kDAAgE/B,IAAhE,2BAAN;AAEF,WAAOoK,aAAa,CAACpK,IAAD,EAAO0B,IAAP,CAApB;AACD;AAED;;;;;;;qBAKA,mBAAS;AAEP,QAAM2M,KAAK,GAAG,IAAI/G,KAAJ,CAAU,KAAKxH,MAAL,CAAY6D,IAAtB,CAAd;AAEA,QAAItE,CAAC,GAAG,CAAR;;AAEA,SAAKS,MAAL,CAAYgE,OAAZ,CAAoB,UAACpC,IAAD,EAAOQ,GAAP,EAAe;AACjCmM,MAAAA,KAAK,CAAChP,CAAC,EAAF,CAAL,GAAa6K,aAAa,CAAChI,GAAD,EAAMR,IAAN,CAA1B;AACD,KAFD;;AAIA,QAAMwC,KAAK,GAAG,IAAIoD,KAAJ,CAAU,KAAK9C,MAAL,CAAYb,IAAtB,CAAd;AAEAtE,IAAAA,CAAC,GAAG,CAAJ;;AAEA,SAAKmF,MAAL,CAAYV,OAAZ,CAAoB,UAACpC,IAAD,EAAOQ,GAAP,EAAe;AACjCgC,MAAAA,KAAK,CAAC7E,CAAC,EAAF,CAAL,GAAa+K,aAAa,CAAClI,GAAD,EAAMR,IAAN,CAA1B;AACD,KAFD;;AAIA,WAAO;AACLS,MAAAA,UAAU,EAAE,KAAKkL,aAAL,EADP;AAELgB,MAAAA,KAAK,EAALA,KAFK;AAGLnK,MAAAA,KAAK,EAALA;AAHK,KAAP;AAKD;AAED;;;;;;;;;SAOAwK,aAAA,oBAAWhN,IAAX,EAAgC;AAAA,QAAfqH,KAAe,uEAAP,KAAO;AAE9B;AACA,QAAM4F,KAAK,GAAGtE,sBAAsB,CAAC3I,IAAD,CAApC;;AAEA,QAAIiN,KAAJ,EAAW;AAET,UAAIA,KAAK,KAAK,YAAd,EACE,MAAM,IAAI/M,0BAAJ,CAA+B,uHAA/B,CAAN;AACF,UAAI+M,KAAK,KAAK,QAAd,EACE,MAAM,IAAI/M,0BAAJ,CAA+B,oCAA/B,CAAN;AACF,UAAI+M,KAAK,KAAK,oBAAd,EACE,MAAM,IAAI/M,0BAAJ,CAA+B,6FAA/B,CAAN;AACH,KAb6B;;;AAAA,QAgBvBM,GAhBuB,GAgBCR,IAhBD,CAgBvBQ,GAhBuB;AAAA,2BAgBCR,IAhBD,CAgBlBS,UAhBkB;AAAA,QAgBlBA,UAhBkB,iCAgBL,EAhBK;AAkB9B,QAAI4G,KAAJ,EACE,KAAK+D,SAAL,CAAe5K,GAAf,EAAoBC,UAApB,EADF,KAGE,KAAKsJ,OAAL,CAAavJ,GAAb,EAAkBC,UAAlB;AAEF,WAAO,IAAP;AACD;AAED;;;;;;;;;SAOAyM,aAAA,oBAAWlN,IAAX,EAAgC;AAAA,QAAfqH,KAAe,uEAAP,KAAO;AAE9B;AACA,QAAM4F,KAAK,GAAGrE,sBAAsB,CAAC5I,IAAD,CAApC;;AAEA,QAAIiN,KAAJ,EAAW;AAET,UAAIA,KAAK,KAAK,YAAd,EACE,MAAM,IAAI/M,0BAAJ,CAA+B,qIAA/B,CAAN;AACF,UAAI+M,KAAK,KAAK,WAAd,EACE,MAAM,IAAI/M,0BAAJ,CAA+B,kCAA/B,CAAN;AACF,UAAI+M,KAAK,KAAK,WAAd,EACE,MAAM,IAAI/M,0BAAJ,CAA+B,mCAA/B,CAAN;AACF,UAAI+M,KAAK,KAAK,oBAAd,EACE,MAAM,IAAI/M,0BAAJ,CAA+B,6FAA/B,CAAN;AACF,UAAI+M,KAAK,KAAK,oBAAd,EACE,MAAM,IAAI/M,0BAAJ,CAA+B,gFAA/B,CAAN;AACH,KAjB6B;;;AAAA,QAqB5BjC,MArB4B,GAyB1B+B,IAzB0B,CAqB5B/B,MArB4B;AAAA,QAsB5BR,MAtB4B,GAyB1BuC,IAzB0B,CAsB5BvC,MAtB4B;AAAA,4BAyB1BuC,IAzB0B,CAuB5BS,UAvB4B;AAAA,QAuB5BA,UAvB4B,kCAuBf,EAvBe;AAAA,2BAyB1BT,IAzB0B,CAwB5BxB,UAxB4B;AAAA,QAwB5BA,UAxB4B,iCAwBf,KAxBe;AA2B9B,QAAImE,MAAJ;;AAEA,QAAI,SAAS3C,IAAb,EAAmB;AACjB2C,MAAAA,MAAM,GAAG0E,KAAK,GACX7I,UAAU,GAAG,KAAK2O,0BAAR,GAAqC,KAAKC,wBADzC,GAEX5O,UAAU,GAAG,KAAKG,wBAAR,GAAmC,KAAK0O,sBAFrD;AAIA1K,MAAAA,MAAM,CAAC2K,IAAP,CACE,IADF,EAEEtN,IAAI,CAACQ,GAFP,EAGEvC,MAHF,EAIER,MAJF,EAKEgD,UALF;AAOD,KAZD,MAaK;AACHkC,MAAAA,MAAM,GAAG0E,KAAK,GACX7I,UAAU,GAAG,KAAK+O,mBAAR,GAA8B,KAAKC,iBADlC,GAEXhP,UAAU,GAAG,KAAKiP,iBAAR,GAA4B,KAAKC,eAF9C;AAIA/K,MAAAA,MAAM,CAAC2K,IAAP,CACE,IADF,EAEErP,MAFF,EAGER,MAHF,EAIEgD,UAJF;AAMD;;AAED,WAAO,IAAP;AACD;AAED;;;;;;;;;qBAOA,iBAAOT,IAAP,EAA4B;AAAA;;AAAA,QAAfqH,KAAe,uEAAP,KAAO;;AAE1B;AACA,QAAI5I,OAAO,CAACuB,IAAD,CAAX,EAAmB;AAEjB,qBAAYA,IAAI,UAAJ,EAAZ,EAA2BqH,KAA3B;AACA,aAAO,IAAP;AACD,KAPyB;;;AAU1B,QAAI,CAACxI,aAAa,CAACmB,IAAD,CAAlB,EACE,MAAM,IAAIE,0BAAJ,CAA+B,mGAA/B,CAAN;;AAEF,QAAIF,IAAI,CAACS,UAAT,EAAqB;AACnB,UAAI,CAAC5B,aAAa,CAACmB,IAAI,CAACS,UAAN,CAAlB,EACE,MAAM,IAAIP,0BAAJ,CAA+B,6DAA/B,CAAN;AAEF,UAAImH,KAAJ,EACE,KAAK4E,eAAL,CAAqBjM,IAAI,CAACS,UAA1B,EADF,KAGE,KAAKuL,iBAAL,CAAuBhM,IAAI,CAACS,UAA5B;AACH,KArByB;;;AAwB1B,QAAIT,IAAI,CAAC2M,KAAT,EACE3M,IAAI,CAAC2M,KAAL,CAAWvK,OAAX,CAAmB,UAAAE,IAAI;AAAA,aAAI,MAAI,CAAC0K,UAAL,CAAgB1K,IAAhB,EAAsB+E,KAAtB,CAAJ;AAAA,KAAvB;AAEF,QAAIrH,IAAI,CAACwC,KAAT,EACExC,IAAI,CAACwC,KAAL,CAAWJ,OAAX,CAAmB,UAAA9D,IAAI;AAAA,aAAI,MAAI,CAAC4O,UAAL,CAAgB5O,IAAhB,EAAsB+I,KAAtB,CAAJ;AAAA,KAAvB;AAEF,WAAO,IAAP;AACD;AAED;;;;;AAKA;;;;;;;;;SAOAsG,WAAA,kBAAS3D,OAAT,EAAkB;AAChB,WAAO,IAAIhG,KAAJ,CAAUxG,MAAM,CAAC,EAAD,EAAK,KAAK4M,QAAV,EAAoBJ,OAApB,CAAhB,CAAP;AACD;AAED;;;;;;;;;SAOA4D,YAAA,mBAAU5D,OAAV,EAAmB;AACjB,QAAMhM,KAAK,GAAG,IAAIgG,KAAJ,CAAUxG,MAAM,CAAC,EAAD,EAAK,KAAK4M,QAAV,EAAoBJ,OAApB,CAAhB,CAAd;;AAEA,SAAK5L,MAAL,CAAYgE,OAAZ,CAAoB,UAAC8D,QAAD,EAAW1F,GAAX,EAAmB;AACrC0F,MAAAA,QAAQ,GAAG,IAAIlI,KAAK,CAACiM,aAAV,CAAwBzJ,GAAxB,EAA6BhD,MAAM,CAAC,EAAD,EAAK0I,QAAQ,CAACzF,UAAd,CAAnC,CAAX;;AACAzC,MAAAA,KAAK,CAACI,MAAN,CAAa4D,GAAb,CAAiBxB,GAAjB,EAAsB0F,QAAtB;AACD,KAHD;;AAKA,WAAOlI,KAAP;AACD;AAED;;;;;;;SAKA6P,OAAA,gBAAO;AACL,QAAM7P,KAAK,GAAG,IAAIgG,KAAJ,CAAU,KAAKoG,QAAf,CAAd;AACApM,IAAAA,KAAK,UAAL,CAAa,IAAb;AAEA,WAAOA,KAAP;AACD;AAED;;;;;;;SAKAgD,iBAAA,0BAAiB;AACf,QAAI,KAAK9C,IAAL,KAAc,OAAlB,EACE,OAAO,IAAP,CAFa;AAKf;AACA;AACA;AACA;;AACA,SAAKE,MAAL,CAAYgE,OAAZ,CAAoB,UAAApC,IAAI;AAAA,aAAKA,IAAI,CAACgB,cAAL,EAAL;AAAA,KAAxB,EATe;;;AAYf,SAAKoJ,QAAL,CAAclM,IAAd,GAAqB,OAArB;AACAyB,IAAAA,gBAAgB,CAAC,IAAD,EAAO,MAAP,EAAe,KAAKyK,QAAL,CAAclM,IAA7B,CAAhB;AACAmB,IAAAA,eAAe,CAAC,IAAD,EAAO,eAAP,EAAwBkB,aAAxB,CAAf;AAEA,WAAO,IAAP;AACD;AAED;;;;;;;SAKAuN,iBAAA,0BAAiB;AACf,QAAI,KAAKtM,KAAT,EACE,OAAO,IAAP,CAFa;;AAKf,SAAK4I,QAAL,CAAc5I,KAAd,GAAsB,IAAtB;AACA7B,IAAAA,gBAAgB,CAAC,IAAD,EAAO,OAAP,EAAgB,IAAhB,CAAhB,CANe;;AASf0C,IAAAA,4BAA4B,CAAC,IAAD,CAA5B;AAEA,WAAO,IAAP;AACD;AAED;;;;;AAKA;;;;;;;SAKAmJ,aAAA,sBAAa;AACXrJ,IAAAA,mBAAmB,CAAC,IAAD,CAAnB;AACA,WAAO,IAAP;AACD;AAED;;;;;AAKA;;;;;;;SAKA4L,SAAA,kBAAS;AACP,WAAO,gBAAP;AACD;AAED;;;;;;;;SAMAC,WAAA,oBAAW;AACT,QAAMC,WAAW,GAAG,KAAKC,KAAL,GAAa,CAAb,IAAkB,KAAKA,KAAL,KAAe,CAArD;AAAA,QACMC,UAAU,GAAG,KAAKlM,IAAL,GAAY,CAAZ,IAAiB,KAAKA,IAAL,KAAc,CADlD;AAGA,2BAAgBjD,WAAW,CAAC,KAAKkP,KAAN,CAA3B,kBAA+CD,WAAW,GAAG,GAAH,GAAS,EAAnE,eAA0EjP,WAAW,CAAC,KAAKiD,IAAN,CAArF,kBAAwGkM,UAAU,GAAG,GAAH,GAAS,EAA3H;AACD;AAED;;;;;;;SAKAC,UAAA,mBAAU;AAAA;;AACR,QAAMzB,KAAK,GAAG,EAAd;;AACA,SAAKvO,MAAL,CAAYgE,OAAZ,CAAoB,UAACpC,IAAD,EAAOQ,GAAP,EAAe;AACjCmM,MAAAA,KAAK,CAACnM,GAAD,CAAL,GAAaR,IAAI,CAACS,UAAlB;AACD,KAFD;;AAIA,QAAM+B,KAAK,GAAG,EAAd;AAAA,QACM6L,UAAU,GAAG,EADnB;;AAGA,SAAKvL,MAAL,CAAYV,OAAZ,CAAoB,UAACpC,IAAD,EAAOQ,GAAP,EAAe;AACjC,UAAM0D,SAAS,GAAGlE,IAAI,YAAYoB,kBAAhB,GAAqC,IAArC,GAA4C,IAA9D;AAEA,UAAIkN,KAAK,GAAG,EAAZ;AAEA,UAAMC,IAAI,cAAOvO,IAAI,CAAC/B,MAAL,CAAYuC,GAAnB,cAA0B0D,SAA1B,cAAuClE,IAAI,CAACvC,MAAL,CAAY+C,GAAnD,MAAV;;AAEA,UAAI,CAACR,IAAI,CAACmB,YAAV,EAAwB;AACtBmN,QAAAA,KAAK,eAAQ9N,GAAR,QAAL;AACD,OAFD,MAGK,IAAI,MAAI,CAACgB,KAAT,EAAgB;AACnB,YAAI,OAAO6M,UAAU,CAACE,IAAD,CAAjB,KAA4B,WAAhC,EAA6C;AAC3CF,UAAAA,UAAU,CAACE,IAAD,CAAV,GAAmB,CAAnB;AACD,SAFD,MAGK;AACHF,UAAAA,UAAU,CAACE,IAAD,CAAV;AACD;;AAEDD,QAAAA,KAAK,cAAOD,UAAU,CAACE,IAAD,CAAjB,OAAL;AACD;;AAEDD,MAAAA,KAAK,IAAIC,IAAT;AAEA/L,MAAAA,KAAK,CAAC8L,KAAD,CAAL,GAAetO,IAAI,CAACS,UAApB;AACD,KAxBD;;AA0BA,QAAM+N,KAAK,GAAG,EAAd;;AAEA,SAAK,IAAM1Q,CAAX,IAAgB,IAAhB,EAAsB;AACpB,UAAI,KAAKmF,cAAL,CAAoBnF,CAApB,KACA,CAACgL,aAAa,CAAClC,GAAd,CAAkB9I,CAAlB,CADD,IAEA,OAAO,KAAKA,CAAL,CAAP,KAAmB,UAFvB,EAGE0Q,KAAK,CAAC1Q,CAAD,CAAL,GAAW,KAAKA,CAAL,CAAX;AACH;;AAED0Q,IAAAA,KAAK,CAAC/N,UAAN,GAAmB,KAAKiL,WAAxB;AACA8C,IAAAA,KAAK,CAAC7B,KAAN,GAAcA,KAAd;AACA6B,IAAAA,KAAK,CAAChM,KAAN,GAAcA,KAAd;AAEAnD,IAAAA,eAAe,CAACmP,KAAD,EAAQ,aAAR,EAAuB,KAAK1P,WAA5B,CAAf;AAEA,WAAO0P,KAAP;AACD;;;EAntDgCC;AAytDnC,IAAI,OAAOC,MAAP,KAAkB,WAAtB,EACE1K,KAAK,CAAC5D,SAAN,CAAgBsO,MAAM,OAAN,CAAW,4BAAX,CAAhB,IAA4D1K,KAAK,CAAC5D,SAAN,CAAgBgO,OAA5E;AAEF;;;;;;;;AAQA;;;;AAGArF,gBAAgB,CAAC3G,OAAjB,CAAyB,UAAAO,MAAM,EAAI;AACjC,GAAC,KAAD,EAAQ,OAAR,EAAiBP,OAAjB,CAAyB,UAAA4G,IAAI,EAAI;AAC/B,QAAM1J,IAAI,GAAGqD,MAAM,CAACrD,IAAP,CAAY0J,IAAZ,CAAb;AAAA,QACM5C,EAAE,GAAG4C,IAAI,KAAK,KAAT,GAAiBK,OAAjB,GAA2BO,SADtC;;AAGA,QAAIjH,MAAM,CAACsG,WAAX,EAAwB;AACtBjF,MAAAA,KAAK,CAAC5D,SAAN,CAAgBd,IAAhB,IAAwB,UAASrB,MAAT,EAAiBR,MAAjB,EAAyBgD,UAAzB,EAAqC;AAC3D,eAAO2F,EAAE,CACP,IADO,EAEP9G,IAFO,EAGP,IAHO,EAIP,CAACqD,MAAM,CAACzE,IAAP,IAAe,KAAKA,IAArB,MAA+B,YAJxB,EAKP,IALO,EAMPD,MANO,EAOPR,MAPO,EAQPgD,UARO,CAAT;AAUD,OAXD;AAYD,KAbD,MAcK;AACHuD,MAAAA,KAAK,CAAC5D,SAAN,CAAgBd,IAAhB,IAAwB,UAAShB,IAAT,EAAeL,MAAf,EAAuBR,MAAvB,EAA+BgD,UAA/B,EAA2C;AACjE,eAAO2F,EAAE,CACP,IADO,EAEP9G,IAFO,EAGP,KAHO,EAIP,CAACqD,MAAM,CAACzE,IAAP,IAAe,KAAKA,IAArB,MAA+B,YAJxB,EAKPI,IALO,EAMPL,MANO,EAOPR,MAPO,EAQPgD,UARO,CAAT;AAUD,OAXD;AAYD;AACF,GAhCD;AAiCD,CAlCD;AAoCA;;;;AAGA,IAAI,OAAOiO,MAAP,KAAkB,WAAtB,EACE1K,KAAK,CAAC5D,SAAN,CAAgBsO,MAAM,CAACrJ,QAAvB,IAAmCrB,KAAK,CAAC5D,SAAN,CAAgBsM,SAAnD;AAEF;;;;AAGA3I,uBAAuB,CAACC,KAAD,CAAvB;AAEA;;;;AAGAmD,0BAA0B,CAACnD,KAAD,CAA1B;AAEA;;;;AAGAuE,8BAA8B,CAACvE,KAAD,CAA9B;;ACptEA;;;;IAGM2K;;;AACJ,yBAAY3E,OAAZ,EAAqB;AAAA,WACnB,kBACExM,MAAM,CAAC;AAACU,MAAAA,IAAI,EAAE;AAAP,KAAD,EAAqB8L,OAArB,CADR,CADmB;AAIpB;;;EALyBhG;;IAOtB4K;;;AACJ,2BAAY5E,OAAZ,EAAqB;AAAA,WACnB,mBACExM,MAAM,CAAC;AAACU,MAAAA,IAAI,EAAE;AAAP,KAAD,EAAuB8L,OAAvB,CADR,CADmB;AAIpB;;;EAL2BhG;;IAOxB6K;;;AACJ,sBAAY7E,OAAZ,EAAqB;AAAA,WACnB,mBACExM,MAAM,CAAC;AAACgE,MAAAA,KAAK,EAAE;AAAR,KAAD,EAAgBwI,OAAhB,CADR,CADmB;AAIpB;;;EALsBhG;;IAOnB8K;;;AACJ,8BAAY9E,OAAZ,EAAqB;AAAA,WACnB,mBACExM,MAAM,CAAC;AAACgE,MAAAA,KAAK,EAAE,IAAR;AAActD,MAAAA,IAAI,EAAE;AAApB,KAAD,EAAkC8L,OAAlC,CADR,CADmB;AAIpB;;;EAL8BhG;;IAO3B+K;;;AACJ,gCAAY/E,OAAZ,EAAqB;AAAA,WACnB,mBACExM,MAAM,CAAC;AAACgE,MAAAA,KAAK,EAAE,IAAR;AAActD,MAAAA,IAAI,EAAE;AAApB,KAAD,EAAoC8L,OAApC,CADR,CADmB;AAIpB;;;EALgChG;AAQnC;;;;;AAGA,SAASgL,sBAAT,CAAgCtM,KAAhC,EAAuC;AAErC;;;;;;;AAOAA,EAAAA,KAAK,CAACuM,IAAN,GAAa,UAASjP,IAAT,EAAegK,OAAf,EAAwB;AACnC,QAAMkF,QAAQ,GAAG,IAAIxM,KAAJ,CAAUsH,OAAV,CAAjB;AACAkF,IAAAA,QAAQ,UAAR,CAAgBlP,IAAhB;AAEA,WAAOkP,QAAP;AACD,GALD;AAMD;;AAEDF,sBAAsB,CAAChL,KAAD,CAAtB;AACAgL,sBAAsB,CAACL,aAAD,CAAtB;AACAK,sBAAsB,CAACJ,eAAD,CAAtB;AACAI,sBAAsB,CAACH,UAAD,CAAtB;AACAG,sBAAsB,CAACF,kBAAD,CAAtB;AACAE,sBAAsB,CAACD,oBAAD,CAAtB;AAEA/K,KAAK,CAACA,KAAN,GAAcA,KAAd;AACAA,KAAK,CAAC2K,aAAN,GAAsBA,aAAtB;AACA3K,KAAK,CAAC4K,eAAN,GAAwBA,eAAxB;AACA5K,KAAK,CAAC6K,UAAN,GAAmBA,UAAnB;AACA7K,KAAK,CAAC8K,kBAAN,GAA2BA,kBAA3B;AACA9K,KAAK,CAAC+K,oBAAN,GAA6BA,oBAA7B;AAEA/K,KAAK,CAAC9D,0BAAN,GAAmCA,0BAAnC;AACA8D,KAAK,CAAC3D,kBAAN,GAA2BA,kBAA3B;AACA2D,KAAK,CAAC1D,eAAN,GAAwBA,eAAxB;;AC3FA;;;;;;;;;"}