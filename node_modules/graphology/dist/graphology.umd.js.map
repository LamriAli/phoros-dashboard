{"version":3,"file":"graphology.umd.js","sources":["../src/utils.js","../node_modules/rollup-plugin-node-builtins/src/es6/events.js","../node_modules/obliterator/iterator.js","../node_modules/obliterator/take.js","../src/errors.js","../src/data.js","../src/indices.js","../src/attributes.js","../node_modules/obliterator/chain.js","../src/iteration/edges.js","../src/iteration/neighbors.js","../src/serialization.js","../src/graph.js","../src/classes.js","../src/endpoint.cjs.js"],"sourcesContent":["/**\n * Graphology Utilities\n * =====================\n *\n * Collection of helpful functions used by the implementation.\n */\n\n/**\n * Very simple Object.assign-like function.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nexport function assign() {\n  const target = arguments[0] || {};\n\n  for (let i = 1, l = arguments.length; i < l; i++) {\n    if (!arguments[i])\n      continue;\n\n    for (const k in arguments[i])\n      target[k] = arguments[i][k];\n  }\n\n  return target;\n}\n\n/**\n * Function returning the first matching edge for given path.\n * Note: this function does not check the existence of source & target. This\n * must be performed by the caller.\n *\n * @param  {Graph}  graph  - Target graph.\n * @param  {any}    source - Source node.\n * @param  {any}    target - Target node.\n * @param  {string} type   - Type of the edge (mixed, directed or undirected).\n * @return {string|null}\n */\nexport function getMatchingEdge(graph, source, target, type) {\n  const sourceData = graph._nodes.get(source);\n\n  let edge = null;\n\n  if (!sourceData)\n    return edge;\n\n  if (type === 'mixed') {\n    edge = (\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target])\n    );\n  }\n  else if (type === 'directed') {\n    edge = sourceData.out && sourceData.out[target];\n  }\n  else {\n    edge = sourceData.undirected && sourceData.undirected[target];\n  }\n\n  return edge;\n}\n\n/**\n * Checks whether the given value is a Graph implementation instance.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isGraph(value) {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof value.addUndirectedEdgeWithKey === 'function' &&\n    typeof value.dropNode === 'function'\n  );\n}\n\n/**\n * Checks whether the given value is a plain object.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isPlainObject(value) {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    value.constructor === Object\n  );\n}\n\n/**\n * Pretty prints the given integer.\n *\n * @param  {number}  integer - Target integer.\n * @return {string}          - The pretty string.\n */\nexport function prettyPrint(integer) {\n  const string = '' + integer;\n\n  let prettyString = '';\n\n  for (let i = 0, l = string.length; i < l; i++) {\n    const j = l - i - 1;\n\n    prettyString = string[j] + prettyString;\n\n    if (!((i - 2) % 3) && i !== l - 1)\n      prettyString = ',' + prettyString;\n  }\n\n  return prettyString;\n}\n\n/**\n * Creates a \"private\" property for the given member name by concealing it\n * using the `enumerable` option.\n *\n * @param {object} target - Target object.\n * @param {string} name   - Member name.\n */\nexport function privateProperty(target, name, value) {\n  Object.defineProperty(target, name, {\n    enumerable: false,\n    configurable: false,\n    writable: true,\n    value\n  });\n}\n\n\n/**\n * Creates a read-only property for the given member name & the given getter.\n *\n * @param {object}   target - Target object.\n * @param {string}   name   - Member name.\n * @param {mixed}    value  - The attached getter or fixed value.\n */\nexport function readOnlyProperty(target, name, value) {\n  const descriptor = {\n    enumerable: true,\n    configurable: true\n  };\n\n  if (typeof value === 'function') {\n    descriptor.get = value;\n  }\n  else {\n    descriptor.value = value;\n    descriptor.writable = false;\n  }\n\n  Object.defineProperty(target, name, descriptor);\n}\n\n/**\n * Creates a function generating incremental ids for edges.\n *\n * @return {function}\n */\nexport function incrementalId() {\n  let i = 0;\n\n  return () => {\n    return `_geid${i++}_`;\n  };\n}\n","'use strict';\n\nvar domain;\n\n// This constructor is used to store event handlers. Instantiating this is\n// faster than explicitly calling `Object.create(null)` to get a \"clean\" empty\n// object (tested with v8 v4.9).\nfunction EventHandlers() {}\nEventHandlers.prototype = Object.create(null);\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nexport default EventEmitter;\nexport {EventEmitter};\n\n// nodejs oddity\n// require('events') === require('events').EventEmitter\nEventEmitter.EventEmitter = EventEmitter\n\nEventEmitter.usingDomains = false;\n\nEventEmitter.prototype.domain = undefined;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\nEventEmitter.init = function() {\n  this.domain = null;\n  if (EventEmitter.usingDomains) {\n    // if there is an active domain, then attach to it.\n    if (domain.active && !(this instanceof domain.Domain)) {\n      this.domain = domain.active;\n    }\n  }\n\n  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = new EventHandlers();\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || isNaN(n))\n    throw new TypeError('\"n\" argument must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\n// These standalone emit* functions are used to optimize calling of event\n// handlers for fast cases because emit() itself often has a variable number of\n// arguments and can be deoptimized because of that. These functions always have\n// the same number of arguments and thus do not get deoptimized, so the code\n// inside them can execute faster.\nfunction emitNone(handler, isFn, self) {\n  if (isFn)\n    handler.call(self);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self);\n  }\n}\nfunction emitOne(handler, isFn, self, arg1) {\n  if (isFn)\n    handler.call(self, arg1);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1);\n  }\n}\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\n  if (isFn)\n    handler.call(self, arg1, arg2);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2);\n  }\n}\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n  if (isFn)\n    handler.call(self, arg1, arg2, arg3);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2, arg3);\n  }\n}\n\nfunction emitMany(handler, isFn, self, args) {\n  if (isFn)\n    handler.apply(self, args);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].apply(self, args);\n  }\n}\n\nEventEmitter.prototype.emit = function emit(type) {\n  var er, handler, len, args, i, events, domain;\n  var needDomainExit = false;\n  var doError = (type === 'error');\n\n  events = this._events;\n  if (events)\n    doError = (doError && events.error == null);\n  else if (!doError)\n    return false;\n\n  domain = this.domain;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    er = arguments[1];\n    if (domain) {\n      if (!er)\n        er = new Error('Uncaught, unspecified \"error\" event');\n      er.domainEmitter = this;\n      er.domain = domain;\n      er.domainThrown = false;\n      domain.emit('error', er);\n    } else if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      // At least give some kind of context to the user\n      var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n      err.context = er;\n      throw err;\n    }\n    return false;\n  }\n\n  handler = events[type];\n\n  if (!handler)\n    return false;\n\n  var isFn = typeof handler === 'function';\n  len = arguments.length;\n  switch (len) {\n    // fast cases\n    case 1:\n      emitNone(handler, isFn, this);\n      break;\n    case 2:\n      emitOne(handler, isFn, this, arguments[1]);\n      break;\n    case 3:\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n      break;\n    case 4:\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n      break;\n    // slower\n    default:\n      args = new Array(len - 1);\n      for (i = 1; i < len; i++)\n        args[i - 1] = arguments[i];\n      emitMany(handler, isFn, this, args);\n  }\n\n  if (needDomainExit)\n    domain.exit();\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n\n  events = target._events;\n  if (!events) {\n    events = target._events = new EventHandlers();\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (!existing) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] :\n                                          [existing, listener];\n    } else {\n      // If we've already got an array, just append.\n      if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n    }\n\n    // Check for listener leak\n    if (!existing.warned) {\n      m = $getMaxListeners(target);\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true;\n        var w = new Error('Possible EventEmitter memory leak detected. ' +\n                            existing.length + ' ' + type + ' listeners added. ' +\n                            'Use emitter.setMaxListeners() to increase limit');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        emitWarning(w);\n      }\n    }\n  }\n\n  return target;\n}\nfunction emitWarning(e) {\n  typeof console.warn === 'function' ? console.warn(e) : console.log(e);\n}\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction _onceWrap(target, type, listener) {\n  var fired = false;\n  function g() {\n    target.removeListener(type, g);\n    if (!fired) {\n      fired = true;\n      listener.apply(target, arguments);\n    }\n  }\n  g.listener = listener;\n  return g;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      list = events[type];\n      if (!list)\n        return this;\n\n      if (list === listener || (list.listener && list.listener === listener)) {\n        if (--this._eventsCount === 0)\n          this._events = new EventHandlers();\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length; i-- > 0;) {\n          if (list[i] === listener ||\n              (list[i].listener && list[i].listener === listener)) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (list.length === 1) {\n          list[0] = undefined;\n          if (--this._eventsCount === 0) {\n            this._events = new EventHandlers();\n            return this;\n          } else {\n            delete events[type];\n          }\n        } else {\n          spliceOne(list, position);\n        }\n\n        if (events.removeListener)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events;\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (!events.removeListener) {\n        if (arguments.length === 0) {\n          this._events = new EventHandlers();\n          this._eventsCount = 0;\n        } else if (events[type]) {\n          if (--this._eventsCount === 0)\n            this._events = new EventHandlers();\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        for (var i = 0, key; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = new EventHandlers();\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners) {\n        // LIFO order\n        do {\n          this.removeListener(type, listeners[listeners.length - 1]);\n        } while (listeners[0]);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  var evlistener;\n  var ret;\n  var events = this._events;\n\n  if (!events)\n    ret = [];\n  else {\n    evlistener = events[type];\n    if (!evlistener)\n      ret = [];\n    else if (typeof evlistener === 'function')\n      ret = [evlistener.listener || evlistener];\n    else\n      ret = unwrapListeners(evlistener);\n  }\n\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n};\n\n// About 1.5x faster than the two-arg version of Array#splice().\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n    list[i] = list[k];\n  list.pop();\n}\n\nfunction arrayClone(arr, i) {\n  var copy = new Array(i);\n  while (i--)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n","/**\n * Obliterator Iterator Class\n * ===========================\n *\n * Simple class representing the library's iterators.\n */\n\n/**\n * Iterator class.\n *\n * @constructor\n * @param {function} next - Next function.\n */\nfunction Iterator(next) {\n\n  // Hiding the given function\n  Object.defineProperty(this, '_next', {\n    writable: false,\n    enumerable: false,\n    value: next\n  });\n\n  // Is the iterator complete?\n  this.done = false;\n}\n\n/**\n * Next function.\n *\n * @return {object}\n */\n// NOTE: maybe this should dropped for performance?\nIterator.prototype.next = function() {\n  if (this.done)\n    return {done: true};\n\n  var step = this._next();\n\n  if (step.done)\n    this.done = true;\n\n  return step;\n};\n\n/**\n * If symbols are supported, we add `next` to `Symbol.iterator`.\n */\nif (typeof Symbol !== 'undefined')\n  Iterator.prototype[Symbol.iterator] = function() {\n    return this;\n  };\n\n/**\n * Returning an iterator of the given values.\n *\n * @param  {any...} values - Values.\n * @return {Iterator}\n */\nIterator.of = function() {\n  var args = arguments,\n      l = args.length,\n      i = 0;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {done: true};\n\n    return {done: false, value: args[i++]};\n  });\n};\n\n/**\n * Returning an empty iterator.\n *\n * @return {Iterator}\n */\nIterator.empty = function() {\n  var iterator = new Iterator(null);\n  iterator.done = true;\n\n  return iterator;\n};\n\n/**\n * Returning whether the given value is an iterator.\n *\n * @param  {any} value - Value.\n * @return {boolean}\n */\nIterator.is = function(value) {\n  if (value instanceof Iterator)\n    return true;\n\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    typeof value.next === 'function'\n  );\n};\n\n/**\n * Exporting.\n */\nmodule.exports = Iterator;\n","/* eslint no-constant-condition: 0 */\n/**\n * Obliterator Take Function\n * ==========================\n *\n * Function taking n or every value of the given iterator and returns them\n * into an array.\n */\n\n/**\n * Take.\n *\n * @param  {Iterator} iterator - Target iterator.\n * @param  {number}   [n]      - Optional number of items to take.\n * @return {array}\n */\nmodule.exports = function take(iterator, n) {\n  var l = arguments.length > 1 ? n : Infinity,\n      array = l !== Infinity ? new Array(l) : [],\n      step,\n      i = 0;\n\n  while (true) {\n\n    if (i === l)\n      return array;\n\n    step = iterator.next();\n\n    if (step.done) {\n\n      if (i !== n)\n        return array.slice(0, i);\n\n      return array;\n    }\n\n    array[i++] = step.value;\n  }\n};\n","/**\n * Graphology Custom Errors\n * =========================\n *\n * Defining custom errors for ease of use & easy unit tests across\n * implementations (normalized typology rather than relying on error\n * messages to check whether the correct error was found).\n */\nexport class GraphError extends Error {\n  constructor(message, data) {\n    super();\n    this.name = 'GraphError';\n    this.message = message || '';\n    this.data = data || {};\n  }\n}\n\nexport class InvalidArgumentsGraphError extends GraphError {\n  constructor(message, data) {\n    super(message, data);\n    this.name = 'InvalidArgumentsGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, InvalidArgumentsGraphError.prototype.constructor);\n  }\n}\n\nexport class NotFoundGraphError extends GraphError {\n  constructor(message, data) {\n    super(message, data);\n    this.name = 'NotFoundGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, NotFoundGraphError.prototype.constructor);\n  }\n}\n\nexport class UsageGraphError extends GraphError {\n  constructor(message, data) {\n    super(message, data);\n    this.name = 'UsageGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, UsageGraphError.prototype.constructor);\n  }\n}\n","/**\n * Graphology Internal Data Classes\n * =================================\n *\n * Internal classes hopefully reduced to structs by engines & storing\n * necessary information for nodes & edges.\n *\n * Note that those classes don't rely on the `class` keyword to avoid some\n * cruft introduced by most of ES2015 transpilers.\n */\n\n/**\n * MixedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function MixedNodeData(key, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.undirectedDegree = 0;\n  this.directedSelfLoops = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n  this.undirected = {};\n}\n\n/**\n * DirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function DirectedNodeData(key, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes || {};\n\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n}\n\nDirectedNodeData.prototype.upgradeToMixed = function() {\n\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.undirected = {};\n};\n\n\n/**\n * UndirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function UndirectedNodeData(key, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes || {};\n\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.undirected = {};\n}\n\nUndirectedNodeData.prototype.upgradeToMixed = function() {\n\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n};\n\n/**\n * DirectedEdgeData class.\n *\n * @constructor\n * @param {string}  string       - The edge's key.\n * @param {boolean} generatedKey - Was its key generated?\n * @param {string}  source       - Source of the edge.\n * @param {string}  target       - Target of the edge.\n * @param {object}  attributes   - Edge's attributes.\n */\nexport function DirectedEdgeData(key, generatedKey, source, target, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  // Extremities\n  this.source = source;\n  this.target = target;\n\n  // Was its key generated?\n  this.generatedKey = generatedKey;\n}\n\n/**\n * UndirectedEdgeData class.\n *\n * @constructor\n * @param {string}  string       - The edge's key.\n * @param {boolean} generatedKey - Was its key generated?\n * @param {string}  source       - Source of the edge.\n * @param {string}  target       - Target of the edge.\n * @param {object}  attributes   - Edge's attributes.\n */\nexport function UndirectedEdgeData(key, generatedKey, source, target, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  // Extremities\n  this.source = source;\n  this.target = target;\n\n  // Was its key generated?\n  this.generatedKey = generatedKey;\n}\n","/**\n * Graphology Indexes Functions\n * =============================\n *\n * Bunch of functions used to compute or clear indexes.\n */\n\n/**\n * Function updating the 'structure' index with the given edge's data.\n * Note that in the case of the multi graph, related edges are stored in a\n * set that is the same for A -> B & B <- A.\n *\n * @param {Graph}    graph      - Target Graph instance.\n * @param {EdgeData} edgeData   - Added edge's data.\n * @param {NodeData} sourceData - Source node's data.\n * @param {NodeData} targetData - Target node's data.\n */\nexport function updateStructureIndex(\n  graph,\n  undirected,\n  edgeData,\n  source,\n  target,\n  sourceData,\n  targetData\n) {\n  const multi = graph.multi;\n\n  const outKey = undirected ? 'undirected' : 'out',\n        inKey = undirected ? 'undirected' : 'in';\n\n  // Handling source\n  let edgeOrSet = sourceData[outKey][target];\n\n  if (typeof edgeOrSet === 'undefined') {\n    edgeOrSet = multi ? new Set() : edgeData;\n    sourceData[outKey][target] = edgeOrSet;\n  }\n\n  if (multi)\n    edgeOrSet.add(edgeData);\n\n  // If selfLoop, we break here\n  if (source === target)\n    return;\n\n  // Handling target (we won't add the edge because it was already taken\n  // care of with source above)\n  if (typeof targetData[inKey][source] === 'undefined')\n    targetData[inKey][source] = edgeOrSet;\n}\n\n/**\n * Function clearing the 'structure' index data related to the given edge.\n *\n * @param {Graph}    graph    - Target Graph instance.\n * @param {EdgeData} edgeData - Dropped edge's data.\n */\nexport function clearEdgeFromStructureIndex(graph, undirected, edgeData) {\n  const multi = graph.multi;\n\n  const {source: sourceData, target: targetData} = edgeData;\n\n  const source = sourceData.key,\n        target = targetData.key;\n\n  // NOTE: since the edge set is the same for source & target, we can only\n  // affect source\n  const outKey = undirected ? 'undirected' : 'out',\n        sourceIndex = sourceData[outKey];\n\n  const inKey = undirected ? 'undirected' : 'in';\n\n  if (target in sourceIndex) {\n\n    if (multi) {\n      const set = sourceIndex[target];\n\n      if (set.size === 1) {\n        delete sourceIndex[target];\n        delete targetData[inKey][source];\n      }\n      else {\n        set.delete(edgeData);\n      }\n    }\n    else\n      delete sourceIndex[target];\n  }\n\n  if (multi)\n    return;\n\n  const targetIndex = targetData[inKey];\n\n  delete targetIndex[source];\n}\n\n/**\n * Function clearing the whole 'structure' index.\n *\n * @param {Graph} graph - Target Graph instance.\n */\nexport function clearStructureIndex(graph) {\n  graph._nodes.forEach(data => {\n\n    // Clearing now useless properties\n    if (typeof data.in !== 'undefined') {\n      data.in = {};\n      data.out = {};\n    }\n\n    if (typeof data.undirected !== 'undefined') {\n      data.undirected = {};\n    }\n  });\n}\n\n/**\n * Function used to upgrade a simple `structure` index to a multi on.\n *\n * @param {Graph}  graph - Target Graph instance.\n */\nexport function upgradeStructureIndexToMulti(graph) {\n  graph._nodes.forEach((data, node) => {\n\n    // Directed\n    if (data.out) {\n\n      for (const neighbor in data.out) {\n        const edges = new Set();\n        edges.add(data.out[neighbor]);\n        data.out[neighbor] = edges;\n        graph._nodes.get(neighbor).in[node] = edges;\n      }\n    }\n\n    // Undirected\n    if (data.undirected) {\n      for (const neighbor in data.undirected) {\n        if (neighbor > node)\n          continue;\n\n        const edges = new Set();\n        edges.add(data.undirected[neighbor]);\n        data.undirected[neighbor] = edges;\n        graph._nodes.get(neighbor).undirected[node] = edges;\n      }\n    }\n  });\n}\n","/**\n * Graphology Attributes methods\n * ==============================\n *\n * Attributes-related methods being exactly the same for nodes & edges,\n * we abstract them here for factorization reasons.\n */\nimport {\n  assign,\n  isPlainObject,\n  getMatchingEdge\n} from './utils';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\nimport {\n  DirectedEdgeData,\n  UndirectedEdgeData\n} from './data';\n\n/**\n * Attach an attribute getter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\nfunction attachAttributeGetter(Class, method, type, EdgeDataClass) {\n\n  /**\n   * Get the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {mixed}          - The attribute's value.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    return data.attributes[name];\n  };\n}\n\n/**\n * Attach an attributes getter method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\nfunction attachAttributesGetter(Class, method, type, EdgeDataClass) {\n\n  /**\n   * Retrieves all the target element's attributes.\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   *\n   * @return {object}          - The element's attributes.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 1) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + arguments[1];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    return data.attributes;\n  };\n}\n\n/**\n * Attach an attribute checker method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\nfunction attachAttributeChecker(Class, method, type, EdgeDataClass) {\n\n  /**\n   * Checks whether the desired attribute is set for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\n/**\n * Attach an attribute setter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\nfunction attachAttributeSetter(Class, method, type, EdgeDataClass) {\n\n  /**\n   * Set the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name, value) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 3) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n      value = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      meta: {\n        name,\n        value\n      }\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\nfunction attachAttributeUpdater(Class, method, type, EdgeDataClass) {\n\n  /**\n   * Update the desired attribute for the given element (node or edge) using\n   * the provided function.\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 3) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n      updater = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(`Graph.${method}: updater should be a function.`);\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    data.attributes[name] = updater(data.attributes[name]);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      meta: {\n        name,\n        value: data.attributes[name]\n      }\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute remover method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\nfunction attachAttributeRemover(Class, method, type, EdgeDataClass) {\n\n  /**\n   * Remove the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      meta: {\n        name\n      }\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute replacer method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\nfunction attachAttributesReplacer(Class, method, type, EdgeDataClass) {\n\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - New attributes.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - New attributes.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(`Graph.${method}: provided attributes are not a plain object.`);\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    const oldAttributes = data.attributes;\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      meta: {\n        before: oldAttributes,\n        after: attributes\n      }\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute merger method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\nfunction attachAttributesMerger(Class, method, type, EdgeDataClass) {\n\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - Attributes to merge.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - Attributes to merge.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(`Graph.${method}: provided attributes are not a plain object.`);\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      meta: {\n        data: attributes\n      }\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachAttributesMerger\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nexport function attachAttributesMethods(Graph) {\n  ATTRIBUTES_METHODS.forEach(function({name, attacher}) {\n\n    // For edges\n    attacher(\n      Graph,\n      name('Edge'),\n      'mixed',\n      DirectedEdgeData\n    );\n\n    // For directed edges\n    attacher(\n      Graph,\n      name('DirectedEdge'),\n      'directed',\n      DirectedEdgeData\n    );\n\n    // For undirected edges\n    attacher(\n      Graph,\n      name('UndirectedEdge'),\n      'undirected',\n      UndirectedEdgeData\n    );\n  });\n}\n","/**\n * Obliterator Chain Function\n * ===========================\n *\n * Variadic function combining the given iterators.\n */\nvar Iterator = require('./iterator.js');\n\n/**\n * Chain.\n *\n * @param  {...Iterator} iterators - Target iterators.\n * @return {Iterator}\n */\nmodule.exports = function chain() {\n  var iterators = arguments,\n      current,\n      i = -1;\n\n  return new Iterator(function iterate() {\n    if (!current) {\n      i++;\n\n      if (i >= iterators.length)\n        return {done: true};\n\n      current = iterators[i];\n    }\n\n    var step = current.next();\n\n    if (step.done) {\n      current = null;\n      return iterate();\n    }\n\n    return step;\n  });\n};\n","/**\n * Graphology Edge Iteration\n * ==========================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's edges.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError\n} from '../errors';\n\nimport {UndirectedEdgeData} from '../data';\n\n/**\n * Definitions.\n */\nconst EDGES_ITERATION = [\n  {\n    name: 'edges',\n    type: 'mixed'\n  },\n  {\n    name: 'inEdges',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outEdges',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundEdges',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundEdges',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedEdges',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedEdges',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function collecting edges from the given object.\n *\n * @param  {array}  edges  - Edges array to populate.\n * @param  {object} object - Target object.\n * @return {array}         - The found edges.\n */\nfunction collect(edges, object) {\n  for (const k in object) {\n    if (object[k] instanceof Set)\n      object[k].forEach(edgeData => edges.push(edgeData.key));\n    else\n      edges.push(object[k].key);\n  }\n}\n\n/**\n * Function iterating over edges from the given object using a callback.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction forEachSimple(object, callback) {\n  for (const k in object) {\n    const edgeData = object[k];\n\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes\n    );\n  }\n}\n\nfunction forEachMulti(object, callback) {\n  for (const k in object) {\n    object[k].forEach(edgeData => callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes\n    ));\n  }\n}\n\n/**\n * Function returning an iterator over edges from the given object.\n *\n * @param  {object}   object - Target object.\n * @return {Iterator}\n */\nfunction createIterator(object) {\n  const keys = Object.keys(object),\n        l = keys.length;\n\n  let inner = null,\n      i = 0;\n\n  return new Iterator(function next() {\n    let edgeData;\n\n    if (inner) {\n      const step = inner.next();\n\n      if (step.done) {\n        inner = null;\n        i++;\n        return next();\n      }\n\n      edgeData = step.value;\n    }\n    else {\n      if (i >= l)\n        return {done: true};\n\n      const k = keys[i];\n\n      edgeData = object[k];\n\n      if (edgeData instanceof Set) {\n        inner = edgeData.values();\n        return next();\n      }\n\n      i++;\n    }\n\n    return {\n      done: false,\n      value: [\n        edgeData.key,\n        edgeData.attributes,\n        edgeData.source.key,\n        edgeData.target.key,\n        edgeData.source.attributes,\n        edgeData.target.attributes\n      ]\n    };\n  });\n}\n\n/**\n * Function collecting edges from the given object at given key.\n *\n * @param  {array}  edges  - Edges array to populate.\n * @param  {object} object - Target object.\n * @param  {mixed}  k      - Neighbor key.\n * @return {array}         - The found edges.\n */\nfunction collectForKey(edges, object, k) {\n\n  if (!(k in object))\n    return;\n\n  if (object[k] instanceof Set)\n    object[k].forEach(edgeData => edges.push(edgeData.key));\n  else\n    edges.push(object[k].key);\n\n  return;\n}\n\n/**\n * Function iterating over the egdes from the object at given key using\n * a callback.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction forEachForKey(object, k, callback) {\n\n  if (!(k in object))\n    return;\n\n  if (object[k] instanceof Set)\n    object[k].forEach(edgeData => callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes\n    ));\n  else {\n    const edgeData = object[k];\n\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes\n    );\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over the egdes from the object at given key.\n *\n * @param  {object}   object   - Target object.\n * @param  {mixed}    k        - Neighbor key.\n * @return {Iterator}\n */\nfunction createIteratorForKey(object, k) {\n  const v = object[k];\n\n  if (v instanceof Set) {\n    const iterator = v.values();\n\n    return new Iterator(function() {\n      const step = iterator.next();\n\n      if (step.done)\n        return step;\n\n      const edgeData = step.value;\n\n      return {\n        done: false,\n        value: [\n          edgeData.key,\n          edgeData.attributes,\n          edgeData.source.key,\n          edgeData.target.key,\n          edgeData.source.attributes,\n          edgeData.target.attributes\n        ]\n      };\n    });\n  }\n\n  return Iterator.of([\n    v.key,\n    v.attributes,\n    v.source.key,\n    v.target.key,\n    v.source.attributes,\n    v.target.attributes\n  ]);\n}\n\n/**\n * Function creating an array of edges for the given type.\n *\n * @param  {Graph}   graph - Target Graph instance.\n * @param  {string}  type  - Type of edges to retrieve.\n * @return {array}         - Array of edges.\n */\nfunction createEdgeArray(graph, type) {\n  if (graph.size === 0)\n    return [];\n\n  if (type === 'mixed' || type === graph.type)\n    return take(graph._edges.keys(), graph._edges.size);\n\n  const size = type === 'undirected' ?\n    graph.undirectedSize :\n    graph.directedSize;\n\n  const list = new Array(size),\n        mask = type === 'undirected';\n\n  let i = 0;\n\n  graph._edges.forEach((data, edge) => {\n\n    if ((data instanceof UndirectedEdgeData) === mask)\n      list[i++] = edge;\n  });\n\n  return list;\n}\n\n/**\n * Function iterating over a graph's edges using a callback.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction forEachEdge(graph, type, callback) {\n  if (graph.size === 0)\n    return;\n\n  if (type === 'mixed' || type === graph.type) {\n    graph._edges.forEach((data, key) => {\n\n      const {attributes, source, target} = data;\n\n      callback(\n        key,\n        attributes,\n        source.key,\n        target.key,\n        source.attributes,\n        target.attributes\n      );\n    });\n  }\n  else {\n    const mask = type === 'undirected';\n\n    graph._edges.forEach((data, key) => {\n      if ((data instanceof UndirectedEdgeData) === mask) {\n\n        const {attributes, source, target} = data;\n\n        callback(\n          key,\n          attributes,\n          source.key,\n          target.key,\n          source.attributes,\n          target.attributes\n        );\n      }\n    });\n  }\n}\n\n/**\n * Function creating an iterator of edges for the given type.\n *\n * @param  {Graph}    graph - Target Graph instance.\n * @param  {string}   type  - Type of edges to retrieve.\n * @return {Iterator}\n */\nfunction createEdgeIterator(graph, type) {\n  if (graph.size === 0)\n    return Iterator.empty();\n\n  let iterator;\n\n  if (type === 'mixed') {\n    iterator = graph._edges.values();\n\n    return new Iterator(function next() {\n      const step = iterator.next();\n\n      if (step.done)\n        return step;\n\n      const data = step.value;\n\n      const value = [\n        data.key,\n        data.attributes,\n        data.source.key,\n        data.target.key,\n        data.source.attributes,\n        data.target.attributes\n      ];\n\n      return {value, done: false};\n    });\n  }\n\n  iterator = graph._edges.values();\n\n  return new Iterator(function next() {\n    const step = iterator.next();\n\n    if (step.done)\n      return step;\n\n    const data = step.value;\n\n    if ((data instanceof UndirectedEdgeData) === (type === 'undirected')) {\n      const value = [\n        data.key,\n        data.attributes,\n        data.source.key,\n        data.target.key,\n        data.source.attributes,\n        data.target.attributes\n      ];\n\n      return {value, done: false};\n    }\n\n    return next();\n  });\n}\n\n/**\n * Function creating an array of edges for the given type & the given node.\n *\n * @param  {string}  type      - Type of edges to retrieve.\n * @param  {string}  direction - In or out?\n * @param  {any}     nodeData  - Target node's data.\n * @return {array}             - Array of edges.\n */\nfunction createEdgeArrayForNode(type, direction, nodeData) {\n  const edges = [];\n\n  if (type !== 'undirected') {\n    if (direction !== 'out')\n      collect(edges, nodeData.in);\n    if (direction !== 'in')\n      collect(edges, nodeData.out);\n  }\n\n  if (type !== 'directed') {\n    collect(edges, nodeData.undirected);\n  }\n\n  return edges;\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction forEachEdgeForNode(multi, type, direction, nodeData, callback) {\n  const fn = multi ? forEachMulti : forEachSimple;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out')\n      fn(nodeData.in, callback);\n    if (direction !== 'in')\n      fn(nodeData.out, callback);\n  }\n\n  if (type !== 'directed') {\n    fn(nodeData.undirected, callback);\n  }\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createEdgeIteratorForNode(type, direction, nodeData) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined')\n      iterator = chain(iterator, createIterator(nodeData.in));\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined')\n      iterator = chain(iterator, createIterator(nodeData.out));\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    iterator = chain(iterator, createIterator(nodeData.undirected));\n  }\n\n  return iterator;\n}\n\n/**\n * Function creating an array of edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {any}      target     - Target node.\n * @return {array}               - Array of edges.\n */\nfunction createEdgeArrayForPath(type, direction, sourceData, target) {\n  const edges = [];\n\n  if (type !== 'undirected') {\n\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out')\n      collectForKey(edges, sourceData.in, target);\n\n    if (typeof sourceData.out !== 'undefined' && direction !== 'in')\n      collectForKey(edges, sourceData.out, target);\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined')\n      collectForKey(edges, sourceData.undirected, target);\n  }\n\n  return edges;\n}\n\n/**\n * Function iterating over edges for the given path using a callback.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction forEachEdgeForPath(type, direction, sourceData, target, callback) {\n  if (type !== 'undirected') {\n\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out')\n      forEachForKey(sourceData.in, target, callback);\n\n    if (typeof sourceData.out !== 'undefined' && direction !== 'in')\n      forEachForKey(sourceData.out, target, callback);\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined')\n      forEachForKey(sourceData.undirected, target, callback);\n  }\n}\n\n/**\n * Function returning an iterator over edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction createEdgeIteratorForPath(type, direction, sourceData, target) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n\n    if (\n      typeof sourceData.in !== 'undefined' &&\n      direction !== 'out' &&\n      target in sourceData.in\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.in, target));\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      target in sourceData.out\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.out, target));\n  }\n\n  if (type !== 'directed') {\n    if (\n      typeof sourceData.undirected !== 'undefined' &&\n      target in sourceData.undirected\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.undirected, target));\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching an edge array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeArrayCreator(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  /**\n   * Function returning an array of certain edges.\n   *\n   * Arity 0: Return all the relevant edges.\n   *\n   * Arity 1: Return all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function(source, target) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    if (!arguments.length)\n      return createEdgeArray(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${source}\" node in the graph.`);\n\n      // Iterating over a node's edges\n      return createEdgeArrayForNode(\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData\n      );\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${name}:  could not find the \"${source}\" source node in the graph.`);\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(`Graph.${name}:  could not find the \"${target}\" target node in the graph.`);\n\n      // Iterating over the edges between source & target\n      return createEdgeArrayForPath(type, direction, sourceData, target);\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching a edge callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachEdge(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function(source, target, callback) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(`Graph.${forEachName}: could not find the \"${source}\" node in the graph.`);\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${forEachName}:  could not find the \"${source}\" source node in the graph.`);\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(`Graph.${forEachName}:  could not find the \"${target}\" target node in the graph.`);\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(type, direction, sourceData, target, callback);\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${forEachName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching an edge iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nexport function attachEdgeIteratorCreator(Class, description) {\n  const {\n    name: originalName,\n    type,\n    direction\n  } = description;\n\n  const name = originalName.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over the graph's edges.\n   *\n   * Arity 0: Iterate over all the relevant edges.\n   *\n   * Arity 1: Iterate over all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Iterate over the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function(source, target) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    if (!arguments.length)\n      return createEdgeIterator(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${source}\" node in the graph.`);\n\n      // Iterating over a node's edges\n      return createEdgeIteratorForNode(type, direction, sourceData);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${name}:  could not find the \"${source}\" source node in the graph.`);\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(`Graph.${name}:  could not find the \"${target}\" target node in the graph.`);\n\n      // Iterating over the edges between source & target\n      return createEdgeIteratorForPath(type, direction, sourceData, target);\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching every edge iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport function attachEdgeIterationMethods(Graph) {\n  EDGES_ITERATION.forEach(description => {\n    attachEdgeArrayCreator(Graph, description);\n    attachForEachEdge(Graph, description);\n    attachEdgeIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Neighbor Iteration\n * ==============================\n *\n * Attaching some methods to the Graph class to be able to iterate over\n * neighbors.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError\n} from '../errors';\n\n/**\n * Definitions.\n */\nconst NEIGHBORS_ITERATION = [\n  {\n    name: 'neighbors',\n    type: 'mixed'\n  },\n  {\n    name: 'inNeighbors',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outNeighbors',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundNeighbors',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundNeighbors',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedNeighbors',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedNeighbors',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function merging neighbors into the given set iterating over the given object.\n *\n * @param {BasicSet} neighbors - Neighbors set.\n * @param {object}   object    - Target object.\n */\nfunction merge(neighbors, object) {\n  if (typeof object === 'undefined')\n    return;\n\n  for (const neighbor in object)\n    neighbors.add(neighbor);\n}\n\n/**\n * Function creating an array of relevant neighbors for the given node.\n *\n * @param  {string}       type      - Type of neighbors.\n * @param  {string}       direction - Direction.\n * @param  {any}          nodeData  - Target node's data.\n * @return {Array}                  - The list of neighbors.\n */\nfunction createNeighborArrayForNode(type, direction, nodeData) {\n\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return Object.keys(nodeData.undirected);\n\n    if (typeof direction === 'string')\n      return Object.keys(nodeData[direction]);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const neighbors = new Set();\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out') {\n      merge(neighbors, nodeData.in);\n    }\n    if (direction !== 'in') {\n      merge(neighbors, nodeData.out);\n    }\n  }\n\n  if (type !== 'directed') {\n    merge(neighbors, nodeData.undirected);\n  }\n\n  return take(neighbors.values(), neighbors.size);\n}\n\n/**\n * Function iterating over the given node's relevant neighbors using a\n * callback.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction forEachInObject(nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    callback(\n      neighborData.key,\n      neighborData.attributes\n    );\n  }\n}\n\nfunction forEachInObjectOnce(visited, nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key))\n      continue;\n\n    visited.add(neighborData.key);\n\n    callback(\n      neighborData.key,\n      neighborData.attributes\n    );\n  }\n}\n\nfunction forEachNeighborForNode(type, direction, nodeData, callback) {\n\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return forEachInObject(nodeData, nodeData.undirected, callback);\n\n    if (typeof direction === 'string')\n      return forEachInObject(nodeData, nodeData[direction], callback);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out') {\n      forEachInObjectOnce(visited, nodeData, nodeData.in, callback);\n    }\n    if (direction !== 'in') {\n      forEachInObjectOnce(visited, nodeData, nodeData.out, callback);\n    }\n  }\n\n  if (type !== 'directed') {\n    forEachInObjectOnce(visited, nodeData, nodeData.undirected, callback);\n  }\n}\n\n/**\n * Function returning an iterator over the given node's relevant neighbors.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createObjectIterator(nodeData, object) {\n  const keys = Object.keys(object),\n        l = keys.length;\n\n  let i = 0;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {done: true};\n\n    let edgeData = object[keys[i++]];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    return {\n      done: false,\n      value: [neighborData.key, neighborData.attributes]\n    };\n  });\n}\n\nfunction createDedupedObjectIterator(visited, nodeData, object) {\n  const keys = Object.keys(object),\n        l = keys.length;\n\n  let i = 0;\n\n  return new Iterator(function next() {\n    if (i >= l)\n      return {done: true};\n\n    let edgeData = object[keys[i++]];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key))\n      return next();\n\n    visited.add(neighborData.key);\n\n    return {\n      done: false,\n      value: [neighborData.key, neighborData.attributes]\n    };\n  });\n}\n\nfunction createNeighborIterator(type, direction, nodeData) {\n\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return createObjectIterator(nodeData, nodeData.undirected);\n\n    if (typeof direction === 'string')\n      return createObjectIterator(nodeData, nodeData[direction]);\n  }\n\n  let iterator = Iterator.empty();\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out') {\n      iterator = chain(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.in));\n    }\n    if (direction !== 'in') {\n      iterator = chain(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.out));\n    }\n  }\n\n  if (type !== 'directed') {\n    iterator = chain(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.undirected));\n  }\n\n  return iterator;\n}\n\n/**\n * Function returning whether the given node has target neighbor.\n *\n * @param  {Graph}        graph     - Target graph.\n * @param  {string}       type      - Type of neighbor.\n * @param  {string}       direction - Direction.\n * @param  {any}          node      - Target node.\n * @param  {any}          neighbor  - Target neighbor.\n * @return {boolean}\n */\nfunction nodeHasNeighbor(graph, type, direction, node, neighbor) {\n\n  const nodeData = graph._nodes.get(node);\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined') {\n      for (const k in nodeData.in)\n        if (k === neighbor)\n          return true;\n    }\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined') {\n      for (const k in nodeData.out)\n        if (k === neighbor)\n          return true;\n    }\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    for (const k in nodeData.undirected)\n        if (k === neighbor)\n          return true;\n  }\n\n  return false;\n}\n\n/**\n * Function attaching a neighbors array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborArrayCreator(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  /**\n   * Function returning an array or the count of certain neighbors.\n   *\n   * Arity 1: Return all of a node's relevant neighbors.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return whether the two nodes are indeed neighbors.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The neighbors or the number of neighbors.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function(node) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    if (arguments.length === 2) {\n      const node1 = '' + arguments[0],\n            node2 = '' + arguments[1];\n\n      if (!this._nodes.has(node1))\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${node1}\" node in the graph.`);\n\n      if (!this._nodes.has(node2))\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${node2}\" node in the graph.`);\n\n      // Here, we want to assess whether the two given nodes are neighbors\n      return nodeHasNeighbor(\n        this,\n        type,\n        direction,\n        node1,\n        node2\n      );\n    }\n    else if (arguments.length === 1) {\n      node = '' + node;\n\n      const nodeData = this._nodes.get(node);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${node}\" node in the graph.`);\n\n      // Here, we want to iterate over a node's relevant neighbors\n      const neighbors = createNeighborArrayForNode(\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData\n      );\n\n      return neighbors;\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${name}: invalid number of arguments (expecting 1 or 2 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachNeighbor(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function(node, callback) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(`Graph.${forEachName}: could not find the \"${node}\" node in the graph.`);\n\n    // Here, we want to iterate over a node's relevant neighbors\n    forEachNeighborForNode(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborIteratorCreator(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const iteratorName = name.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over all the relevant neighbors.\n   *\n   * @param  {any}      node     - Target node.\n   * @return {Iterator}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[iteratorName] = function(node) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(`Graph.${iteratorName}: could not find the \"${node}\" node in the graph.`);\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborIterator(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching every neighbor iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport function attachNeighborIterationMethods(Graph) {\n  NEIGHBORS_ITERATION.forEach(description => {\n    attachNeighborArrayCreator(Graph, description);\n    attachForEachNeighbor(Graph, description);\n    attachNeighborIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Serialization Utilities\n * ===================================\n *\n * Collection of functions used to validate import-export formats & to ouput\n * them from internal graph data.\n *\n * Serialized Node:\n * {key, ?attributes}\n *\n * Serialized Edge:\n * {key?, source, target, attributes?, undirected?}\n *\n * Serialized Graph:\n * {nodes[], edges?[]}\n */\nimport {UndirectedEdgeData} from './data';\nimport {assign, isPlainObject} from './utils';\n\n/**\n * Formats internal node data into a serialized node.\n *\n * @param  {any}    key  - The node's key.\n * @param  {object} data - Internal node's data.\n * @return {array}       - The serialized node.\n */\nexport function serializeNode(key, data) {\n  const serialized = {key};\n\n  if (Object.keys(data.attributes).length)\n    serialized.attributes = assign({}, data.attributes);\n\n  return serialized;\n}\n\n/**\n * Formats internal edge data into a serialized edge.\n *\n * @param  {any}    key  - The edge's key.\n * @param  {object} data - Internal edge's data.\n * @return {array}       - The serialized edge.\n */\nexport function serializeEdge(key, data) {\n  const serialized = {\n    source: data.source.key,\n    target: data.target.key\n  };\n\n  // We export the key unless if it was provided by the user\n  if (!data.generatedKey)\n    serialized.key = key;\n\n  if (Object.keys(data.attributes).length)\n    serialized.attributes = assign({}, data.attributes);\n\n  if (data instanceof UndirectedEdgeData)\n    serialized.undirected = true;\n\n  return serialized;\n}\n\n/**\n * Checks whether the given value is a serialized node.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedNode(value) {\n  if (!isPlainObject(value))\n    return 'not-object';\n\n  if (!('key' in value))\n    return 'no-key';\n\n  if ('attributes' in value &&\n      (!isPlainObject(value.attributes) || value.attributes === null))\n    return 'invalid-attributes';\n\n  return null;\n}\n\n/**\n * Checks whether the given value is a serialized edge.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedEdge(value) {\n  if (!isPlainObject(value))\n    return 'not-object';\n\n  if (!('source' in value))\n    return 'no-source';\n\n  if (!('target' in value))\n    return 'no-target';\n\n  if ('attributes' in value &&\n      (!isPlainObject(value.attributes) || value.attributes === null))\n    return 'invalid-attributes';\n\n  if ('undirected' in value &&\n      (typeof value.undirected !== 'boolean'))\n    return 'invalid-undirected';\n\n  return null;\n}\n","/* eslint no-nested-ternary: 0 */\n/**\n * Graphology Reference Implementation\n * ====================================\n *\n * Reference implementation of the graphology specs.\n */\nimport {EventEmitter} from 'events';\nimport Iterator from 'obliterator/iterator';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\nimport {\n  MixedNodeData,\n  DirectedNodeData,\n  UndirectedNodeData,\n  DirectedEdgeData,\n  UndirectedEdgeData\n} from './data';\n\nimport {\n  updateStructureIndex,\n  clearEdgeFromStructureIndex,\n  clearStructureIndex,\n  upgradeStructureIndexToMulti\n} from './indices';\n\nimport {attachAttributesMethods} from './attributes';\nimport {attachEdgeIterationMethods} from './iteration/edges';\nimport {attachNeighborIterationMethods} from './iteration/neighbors';\n\nimport {\n  serializeNode,\n  serializeEdge,\n  validateSerializedNode,\n  validateSerializedEdge\n} from './serialization';\n\nimport {\n  assign,\n  getMatchingEdge,\n  isGraph,\n  isPlainObject,\n  prettyPrint,\n  privateProperty,\n  readOnlyProperty,\n  incrementalId\n} from './utils';\n\n/**\n * Enums.\n */\nconst TYPES = new Set([\n  'directed',\n  'undirected',\n  'mixed'\n]);\n\nconst EMITTER_PROPS = new Set([\n  'domain',\n  '_events',\n  '_eventsCount',\n  '_maxListeners'\n]);\n\nconst EDGE_ADD_METHODS = [\n  {\n    name: verb => `${verb}Edge`,\n    generateKey: true\n  },\n  {\n    name: verb => `${verb}DirectedEdge`,\n    generateKey: true,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdge`,\n    generateKey: true,\n    type: 'undirected'\n  },\n  {\n    name: verb => `${verb}EdgeWithKey`,\n  },\n  {\n    name: verb => `${verb}DirectedEdgeWithKey`,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdgeWithKey`,\n    type: 'undirected'\n  }\n];\n\n/**\n * Default options.\n */\nconst DEFAULTS = {\n  allowSelfLoops: true,\n  edgeKeyGenerator: null,\n  multi: false,\n  type: 'mixed'\n};\n\n/**\n * Abstract functions used by the Graph class for various methods.\n */\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction addEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes\n) {\n\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(`Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(`Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);\n\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(`Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`);\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n  attributes = attributes || {};\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(`Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);\n\n  const sourceData = graph._nodes.get(source),\n        targetData = graph._nodes.get(target);\n\n  if (!sourceData)\n    throw new NotFoundGraphError(`Graph.${name}: source node \"${source}\" not found.`);\n\n  if (!targetData)\n    throw new NotFoundGraphError(`Graph.${name}: target node \"${target}\" not found.`);\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey)\n    edge = graph._edgeKeyGenerator(eventData);\n\n  // Coercion of edge key\n  edge = '' + edge;\n\n  // Here, we have a key collision\n  if (graph._edges.has(edge))\n    throw new UsageGraphError(`Graph.${name}: the \"${edge}\" edge already exists in the graph.`);\n\n  // Here, we might have a source / target collision\n  if (\n    !graph.multi &&\n    (\n      undirected ?\n        typeof sourceData.undirected[target] !== 'undefined' :\n        typeof sourceData.out[target] !== 'undefined'\n    )\n  ) {\n    throw new UsageGraphError(`Graph.${name}: an edge linking \"${source}\" to \"${target}\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`);\n  }\n\n  // Storing some data\n  const DataClass = undirected ? UndirectedEdgeData : DirectedEdgeData;\n\n  const edgeData = new DataClass(\n    edge,\n    mustGenerateKey,\n    sourceData,\n    targetData,\n    attributes\n  );\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  if (source === target) {\n    if (undirected)\n      sourceData.undirectedSelfLoops++;\n    else\n      sourceData.directedSelfLoops++;\n  }\n  else {\n    if (undirected) {\n      sourceData.undirectedDegree++;\n      targetData.undirectedDegree++;\n    }\n    else {\n      sourceData.outDegree++;\n      targetData.inDegree++;\n    }\n  }\n\n  // Updating relevant index\n  updateStructureIndex(\n    graph,\n    undirected,\n    edgeData,\n    source,\n    target,\n    sourceData,\n    targetData\n  );\n\n  if (undirected)\n    graph._undirectedSize++;\n  else\n    graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction mergeEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes\n) {\n\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(`Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(`Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);\n\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(`Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`);\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n  attributes = attributes || {};\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(`Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);\n\n  let sourceData = graph._nodes.get(source),\n      targetData = graph._nodes.get(target),\n      edgeData;\n\n  // Do we need to handle duplicate?\n  let alreadyExistingEdge = null;\n\n  if (!mustGenerateKey) {\n    edgeData = graph._edges.get(edge);\n\n    if (edgeData) {\n\n      // Here, we need to ensure, if the user gave a key, that source & target\n      // are coherent\n      if (\n        (edgeData.source !== source || edgeData.target !== target) ||\n        (undirected && (edgeData.source !== target || edgeData.target !== source))\n      ) {\n        throw new UsageGraphError(`Graph.${name}: inconsistency detected when attempting to merge the \"${edge}\" edge with \"${source}\" source & \"${target}\" target vs. (${edgeData.source}, ${edgeData.target}).`);\n      }\n\n      alreadyExistingEdge = edge;\n    }\n  }\n\n  let alreadyExistingEdgeData;\n\n  // Here, we might have a source / target collision\n  if (\n    !alreadyExistingEdge &&\n    !graph.multi &&\n    sourceData &&\n    (\n      undirected ?\n        typeof sourceData.undirected[target] !== 'undefined' :\n        typeof sourceData.out[target] !== 'undefined'\n    )\n  ) {\n    alreadyExistingEdgeData = getMatchingEdge(graph, source, target, undirected ? 'undirected' : 'directed');\n  }\n\n  // Handling duplicates\n  if (alreadyExistingEdgeData) {\n\n    // We can skip the attribute merging part if the user did not provide them\n    if (!attributes)\n      return alreadyExistingEdge;\n\n    // Merging the attributes\n    assign(alreadyExistingEdgeData.attributes, attributes);\n    return alreadyExistingEdge;\n  }\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey)\n    edge = graph._edgeKeyGenerator(eventData);\n\n  // Coercion of edge key\n  edge = '' + edge;\n\n  // Here, we have a key collision\n  if (graph._edges.has(edge))\n    throw new UsageGraphError(`Graph.${name}: the \"${edge}\" edge already exists in the graph.`);\n\n  if (!sourceData) {\n    graph.addNode(source);\n    sourceData = graph._nodes.get(source);\n\n    if (source === target)\n      targetData = sourceData;\n  }\n  if (!targetData) {\n    graph.addNode(target);\n    targetData = graph._nodes.get(target);\n  }\n\n  // Storing some data\n  const DataClass = undirected ? UndirectedEdgeData : DirectedEdgeData;\n\n  edgeData = new DataClass(\n    edge,\n    mustGenerateKey,\n    sourceData,\n    targetData,\n    attributes\n  );\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  if (source === target) {\n    if (undirected)\n      sourceData.undirectedSelfLoops++;\n    else\n      sourceData.directedSelfLoops++;\n  }\n  else {\n    if (undirected) {\n      sourceData.undirectedDegree++;\n      targetData.undirectedDegree++;\n    }\n    else {\n      sourceData.outDegree++;\n      targetData.inDegree++;\n    }\n  }\n\n  // Updating relevant index\n  updateStructureIndex(\n    graph,\n    undirected,\n    edgeData,\n    source,\n    target,\n    sourceData,\n    targetData\n  );\n\n  if (undirected)\n    graph._undirectedSize++;\n  else\n    graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Graph class\n *\n * @constructor\n * @param  {object}  [options] - Options:\n * @param  {boolean}   [allowSelfLoops] - Allow self loops?\n * @param  {string}    [type]           - Type of the graph.\n * @param  {boolean}   [map]            - Allow references as keys?\n * @param  {boolean}   [multi]          - Allow parallel edges?\n *\n * @throws {Error} - Will throw if the arguments are not valid.\n */\nexport default class Graph extends EventEmitter {\n  constructor(options) {\n    super();\n\n    //-- Solving options\n    options = assign({}, DEFAULTS, options);\n\n    // Enforcing options validity\n    if (options.edgeKeyGenerator && typeof options.edgeKeyGenerator !== 'function')\n      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'edgeKeyGenerator' option. Expecting a function but got \"${options.edgeKeyGenerator}\".`);\n\n    if (typeof options.multi !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"${options.multi}\".`);\n\n    if (!TYPES.has(options.type))\n      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'type' option. Should be one of \"mixed\", \"directed\" or \"undirected\" but got \"${options.type}\".`);\n\n    if (typeof options.allowSelfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"${options.allowSelfLoops}\".`);\n\n    //-- Private properties\n\n    // Utilities\n    const NodeDataClass = options.type === 'mixed' ?\n      MixedNodeData :\n      (options.type === 'directed') ?\n        DirectedNodeData :\n        UndirectedNodeData;\n\n    privateProperty(this, 'NodeDataClass', NodeDataClass);\n\n    // Indexes\n    privateProperty(this, '_attributes', {});\n    privateProperty(this, '_nodes', new Map());\n    privateProperty(this, '_edges', new Map());\n    privateProperty(this, '_directedSize', 0);\n    privateProperty(this, '_undirectedSize', 0);\n    privateProperty(this, '_edgeKeyGenerator', options.edgeKeyGenerator || incrementalId());\n\n    // Options\n    privateProperty(this, '_options', options);\n\n    // Emitter properties\n    EMITTER_PROPS.forEach(prop => privateProperty(this, prop, this[prop]));\n\n    //-- Properties readers\n    readOnlyProperty(this, 'order', () => this._nodes.size);\n    readOnlyProperty(this, 'size', () => this._edges.size);\n    readOnlyProperty(this, 'directedSize', () => this._directedSize);\n    readOnlyProperty(this, 'undirectedSize', () => this._undirectedSize);\n    readOnlyProperty(this, 'multi', this._options.multi);\n    readOnlyProperty(this, 'type', this._options.type);\n    readOnlyProperty(this, 'allowSelfLoops', this._options.allowSelfLoops);\n  }\n\n  /**---------------------------------------------------------------------------\n   * Read\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning whether the given node is found in the graph.\n   *\n   * @param  {any}     node - The node.\n   * @return {boolean}\n   */\n  hasNode(node) {\n    return this._nodes.has('' + node);\n  }\n\n  /**\n   * Method returning whether the given directed edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasDirectedEdge(source, target) {\n\n    // Early termination\n    if (this.type === 'undirected')\n      return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return (\n        !!edgeData &&\n        edgeData instanceof DirectedEdgeData\n      );\n    }\n    else if (arguments.length === 2) {\n\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData)\n        return false;\n\n      // Is there a directed edge pointing toward target?\n      const edges = nodeData.out[target];\n\n      if (!edges)\n        return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);\n  }\n\n  /**\n   * Method returning whether the given undirected edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasUndirectedEdge(source, target) {\n\n    // Early termination\n    if (this.type === 'directed')\n      return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return (\n        !!edgeData &&\n        edgeData instanceof UndirectedEdgeData\n      );\n    }\n    else if (arguments.length === 2) {\n\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData)\n        return false;\n\n      // Is there a directed edge pointing toward target?\n      const edges = nodeData.undirected[target];\n\n      if (!edges)\n        return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);\n  }\n\n  /**\n   * Method returning whether the given edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasEdge(source, target) {\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      return this._edges.has(edge);\n    }\n    else if (arguments.length === 2) {\n\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData)\n        return false;\n\n      // Is there a directed edge pointing toward target?\n      let edges = typeof nodeData.out !== 'undefined' && nodeData.out[target];\n\n      if (!edges)\n        edges = typeof nodeData.undirected !== 'undefined' && nodeData.undirected[target];\n\n      if (!edges)\n        return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);\n  }\n\n  /**\n   * Method returning the edge matching source & target in a directed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  directedEdge(source, target) {\n\n    if (this.type === 'undirected')\n      return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError('Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.');\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(`Graph.directedEdge: could not find the \"${source}\" source node in the graph.`);\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(`Graph.directedEdge: could not find the \"${target}\" target node in the graph.`);\n\n    const edgeData = (sourceData.out && sourceData.out[target]) || undefined;\n\n    if (edgeData)\n      return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a undirected fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  undirectedEdge(source, target) {\n\n    if (this.type === 'directed')\n      return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError('Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.');\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(`Graph.undirectedEdge: could not find the \"${source}\" source node in the graph.`);\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(`Graph.undirectedEdge: could not find the \"${target}\" target node in the graph.`);\n\n    const edgeData = (sourceData.undirected && sourceData.undirected[target]) || undefined;\n\n    if (edgeData)\n      return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a mixed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  edge(source, target) {\n    if (this.multi)\n      throw new UsageGraphError('Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.');\n\n    source = '' + source;\n    target = '' + target;\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(`Graph.edge: could not find the \"${source}\" source node in the graph.`);\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(`Graph.edge: could not find the \"${target}\" target node in the graph.`);\n\n    const edgeData = (\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]) ||\n      undefined\n    );\n\n    if (edgeData)\n      return edgeData.key;\n  }\n\n  /**\n   * Method returning the given node's in degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} allowSelfLoops - Count self-loops?\n   * @return {number}            - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.inDegree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.inDegree: could not find the \"${node}\" node in the graph.`);\n\n    if (this.type === 'undirected')\n      return 0;\n\n    const loops = selfLoops ? nodeData.directedSelfLoops : 0;\n\n    return nodeData.inDegree + loops;\n  }\n\n  /**\n   * Method returning the given node's out degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's out degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.outDegree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.outDegree: could not find the \"${node}\" node in the graph.`);\n\n    if (this.type === 'undirected')\n      return 0;\n\n    const loops = selfLoops ? nodeData.directedSelfLoops : 0;\n\n    return nodeData.outDegree + loops;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's directed degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.directedDegree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    if (!this.hasNode(node))\n      throw new NotFoundGraphError(`Graph.directedDegree: could not find the \"${node}\" node in the graph.`);\n\n    if (this.type === 'undirected')\n      return 0;\n\n    return this.inDegree(node, selfLoops) + this.outDegree(node, selfLoops);\n  }\n\n  /**\n   * Method returning the given node's undirected degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's undirected degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.undirectedDegree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    if (!this.hasNode(node))\n      throw new NotFoundGraphError(`Graph.undirectedDegree: could not find the \"${node}\" node in the graph.`);\n\n    if (this.type === 'directed')\n      return 0;\n\n    const data = this._nodes.get(node),\n          loops = selfLoops ? (data.undirectedSelfLoops * 2) : 0;\n\n    return data.undirectedDegree + loops;\n  }\n\n  /**\n   * Method returning the given node's degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.degree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    if (!this.hasNode(node))\n      throw new NotFoundGraphError(`Graph.degree: could not find the \"${node}\" node in the graph.`);\n\n    let degree = 0;\n\n    if (this.type !== 'undirected')\n      degree += this.directedDegree(node, selfLoops);\n\n    if (this.type !== 'directed')\n      degree += this.undirectedDegree(node, selfLoops);\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given edge's source.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's source.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  source(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.source: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.source.key;\n  }\n\n  /**\n   * Method returning the given edge's target.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's target.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  target(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.target: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.target.key;\n  }\n\n  /**\n   * Method returning the given edge's extremities.\n   *\n   * @param  {any}   edge - The edge's key.\n   * @return {array}      - The edge's extremities.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  extremities(edge) {\n    edge = '' + edge;\n\n    const edgeData = this._edges.get(edge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(`Graph.extremities: could not find the \"${edge}\" edge in the graph.`);\n\n    return [\n      edgeData.source.key,\n      edgeData.target.key\n    ];\n  }\n\n  /**\n   * Given a node & an edge, returns the other extremity of the edge.\n   *\n   * @param  {any}   node - The node's key.\n   * @param  {any}   edge - The edge's key.\n   * @return {any}        - The related node.\n   *\n   * @throws {Error} - Will throw if either the node or the edge isn't in the graph.\n   */\n  opposite(node, edge) {\n    node = '' + node;\n    edge = '' + edge;\n\n    if (!this._nodes.has(node))\n      throw new NotFoundGraphError(`Graph.opposite: could not find the \"${node}\" node in the graph.`);\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.opposite: could not find the \"${edge}\" edge in the graph.`);\n\n    const {source: sourceData, target: targetData} = data;\n\n    const source = sourceData.key,\n          target = targetData.key;\n\n    if (node !== source && node !== target)\n      throw new NotFoundGraphError(`Graph.opposite: the \"${node}\" node is not attached to the \"${edge}\" edge (${source}, ${target}).`);\n\n    return node === source ? target : source;\n  }\n\n  /**\n   * Method returning whether the given edge is undirected.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  undirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.undirected: could not find the \"${edge}\" edge in the graph.`);\n\n    return data instanceof UndirectedEdgeData;\n  }\n\n  /**\n   * Method returning whether the given edge is directed.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  directed(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.directed: could not find the \"${edge}\" edge in the graph.`);\n\n    return data instanceof DirectedEdgeData;\n  }\n\n  /**\n   * Method returning whether the given edge is a self loop.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  selfLoop(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.selfLoop: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.source === data.target;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Mutation\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to add a node to the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   *\n   * @throws {Error} - Will throw if the given node already exist.\n   * @throws {Error} - Will throw if the given attributes are not an object.\n   */\n  addNode(node, attributes) {\n    if (attributes && !isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(`Graph.addNode: invalid attributes. Expecting an object but got \"${attributes}\"`);\n\n    // String coercion\n    node = '' + node;\n    attributes = attributes || {};\n\n    if (this._nodes.has(node))\n      throw new UsageGraphError(`Graph.addNode: the \"${node}\" node already exist in the graph.`);\n\n    const data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return node;\n  }\n\n  /**\n   * Method used to merge a node into the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   */\n  mergeNode(node, attributes) {\n    if (attributes && !isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(`Graph.mergeNode: invalid attributes. Expecting an object but got \"${attributes}\"`);\n\n    // String coercion\n    node = '' + node;\n    attributes = attributes || {};\n\n    // If the node already exists, we merge the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (attributes)\n        assign(data.attributes, attributes);\n      return node;\n    }\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return node;\n  }\n\n  /**\n   * Method used to drop a single node & all its attached edges from the graph.\n   *\n   * @param  {any}    node - The node.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node doesn't exist.\n   */\n  dropNode(node) {\n    node = '' + node;\n\n    if (!this.hasNode(node))\n      throw new NotFoundGraphError(`Graph.dropNode: could not find the \"${node}\" node in the graph.`);\n\n    // Removing attached edges\n    const edges = this.edges(node);\n\n    // NOTE: we could go faster here\n    for (let i = 0, l = edges.length; i < l; i++)\n      this.dropEdge(edges[i]);\n\n    const data = this._nodes.get(node);\n\n    // Dropping the node from the register\n    this._nodes.delete(node);\n\n    // Emitting\n    this.emit('nodeDropped', {\n      key: node,\n      attributes: data.attributes\n    });\n  }\n\n  /**\n   * Method used to drop a single edge from the graph.\n   *\n   * Arity 1:\n   * @param  {any}    edge - The edge.\n   *\n   * Arity 2:\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropEdge(edge) {\n    let edgeData;\n\n    if (arguments.length > 1) {\n      const source = '' + arguments[0],\n            target = '' + arguments[1];\n\n      edgeData = getMatchingEdge(this, source, target, this.type);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(`Graph.dropEdge: could not find the \"${source}\" -> \"${target}\" edge in the graph.`);\n    }\n    else {\n      edge = '' + edge;\n\n      edgeData = this._edges.get(edge);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(`Graph.dropEdge: could not find the \"${edge}\" edge in the graph.`);\n    }\n\n    // Dropping the edge from the register\n    this._edges.delete(edgeData.key);\n\n    // Updating related degrees\n    const {\n      source: sourceData,\n      target: targetData,\n      attributes\n    } = edgeData;\n\n    const undirected = edgeData instanceof UndirectedEdgeData;\n\n    if (sourceData === targetData) {\n      sourceData.selfLoops--;\n    }\n    else {\n      if (undirected) {\n        sourceData.undirectedDegree--;\n        targetData.undirectedDegree--;\n      }\n      else {\n        sourceData.outDegree--;\n        targetData.inDegree--;\n      }\n    }\n\n    // Clearing index\n    clearEdgeFromStructureIndex(this, undirected, edgeData);\n\n    if (undirected)\n      this._undirectedSize--;\n    else\n      this._directedSize--;\n\n    // Emitting\n    this.emit('edgeDropped', {\n      key: edge,\n      attributes,\n      source: sourceData.key,\n      target: targetData.key,\n      undirected\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to remove every edge & every node from the graph.\n   *\n   * @return {Graph}\n   */\n  clear() {\n\n    // Clearing edges\n    this._edges.clear();\n\n    // Clearing nodes\n    this._nodes.clear();\n\n    // Emitting\n    this.emit('cleared');\n  }\n\n  /**\n   * Method used to remove every edge from the graph.\n   *\n   * @return {Graph}\n   */\n  clearEdges() {\n\n    // Clearing edges\n    this._edges.clear();\n\n    // Clearing indices\n    this.clearIndex();\n\n    // Emitting\n    this.emit('edgesCleared');\n  }\n\n  /**---------------------------------------------------------------------------\n   * Attributes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning the desired graph's attribute.\n   *\n   * @param  {string} name - Name of the attribute.\n   * @return {any}\n   */\n  getAttribute(name) {\n    return this._attributes[name];\n  }\n\n  /**\n   * Method returning the graph's attributes.\n   *\n   * @return {object}\n   */\n  getAttributes() {\n    return this._attributes;\n  }\n\n  /**\n   * Method returning whether the graph has the desired attribute.\n   *\n   * @param  {string}  name - Name of the attribute.\n   * @return {boolean}\n   */\n  hasAttribute(name) {\n    return this._attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method setting a value for the desired graph's attribute.\n   *\n   * @param  {string}  name  - Name of the attribute.\n   * @param  {any}     value - Value for the attribute.\n   * @return {Graph}\n   */\n  setAttribute(name, value) {\n    this._attributes[name] = value;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      meta: {\n        name,\n        value\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Method using a function to update the desired graph's attribute's value.\n   *\n   * @param  {string}   name    - Name of the attribute.\n   * @param  {function} updater - Function use to update the attribute's value.\n   * @return {Graph}\n   */\n  updateAttribute(name, updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.updateAttribute: updater should be a function.');\n\n    this._attributes[name] = updater(this._attributes[name]);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      meta: {\n        name,\n        value: this._attributes[name]\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired graph's attribute.\n   *\n   * @param  {string} name  - Name of the attribute.\n   * @return {Graph}\n   */\n  removeAttribute(name) {\n    delete this._attributes[name];\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'remove',\n      meta: {\n        name\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Method replacing the graph's attributes.\n   *\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  replaceAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError('Graph.replaceAttributes: provided attributes are not a plain object.');\n\n    const before = this._attributes;\n\n    this._attributes = attributes;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'replace',\n      meta: {\n        before,\n        after: attributes\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the graph's attributes.\n   *\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  mergeAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError('Graph.mergeAttributes: provided attributes are not a plain object.');\n\n    this._attributes = assign(this._attributes, attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'merge',\n      meta: {\n        data: this._attributes\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Method returning the desired attribute for the given node.\n   *\n   * @param  {any}    node - Target node.\n   * @param  {string} name - Name of the attribute to get.\n   * @return {any}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  getNodeAttribute(node, name) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.getNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    return data.attributes[name];\n  }\n\n  /**\n   * Method returning the attributes for the given node.\n   *\n   * @param  {any}    node - Target node.\n   * @return {object}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  getNodeAttributes(node) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.getNodeAttributes: could not find the \"${node}\" node in the graph.`);\n\n    return data.attributes;\n  }\n\n  /**\n   * Method checking whether the given attribute exists for the given node.\n   *\n   * @param  {any}    node - Target node.\n   * @param  {string} name - Name of the attribute to check.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  hasNodeAttribute(node, name) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.hasNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    return data.attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method checking setting the desired attribute for the given node.\n   *\n   * @param  {any}    node  - Target node.\n   * @param  {string} name  - Name of the attribute to set.\n   * @param  {any}    value - Value for the attribute.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if less than 3 arguments are passed.\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  setNodeAttribute(node, name, value) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.setNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError('Graph.setNodeAttribute: not enough arguments. Either you forgot to pass the attribute\\'s name or value, or you meant to use #.replaceNodeAttributes / #.mergeNodeAttributes instead.');\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'set',\n      meta: {\n        name,\n        value\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Method checking setting the desired attribute for the given node.\n   *\n   * @param  {any}      node    - Target node.\n   * @param  {string}   name    - Name of the attribute to set.\n   * @param  {function} updater - Function that will update the attribute.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if less than 3 arguments are passed.\n   * @throws {Error} - Will throw if updater is not a function.\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  updateNodeAttribute(node, name, updater) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.updateNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError('Graph.updateNodeAttribute: not enough arguments. Either you forgot to pass the attribute\\'s name or updater, or you meant to use #.replaceNodeAttributes / #.mergeNodeAttributes instead.');\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.updateAttribute: updater should be a function.');\n\n    const attributes = data.attributes;\n\n    attributes[name] = updater(attributes[name]);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'set',\n      meta: {\n        name,\n        value: attributes[name]\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired attribute for the given node.\n   *\n   * @param  {any}    node  - Target node.\n   * @param  {string} name  - Name of the attribute to remove.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  removeNodeAttribute(node, name) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.hasNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'remove',\n      meta: {\n        name\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Method completely replacing the attributes of the given node.\n   *\n   * @param  {any}    node       - Target node.\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   * @throws {Error} - Will throw if the given attributes is not a plain object.\n   */\n  replaceNodeAttributes(node, attributes) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.replaceNodeAttributes: could not find the \"${node}\" node in the graph.`);\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError('Graph.replaceNodeAttributes: provided attributes are not a plain object.');\n\n    const oldAttributes = data.attributes;\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'replace',\n      meta: {\n        before: oldAttributes,\n        after: attributes\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the attributes of the given node with the provided ones.\n   *\n   * @param  {any}    node       - Target node.\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   * @throws {Error} - Will throw if the given attributes is not a plain object.\n   */\n  mergeNodeAttributes(node, attributes) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.mergeNodeAttributes: could not find the \"${node}\" node in the graph.`);\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError('Graph.mergeNodeAttributes: provided attributes are not a plain object.');\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'merge',\n      meta: {\n        data: attributes\n      }\n    });\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Iteration-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method iterating over the graph's adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEach(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.forEach: expecting a callback.');\n\n    this._edges.forEach((edgeData, key) => {\n      const sourceData = edgeData.source,\n            targetData = edgeData.target;\n\n      callback(\n        sourceData.key,\n        targetData.key,\n        sourceData.attributes,\n        targetData.attributes,\n        key,\n        edgeData.attributes\n      );\n    });\n  }\n\n  /**\n   * Method returning an iterator over the graph's adjacency.\n   *\n   * @return {Iterator}\n   */\n  adjacency() {\n    const iterator = this._edges.values();\n\n    return new Iterator(function() {\n      const step = iterator.next();\n\n      if (step.done)\n        return step;\n\n      const edgeData = step.value;\n\n      const sourceData = edgeData.source,\n            targetData = edgeData.target;\n\n      return {\n        done: false,\n        value: [\n          sourceData.key,\n          targetData.key,\n          sourceData.attributes,\n          targetData.attributes,\n          edgeData.key,\n          edgeData.attributes\n        ]\n      };\n    });\n  }\n\n  /**\n   * Method returning the list of the graph's nodes.\n   *\n   * @return {array} - The nodes.\n   */\n  nodes() {\n    return take(this._nodes.keys(), this._nodes.size);\n  }\n\n  /**\n   * Method iterating over the graph's nodes using the given callback.\n   *\n   * @param  {function}  callback - Callback (key, attributes, index).\n   */\n  forEachNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.forEachNode: expecting a callback.');\n\n    this._nodes.forEach((data, key) => {\n      callback(key, data.attributes);\n    });\n  }\n\n  /**\n   * Method returning an iterator over the graph's node entries.\n   *\n   * @return {Iterator}\n   */\n  nodeEntries() {\n    const iterator = this._nodes.values();\n\n    return new Iterator(() => {\n      const step = iterator.next();\n\n      if (step.done)\n        return step;\n\n      const data = step.value;\n\n      return {value: [data.key, data.attributes], done: false};\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Serialization\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method exporting the target node.\n   *\n   * @param  {any}   node - Target node.\n   * @return {array}      - The serialized node.\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  exportNode(node) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.exportNode: could not find the \"${node}\" node in the graph.`);\n\n    return serializeNode(node, data);\n  }\n\n  /**\n   * Method exporting the target edge.\n   *\n   * @param  {any}   edge - Target edge.\n   * @return {array}      - The serialized edge.\n   *\n   * @throws {Error} - Will throw if the edge is not found.\n   */\n  exportEdge(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.exportEdge: could not find the \"${edge}\" edge in the graph.`);\n\n    return serializeEdge(edge, data);\n  }\n\n  /**\n   * Method used to export the whole graph.\n   *\n   * @return {object} - The serialized graph.\n   */\n  export() {\n\n    const nodes = new Array(this._nodes.size);\n\n    let i = 0;\n\n    this._nodes.forEach((data, key) => {\n      nodes[i++] = serializeNode(key, data);\n    });\n\n    const edges = new Array(this._edges.size);\n\n    i = 0;\n\n    this._edges.forEach((data, key) => {\n      edges[i++] = serializeEdge(key, data);\n    });\n\n    return {\n      attributes: this.getAttributes(),\n      nodes,\n      edges\n    };\n  }\n\n  /**\n   * Method used to import a serialized node.\n   *\n   * @param  {object} data   - The serialized node.\n   * @param  {boolean} merge - Whether to merge the given node.\n   * @return {Graph}         - Returns itself for chaining.\n   */\n  importNode(data, merge = false) {\n\n    // Validating\n    const error = validateSerializedNode(data);\n\n    if (error) {\n\n      if (error === 'not-object')\n        throw new InvalidArgumentsGraphError('Graph.importNode: invalid serialized node. A serialized node should be a plain object with at least a \"key\" property.');\n      if (error === 'no-key')\n        throw new InvalidArgumentsGraphError('Graph.importNode: no key provided.');\n      if (error === 'invalid-attributes')\n        throw new InvalidArgumentsGraphError('Graph.importNode: invalid attributes. Attributes should be a plain object, null or omitted.');\n    }\n\n    // Adding the node\n    const {key, attributes = {}} = data;\n\n    if (merge)\n      this.mergeNode(key, attributes);\n    else\n      this.addNode(key, attributes);\n\n    return this;\n  }\n\n  /**\n   * Method used to import a serialized edge.\n   *\n   * @param  {object}  data  - The serialized edge.\n   * @param  {boolean} merge - Whether to merge the given edge.\n   * @return {Graph}         - Returns itself for chaining.\n   */\n  importEdge(data, merge = false) {\n\n    // Validating\n    const error = validateSerializedEdge(data);\n\n    if (error) {\n\n      if (error === 'not-object')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: invalid serialized edge. A serialized edge should be a plain object with at least a \"source\" & \"target\" property.');\n      if (error === 'no-source')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: missing souce.');\n      if (error === 'no-target')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: missing target.');\n      if (error === 'invalid-attributes')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: invalid attributes. Attributes should be a plain object, null or omitted.');\n      if (error === 'invalid-undirected')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: invalid undirected. Undirected should be boolean or omitted.');\n    }\n\n    // Adding the edge\n    const {\n      source,\n      target,\n      attributes = {},\n      undirected = false\n    } = data;\n\n    let method;\n\n    if ('key' in data) {\n      method = merge ?\n        (undirected ? this.mergeUndirectedEdgeWithKey : this.mergeDirectedEdgeWithKey) :\n        (undirected ? this.addUndirectedEdgeWithKey : this.addDirectedEdgeWithKey);\n\n      method.call(\n        this,\n        data.key,\n        source,\n        target,\n        attributes\n      );\n    }\n    else {\n      method = merge ?\n        (undirected ? this.mergeUndirectedEdge : this.mergeDirectedEdge) :\n        (undirected ? this.addUndirectedEdge : this.addDirectedEdge);\n\n      method.call(\n        this,\n        source,\n        target,\n        attributes\n      );\n    }\n\n    return this;\n  }\n\n  /**\n   * Method used to import a serialized graph.\n   *\n   * @param  {object|Graph} data  - The serialized graph.\n   * @param  {boolean}      merge - Whether to merge data.\n   * @return {Graph}              - Returns itself for chaining.\n   */\n  import(data, merge = false) {\n\n    // Importing a Graph instance\n    if (isGraph(data)) {\n\n      this.import(data.export(), merge);\n      return this;\n    }\n\n    // Importing a serialized graph\n    if (!isPlainObject(data))\n      throw new InvalidArgumentsGraphError('Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.');\n\n    if (data.attributes) {\n      if (!isPlainObject(data.attributes))\n        throw new InvalidArgumentsGraphError('Graph.import: invalid attributes. Expecting a plain object.');\n\n      if (merge)\n        this.mergeAttributes(data.attributes);\n      else\n        this.replaceAttributes(data.attributes);\n    }\n\n    // TODO: optimize\n    if (data.nodes)\n      data.nodes.forEach(node => this.importNode(node, merge));\n\n    if (data.edges)\n      data.edges.forEach(edge => this.importEdge(edge, merge));\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Utils\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning a null copy of the graph, i.e. a graph without nodes\n   * & edges but with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The null copy.\n   */\n  nullCopy(options) {\n    return new Graph(assign({}, this._options, options));\n  }\n\n  /**\n   * Method returning an empty copy of the graph, i.e. a graph without edges but\n   * with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The empty copy.\n   */\n  emptyCopy(options) {\n    const graph = new Graph(assign({}, this._options, options));\n\n    this._nodes.forEach((nodeData, key) => {\n      nodeData = new graph.NodeDataClass(key, assign({}, nodeData.attributes));\n      graph._nodes.set(key, nodeData);\n    });\n\n    return graph;\n  }\n\n  /**\n   * Method returning an exact copy of the graph.\n   *\n   * @return {Graph} - The copy.\n   */\n  copy() {\n    const graph = new Graph(this._options);\n    graph.import(this);\n\n    return graph;\n  }\n\n  /**\n   * Method upgrading the graph to a mixed one.\n   *\n   * @return {Graph} - The copy.\n   */\n  upgradeToMixed() {\n    if (this.type === 'mixed')\n      return this;\n\n    // Upgrading node data:\n    // NOTE: maybe this could lead to some de-optimization by usual\n    // JavaScript engines but I cannot be sure of it. Another solution\n    // would be to reinstantiate the classes but this surely has a performance\n    // and memory impact.\n    this._nodes.forEach(data => (data.upgradeToMixed()));\n\n    // Mutating the options & the instance\n    this._options.type = 'mixed';\n    readOnlyProperty(this, 'type', this._options.type);\n    privateProperty(this, 'NodeDataClass', MixedNodeData);\n\n    return this;\n  }\n\n  /**\n   * Method upgrading the graph to a multi one.\n   *\n   * @return {Graph} - The copy.\n   */\n  upgradeToMulti() {\n    if (this.multi)\n      return this;\n\n    // Mutating the options & the instance\n    this._options.multi = true;\n    readOnlyProperty(this, 'multi', true);\n\n    // Upgrading indices\n    upgradeStructureIndexToMulti(this);\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Indexes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to clear the desired index to clear memory.\n   *\n   * @return {Graph}       - Returns itself for chaining.\n   */\n  clearIndex() {\n    clearStructureIndex(this);\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Known methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used by JavaScript to perform JSON serialization.\n   *\n   * @return {object} - The serialized graph.\n   */\n  toJSON() {\n    return this.export();\n  }\n\n  /**\n   * Method used to perform string coercion and returning useful information\n   * about the Graph instance.\n   *\n   * @return {string} - String representation of the graph.\n   */\n  toString() {\n    const pluralOrder = this.order > 1 || this.order === 0,\n          pluralSize = this.size > 1 || this.size === 0;\n\n    return `Graph<${prettyPrint(this.order)} node${pluralOrder ? 's' : ''}, ${prettyPrint(this.size)} edge${pluralSize ? 's' : ''}>`;\n  }\n\n  /**\n   * Method used internally by node's console to display a custom object.\n   *\n   * @return {object} - Formatted object representation of the graph.\n   */\n  inspect() {\n    const nodes = {};\n    this._nodes.forEach((data, key) => {\n      nodes[key] = data.attributes;\n    });\n\n    const edges = {},\n          multiIndex = {};\n\n    this._edges.forEach((data, key) => {\n      const direction = data instanceof UndirectedEdgeData ? '--' : '->';\n\n      let label = '';\n\n      const desc = `(${data.source.key})${direction}(${data.target.key})`;\n\n      if (!data.generatedKey) {\n        label += `[${key}]: `;\n      }\n      else if (this.multi) {\n        if (typeof multiIndex[desc] === 'undefined') {\n          multiIndex[desc] = 0;\n        }\n        else {\n          multiIndex[desc]++;\n        }\n\n        label += `${multiIndex[desc]}. `;\n      }\n\n      label += desc;\n\n      edges[label] = data.attributes;\n    });\n\n    const dummy = {};\n\n    for (const k in this) {\n      if (this.hasOwnProperty(k) &&\n          !EMITTER_PROPS.has(k) &&\n          typeof this[k] !== 'function')\n        dummy[k] = this[k];\n    }\n\n    dummy.attributes = this._attributes;\n    dummy.nodes = nodes;\n    dummy.edges = edges;\n\n    privateProperty(dummy, 'constructor', this.constructor);\n\n    return dummy;\n  }\n}\n\n/**\n * Attaching custom inspect method for node >= 10.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.for('nodejs.util.inspect.custom')] = Graph.prototype.inspect;\n\n/**\n * Attaching methods to the prototype.\n *\n * Here, we are attaching a wide variety of methods to the Graph class'\n * prototype when those are very numerous and when their creation is\n * abstracted.\n */\n\n/**\n * Related to edge addition.\n */\nEDGE_ADD_METHODS.forEach(method => {\n  ['add', 'merge'].forEach(verb => {\n    const name = method.name(verb),\n          fn = verb === 'add' ? addEdge : mergeEdge;\n\n    if (method.generateKey) {\n      Graph.prototype[name] = function(source, target, attributes) {\n        return fn(\n          this,\n          name,\n          true,\n          (method.type || this.type) === 'undirected',\n          null,\n          source,\n          target,\n          attributes\n        );\n      };\n    }\n    else {\n      Graph.prototype[name] = function(edge, source, target, attributes) {\n        return fn(\n          this,\n          name,\n          false,\n          (method.type || this.type) === 'undirected',\n          edge,\n          source,\n          target,\n          attributes\n        );\n      };\n    }\n  });\n});\n\n/**\n * Self iterator.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.iterator] = Graph.prototype.adjacency;\n\n/**\n * Attributes-related.\n */\nattachAttributesMethods(Graph);\n\n/**\n * Edge iteration-related.\n */\nattachEdgeIterationMethods(Graph);\n\n/**\n * Neighbor iteration-related.\n */\nattachNeighborIterationMethods(Graph);\n","/**\n * Graphology Helper Classes\n * ==========================\n *\n * Building some higher-order classes instantiating the graph with\n * predefinite options.\n */\nimport {assign} from './utils';\nimport Graph from './graph';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\n/**\n * Alternative constructors.\n */\nclass DirectedGraph extends Graph {\n  constructor(options) {\n    super(\n      assign({type: 'directed'}, options)\n    );\n  }\n}\nclass UndirectedGraph extends Graph {\n  constructor(options) {\n    super(\n      assign({type: 'undirected'}, options)\n    );\n  }\n}\nclass MultiGraph extends Graph {\n  constructor(options) {\n    super(\n      assign({multi: true}, options)\n    );\n  }\n}\nclass MultiDirectedGraph extends Graph {\n  constructor(options) {\n    super(\n      assign({multi: true, type: 'directed'}, options)\n    );\n  }\n}\nclass MultiUndirectedGraph extends Graph {\n  constructor(options) {\n    super(\n      assign({multi: true, type: 'undirected'}, options)\n    );\n  }\n}\n\n/**\n * Attaching static #.from method to each of the constructors.\n */\nfunction attachStaticFromMethod(Class) {\n\n  /**\n   * Builds a graph from serialized data or another graph's data.\n   *\n   * @param  {Graph|SerializedGraph} data      - Hydratation data.\n   * @param  {object}                [options] - Options.\n   * @return {Class}\n   */\n  Class.from = function(data, options) {\n    const instance = new Class(options);\n    instance.import(data);\n\n    return instance;\n  };\n}\n\nattachStaticFromMethod(Graph);\nattachStaticFromMethod(DirectedGraph);\nattachStaticFromMethod(UndirectedGraph);\nattachStaticFromMethod(MultiGraph);\nattachStaticFromMethod(MultiDirectedGraph);\nattachStaticFromMethod(MultiUndirectedGraph);\n\nGraph.Graph = Graph;\nGraph.DirectedGraph = DirectedGraph;\nGraph.UndirectedGraph = UndirectedGraph;\nGraph.MultiGraph = MultiGraph;\nGraph.MultiDirectedGraph = MultiDirectedGraph;\nGraph.MultiUndirectedGraph = MultiUndirectedGraph;\n\nGraph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;\nGraph.NotFoundGraphError = NotFoundGraphError;\nGraph.UsageGraphError = UsageGraphError;\n\nexport {\n  Graph,\n  DirectedGraph,\n  UndirectedGraph,\n  MultiGraph,\n  MultiDirectedGraph,\n  MultiUndirectedGraph\n};\n","/**\n * Graphology CommonJS Endoint\n * ============================\n *\n * Endpoint for CommonJS modules consumers.\n */\nimport {Graph} from './classes';\n\nexport default Graph;\n"],"names":["assign","target","arguments","i","l","length","k","getMatchingEdge","graph","source","type","sourceData","_nodes","get","edge","out","undirected","isGraph","value","addUndirectedEdgeWithKey","dropNode","isPlainObject","constructor","Object","prettyPrint","integer","string","prettyString","j","privateProperty","name","defineProperty","enumerable","configurable","writable","readOnlyProperty","descriptor","incrementalId","GraphError","message","data","Error","InvalidArgumentsGraphError","captureStackTrace","prototype","NotFoundGraphError","UsageGraphError","MixedNodeData","key","attributes","inDegree","outDegree","undirectedDegree","directedSelfLoops","undirectedSelfLoops","DirectedNodeData","upgradeToMixed","UndirectedNodeData","DirectedEdgeData","generatedKey","UndirectedEdgeData","updateStructureIndex","edgeData","targetData","multi","outKey","inKey","edgeOrSet","Set","add","clearEdgeFromStructureIndex","sourceIndex","set","size","targetIndex","clearStructureIndex","forEach","upgradeStructureIndexToMulti","node","neighbor","edges","attachAttributeGetter","Class","method","EdgeDataClass","element","_edges","attachAttributesGetter","attachAttributeChecker","hasOwnProperty","attachAttributeSetter","emit","meta","attachAttributeUpdater","updater","attachAttributeRemover","attachAttributesReplacer","oldAttributes","before","after","attachAttributesMerger","ATTRIBUTES_METHODS","attacher","attachAttributesMethods","Graph","Iterator","EDGES_ITERATION","direction","collect","object","push","forEachSimple","callback","forEachMulti","createIterator","keys","inner","next","step","done","values","collectForKey","forEachForKey","createIteratorForKey","v","iterator","of","createEdgeArray","take","undirectedSize","directedSize","list","Array","mask","forEachEdge","createEdgeIterator","empty","createEdgeArrayForNode","nodeData","forEachEdgeForNode","fn","createEdgeIteratorForNode","chain","createEdgeArrayForPath","forEachEdgeForPath","createEdgeIteratorForPath","attachEdgeArrayCreator","description","has","attachForEachEdge","forEachName","toUpperCase","slice","attachEdgeIteratorCreator","originalName","attachEdgeIterationMethods","NEIGHBORS_ITERATION","merge","neighbors","createNeighborArrayForNode","forEachInObject","neighborData","forEachInObjectOnce","visited","forEachNeighborForNode","createObjectIterator","createDedupedObjectIterator","createNeighborIterator","nodeHasNeighbor","attachNeighborArrayCreator","node1","node2","attachForEachNeighbor","attachNeighborIteratorCreator","iteratorName","attachNeighborIterationMethods","serializeNode","serialized","serializeEdge","validateSerializedNode","validateSerializedEdge","TYPES","EMITTER_PROPS","EDGE_ADD_METHODS","verb","generateKey","DEFAULTS","allowSelfLoops","edgeKeyGenerator","addEdge","mustGenerateKey","eventData","_edgeKeyGenerator","DataClass","_undirectedSize","_directedSize","mergeEdge","alreadyExistingEdge","alreadyExistingEdgeData","addNode","options","NodeDataClass","Map","prop","_options","hasNode","hasDirectedEdge","hasUndirectedEdge","hasEdge","directedEdge","undefined","undirectedEdge","selfLoops","loops","directedDegree","degree","extremities","opposite","directed","selfLoop","mergeNode","dropEdge","clear","clearEdges","clearIndex","getAttribute","_attributes","getAttributes","hasAttribute","setAttribute","updateAttribute","removeAttribute","replaceAttributes","mergeAttributes","getNodeAttribute","getNodeAttributes","hasNodeAttribute","setNodeAttribute","updateNodeAttribute","removeNodeAttribute","replaceNodeAttributes","mergeNodeAttributes","adjacency","nodes","forEachNode","nodeEntries","exportNode","exportEdge","importNode","error","importEdge","mergeUndirectedEdgeWithKey","mergeDirectedEdgeWithKey","addDirectedEdgeWithKey","call","mergeUndirectedEdge","mergeDirectedEdge","addUndirectedEdge","addDirectedEdge","nullCopy","emptyCopy","copy","upgradeToMulti","toJSON","toString","pluralOrder","order","pluralSize","inspect","multiIndex","label","desc","dummy","EventEmitter","Symbol","DirectedGraph","UndirectedGraph","MultiGraph","MultiDirectedGraph","MultiUndirectedGraph","attachStaticFromMethod","from","instance"],"mappings":"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"}